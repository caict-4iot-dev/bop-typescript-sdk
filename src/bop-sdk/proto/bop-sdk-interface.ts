// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v3.20.3
// source: bop-sdk-interface.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  SdkStatusCode,
  sdkStatusCodeFromJSON,
  sdkStatusCodeToJSON,
} from "./bop-sdk-common";

export const protobufPackage = "bopsdkinterface";

export enum ContractType {
  JAVASCRIPT = 0,
  EVM = 1,
  SYSTEM = 2,
  UNRECOGNIZED = -1,
}

export function contractTypeFromJSON(object: any): ContractType {
  switch (object) {
    case 0:
    case "JAVASCRIPT":
      return ContractType.JAVASCRIPT;
    case 1:
    case "EVM":
      return ContractType.EVM;
    case 2:
    case "SYSTEM":
      return ContractType.SYSTEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ContractType.UNRECOGNIZED;
  }
}

export function contractTypeToJSON(object: ContractType): string {
  switch (object) {
    case ContractType.JAVASCRIPT:
      return "JAVASCRIPT";
    case ContractType.EVM:
      return "EVM";
    case ContractType.SYSTEM:
      return "SYSTEM";
    case ContractType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TxType {
  INCREASE_NONCE = 0,
  RANDOM_NONCE = 1,
  UNRECOGNIZED = -1,
}

export function txTypeFromJSON(object: any): TxType {
  switch (object) {
    case 0:
    case "INCREASE_NONCE":
      return TxType.INCREASE_NONCE;
    case 1:
    case "RANDOM_NONCE":
      return TxType.RANDOM_NONCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TxType.UNRECOGNIZED;
  }
}

export function txTypeToJSON(object: TxType): string {
  switch (object) {
    case TxType.INCREASE_NONCE:
      return "INCREASE_NONCE";
    case TxType.RANDOM_NONCE:
      return "RANDOM_NONCE";
    case TxType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ChainInfo {
  licenseVersion?: string | undefined;
  websocketPort?: number | undefined;
  chainVersion?: string | undefined;
  currentTime?: string | undefined;
  hashType?: string | undefined;
  ledgerVersion?: string | undefined;
  networkId?: string | undefined;
}

export interface GetChainInfoResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: ChainInfo | undefined;
}

export interface GetNetworkIdResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: string | undefined;
}

export interface LedgerHeader {
  seq?: number | undefined;
  hash?: string | undefined;
  previousHash?: string | undefined;
  accountTreeHash?: string | undefined;
  closeTime?: number | undefined;
  consensusValueHash?: string | undefined;
  version?: number | undefined;
  txCount?: number | undefined;
  validatorsHash?: string | undefined;
  feesHash?: string | undefined;
}

export interface LedgerResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: LedgerHeader | undefined;
}

export interface LedgerNumberResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: number | undefined;
}

export interface LedgerLeaderResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: string | undefined;
}

export interface LedgerValidatorsResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: string[] | undefined;
}

export interface LedgerTxHashesResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: string[] | undefined;
}

export interface Contract {
  type?: ContractType | undefined;
  payload?: string | undefined;
}

export interface Signer {
  address?: string | undefined;
  weight?: number | undefined;
}

export enum Signer_Limit {
  SIGNER_NONE = 0,
  SIGNER = 100,
  UNRECOGNIZED = -1,
}

export function signer_LimitFromJSON(object: any): Signer_Limit {
  switch (object) {
    case 0:
    case "SIGNER_NONE":
      return Signer_Limit.SIGNER_NONE;
    case 100:
    case "SIGNER":
      return Signer_Limit.SIGNER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Signer_Limit.UNRECOGNIZED;
  }
}

export function signer_LimitToJSON(object: Signer_Limit): string {
  switch (object) {
    case Signer_Limit.SIGNER_NONE:
      return "SIGNER_NONE";
    case Signer_Limit.SIGNER:
      return "SIGNER";
    case Signer_Limit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OperationTypeThreshold {
  type?: OperationTypeThreshold_Type | undefined;
  threshold?: number | undefined;
}

export enum OperationTypeThreshold_Type {
  UNKNOWN = 0,
  CREATE_ACCOUNT = 1,
  SET_METADATA = 4,
  SET_SIGNER_WEIGHT = 5,
  SET_THRESHOLD = 6,
  PAY_COIN = 7,
  LOG = 8,
  SET_PRIVILEGE = 9,
  UPGRADE_CONTRACT = 10,
  SET_CONTROLLED_AREA = 11,
  AUTHORIZE_TRANSFER = 12,
  UNRECOGNIZED = -1,
}

export function operationTypeThreshold_TypeFromJSON(
  object: any,
): OperationTypeThreshold_Type {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return OperationTypeThreshold_Type.UNKNOWN;
    case 1:
    case "CREATE_ACCOUNT":
      return OperationTypeThreshold_Type.CREATE_ACCOUNT;
    case 4:
    case "SET_METADATA":
      return OperationTypeThreshold_Type.SET_METADATA;
    case 5:
    case "SET_SIGNER_WEIGHT":
      return OperationTypeThreshold_Type.SET_SIGNER_WEIGHT;
    case 6:
    case "SET_THRESHOLD":
      return OperationTypeThreshold_Type.SET_THRESHOLD;
    case 7:
    case "PAY_COIN":
      return OperationTypeThreshold_Type.PAY_COIN;
    case 8:
    case "LOG":
      return OperationTypeThreshold_Type.LOG;
    case 9:
    case "SET_PRIVILEGE":
      return OperationTypeThreshold_Type.SET_PRIVILEGE;
    case 10:
    case "UPGRADE_CONTRACT":
      return OperationTypeThreshold_Type.UPGRADE_CONTRACT;
    case 11:
    case "SET_CONTROLLED_AREA":
      return OperationTypeThreshold_Type.SET_CONTROLLED_AREA;
    case 12:
    case "AUTHORIZE_TRANSFER":
      return OperationTypeThreshold_Type.AUTHORIZE_TRANSFER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperationTypeThreshold_Type.UNRECOGNIZED;
  }
}

export function operationTypeThreshold_TypeToJSON(
  object: OperationTypeThreshold_Type,
): string {
  switch (object) {
    case OperationTypeThreshold_Type.UNKNOWN:
      return "UNKNOWN";
    case OperationTypeThreshold_Type.CREATE_ACCOUNT:
      return "CREATE_ACCOUNT";
    case OperationTypeThreshold_Type.SET_METADATA:
      return "SET_METADATA";
    case OperationTypeThreshold_Type.SET_SIGNER_WEIGHT:
      return "SET_SIGNER_WEIGHT";
    case OperationTypeThreshold_Type.SET_THRESHOLD:
      return "SET_THRESHOLD";
    case OperationTypeThreshold_Type.PAY_COIN:
      return "PAY_COIN";
    case OperationTypeThreshold_Type.LOG:
      return "LOG";
    case OperationTypeThreshold_Type.SET_PRIVILEGE:
      return "SET_PRIVILEGE";
    case OperationTypeThreshold_Type.UPGRADE_CONTRACT:
      return "UPGRADE_CONTRACT";
    case OperationTypeThreshold_Type.SET_CONTROLLED_AREA:
      return "SET_CONTROLLED_AREA";
    case OperationTypeThreshold_Type.AUTHORIZE_TRANSFER:
      return "AUTHORIZE_TRANSFER";
    case OperationTypeThreshold_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AccountThreshold {
  txThreshold?: number | undefined;
  typeThresholds?: OperationTypeThreshold[] | undefined;
}

export interface AccountPrivilege {
  masterWeight?: number | undefined;
  signers?: Signer[] | undefined;
  thresholds?: AccountThreshold | undefined;
}

export interface AccountInfo {
  address?: string | undefined;
  balance?: number | undefined;
  nonce?: number | undefined;
  authTransfer?: boolean | undefined;
  metadatasHash?: string | undefined;
  contract?: Contract | undefined;
  priv?: AccountPrivilege | undefined;
}

export interface GetAccountResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: AccountInfo | undefined;
}

export interface KeyPair {
  key?: string | undefined;
  value?: string | undefined;
  version?: number | undefined;
}

export interface GetAccountMetadataResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: KeyPair[] | undefined;
}

export interface GetAccountIncreaseNonceResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: number | undefined;
}

export interface GetAccountBalanceResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: number | undefined;
}

export interface GetAccountPrivResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: AccountPrivilege | undefined;
}

export interface GetTxPoolSizeResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: number | undefined;
}

export interface Signature {
  publicKey?: string | undefined;
  signData?: string | undefined;
}

export interface OperationCreateAccount {
  destAddress?: string | undefined;
  contract?: Contract | undefined;
  priv?: AccountPrivilege | undefined;
  metadatas?: KeyPair[] | undefined;
  initBalance?: number | undefined;
  initInput?: string | undefined;
}

export interface OperationPayCoin {
  destAddress?: string | undefined;
  amount?: number | undefined;
  input?: string | undefined;
}

export interface OperationSetMetadata {
  key?: string | undefined;
  value?: string | undefined;
  /** optional */
  version?: number | undefined;
  deleteFlag?: boolean | undefined;
}

export interface OperationUpgradeContract {
  destAddress?: string | undefined;
  payload?: string | undefined;
  type?: number | undefined;
}

export interface OperationSetSignerWeight {
  /** required, [-1,MAX(UINT32)] -1: indicates no setting */
  masterWeight?: number | undefined;
  /** address:weight, if weight is 0, it indicates deleting this signer */
  signers?: Signer[] | undefined;
}

export interface OperationSetThreshold {
  txThreshold?: number | undefined;
  /** type:threshold, threshold:0 indicates deleting this type */
  typeThresholds?: OperationTypeThreshold[] | undefined;
}

export interface OperationLog {
  topic?: string | undefined;
  datas?: string[] | undefined;
  /** for evm */
  topics?: string[] | undefined;
}

export interface OperationSetPrivilege {
  masterWeight?: string | undefined;
  signers?: Signer[] | undefined;
  txThreshold?: string | undefined;
  typeThresholds?: OperationTypeThreshold[] | undefined;
}

export interface ControlledArea {
  trusted?: ControlledArea_trustFlag | undefined;
  status?: ControlledArea_statusFalg | undefined;
  attributes?: KeyPair[] | undefined;
}

export enum ControlledArea_trustFlag {
  UNCERT = 0,
  TRUSTED = 1,
  UNTRUSTED = 2,
  UNRECOGNIZED = -1,
}

export function controlledArea_trustFlagFromJSON(
  object: any,
): ControlledArea_trustFlag {
  switch (object) {
    case 0:
    case "UNCERT":
      return ControlledArea_trustFlag.UNCERT;
    case 1:
    case "TRUSTED":
      return ControlledArea_trustFlag.TRUSTED;
    case 2:
    case "UNTRUSTED":
      return ControlledArea_trustFlag.UNTRUSTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ControlledArea_trustFlag.UNRECOGNIZED;
  }
}

export function controlledArea_trustFlagToJSON(
  object: ControlledArea_trustFlag,
): string {
  switch (object) {
    case ControlledArea_trustFlag.UNCERT:
      return "UNCERT";
    case ControlledArea_trustFlag.TRUSTED:
      return "TRUSTED";
    case ControlledArea_trustFlag.UNTRUSTED:
      return "UNTRUSTED";
    case ControlledArea_trustFlag.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ControlledArea_statusFalg {
  ENABLED = 0,
  DISABLED = 1,
  UNRECOGNIZED = -1,
}

export function controlledArea_statusFalgFromJSON(
  object: any,
): ControlledArea_statusFalg {
  switch (object) {
    case 0:
    case "ENABLED":
      return ControlledArea_statusFalg.ENABLED;
    case 1:
    case "DISABLED":
      return ControlledArea_statusFalg.DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ControlledArea_statusFalg.UNRECOGNIZED;
  }
}

export function controlledArea_statusFalgToJSON(
  object: ControlledArea_statusFalg,
): string {
  switch (object) {
    case ControlledArea_statusFalg.ENABLED:
      return "ENABLED";
    case ControlledArea_statusFalg.DISABLED:
      return "DISABLED";
    case ControlledArea_statusFalg.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OperationSetControlledArea {
  destAddress?: string | undefined;
  sTrusted?: boolean | undefined;
  sStatus?: boolean | undefined;
  trusted?: ControlledArea_trustFlag | undefined;
  status?: ControlledArea_statusFalg | undefined;
  attributes?: KeyPair[] | undefined;
}

export interface OperationAuthorizeTransfer {
  destAddress?: string | undefined;
  auth?: boolean | undefined;
}

export interface Operation {
  type?: Operation_Type | undefined;
  sourceAddress?: string | undefined;
  metadata?: string | undefined;
  createAccount?: OperationCreateAccount | undefined;
  setMetadata?: OperationSetMetadata | undefined;
  setSignerWeight?: OperationSetSignerWeight | undefined;
  setThreshold?: OperationSetThreshold | undefined;
  payCoin?: OperationPayCoin | undefined;
  log?: OperationLog | undefined;
  setPrivilege?: OperationSetPrivilege | undefined;
  upgradeContract?: OperationUpgradeContract | undefined;
  setControlledArea?: OperationSetControlledArea | undefined;
  authorizeTransfer?: OperationAuthorizeTransfer | undefined;
}

export enum Operation_Type {
  UNKNOWN = 0,
  CREATE_ACCOUNT = 1,
  SET_METADATA = 4,
  SET_SIGNER_WEIGHT = 5,
  SET_THRESHOLD = 6,
  PAY_COIN = 7,
  LOG = 8,
  SET_PRIVILEGE = 9,
  UPGRADE_CONTRACT = 10,
  SET_CONTROLLED_AREA = 11,
  AUTHORIZE_TRANSFER = 12,
  UNRECOGNIZED = -1,
}

export function operation_TypeFromJSON(object: any): Operation_Type {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Operation_Type.UNKNOWN;
    case 1:
    case "CREATE_ACCOUNT":
      return Operation_Type.CREATE_ACCOUNT;
    case 4:
    case "SET_METADATA":
      return Operation_Type.SET_METADATA;
    case 5:
    case "SET_SIGNER_WEIGHT":
      return Operation_Type.SET_SIGNER_WEIGHT;
    case 6:
    case "SET_THRESHOLD":
      return Operation_Type.SET_THRESHOLD;
    case 7:
    case "PAY_COIN":
      return Operation_Type.PAY_COIN;
    case 8:
    case "LOG":
      return Operation_Type.LOG;
    case 9:
    case "SET_PRIVILEGE":
      return Operation_Type.SET_PRIVILEGE;
    case 10:
    case "UPGRADE_CONTRACT":
      return Operation_Type.UPGRADE_CONTRACT;
    case 11:
    case "SET_CONTROLLED_AREA":
      return Operation_Type.SET_CONTROLLED_AREA;
    case 12:
    case "AUTHORIZE_TRANSFER":
      return Operation_Type.AUTHORIZE_TRANSFER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Operation_Type.UNRECOGNIZED;
  }
}

export function operation_TypeToJSON(object: Operation_Type): string {
  switch (object) {
    case Operation_Type.UNKNOWN:
      return "UNKNOWN";
    case Operation_Type.CREATE_ACCOUNT:
      return "CREATE_ACCOUNT";
    case Operation_Type.SET_METADATA:
      return "SET_METADATA";
    case Operation_Type.SET_SIGNER_WEIGHT:
      return "SET_SIGNER_WEIGHT";
    case Operation_Type.SET_THRESHOLD:
      return "SET_THRESHOLD";
    case Operation_Type.PAY_COIN:
      return "PAY_COIN";
    case Operation_Type.LOG:
      return "LOG";
    case Operation_Type.SET_PRIVILEGE:
      return "SET_PRIVILEGE";
    case Operation_Type.UPGRADE_CONTRACT:
      return "UPGRADE_CONTRACT";
    case Operation_Type.SET_CONTROLLED_AREA:
      return "SET_CONTROLLED_AREA";
    case Operation_Type.AUTHORIZE_TRANSFER:
      return "AUTHORIZE_TRANSFER";
    case Operation_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Transaction {
  sourceAddress?: string | undefined;
  feeLimit?: number | undefined;
  gasPrice?: number | undefined;
  nonce?: string | undefined;
  metadata?: string | undefined;
  nonceType?: TxType | undefined;
  maxLedgerSeq?: number | undefined;
  operations?: Operation[] | undefined;
}

export interface ChainTransaction {
  status?: string | undefined;
  incomingTime?: string | undefined;
  hash?: string | undefined;
  signatures?: Signature[] | undefined;
  transaction?: Transaction | undefined;
}

export interface TransactionCacheChain {
  totalCount?: number | undefined;
  transactions?: ChainTransaction[] | undefined;
}

export interface GetTransactionCacheResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: TransactionCacheChain | undefined;
}

export interface TransactionEnv {
  hash?: string | undefined;
  actualFee?: number | undefined;
  closeTime?: number | undefined;
  contractTxHashes?: string[] | undefined;
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  ledgerSeq?: number | undefined;
  signatures?: Signature[] | undefined;
  transaction?: Transaction | undefined;
  txSize?: number | undefined;
  blob?: string | undefined;
}

export interface TransactionHistory {
  totalCount?: number | undefined;
  transactions?: TransactionEnv[] | undefined;
}

export interface GetTransactionHistoryResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: TransactionHistory | undefined;
}

export interface opBaseParams {
  nonceType?: TxType | undefined;
  ceilLedgerSeq?: number | undefined;
  gasPrice?: number | undefined;
  feeLimit?: number | undefined;
  remarks?: string | undefined;
}

export interface GetTxResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: string | undefined;
}

export interface OpCreateAccountParams {
  params?: opBaseParams | undefined;
  destAddress?: string | undefined;
  amount?: number | undefined;
}

export interface OpCreateContractParams {
  params?: opBaseParams | undefined;
  initBalance?: number | undefined;
  type?: ContractType | undefined;
  payload?: string | undefined;
  initInput?: string | undefined;
}

export interface OpGasSendParams {
  params?: opBaseParams | undefined;
  destAddress?: string | undefined;
  amount?: number | undefined;
}

export interface OpGasSend {
  destAddress?: string | undefined;
  amount?: number | undefined;
}

export interface OpContractInvokeParams {
  params?: opBaseParams | undefined;
  contractAddress?: string | undefined;
  input?: string | undefined;
  amount?: number | undefined;
}

export interface OpContractInvoke {
  contractAddress?: string | undefined;
  input?: string | undefined;
  amount?: number | undefined;
}

export interface OpSetMetadataParams {
  params?: opBaseParams | undefined;
  key?: string | undefined;
  value?: string | undefined;
  version?: number | undefined;
  deleteFlag?: boolean | undefined;
}

export interface OpSetPrivParams {
  params?: opBaseParams | undefined;
  masterWeight?: string | undefined;
  signers?: Signer[] | undefined;
  txThreshold?: string | undefined;
  typeThresholds?: OperationTypeThreshold[] | undefined;
}

export interface OpBatchGasSend {
  base?: opBaseParams | undefined;
  params?: OpGasSend[] | undefined;
}

export interface OpBatchContractInvoke {
  base?: opBaseParams | undefined;
  params?: OpContractInvoke[] | undefined;
}

export interface TxBlob {
  transactionBlob?: string | undefined;
  signatures?: Signature[] | undefined;
}

export interface SubmitTransactionParams {
  items?: TxBlob[] | undefined;
}

export interface SubmitTransaction {
  hash?: string | undefined;
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
}

export interface SubmitTransactionResponse {
  successCount?: number | undefined;
  results?: SubmitTransaction[] | undefined;
}

export interface CheckContractAccountResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: boolean | undefined;
}

export interface GetContractInfoResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: Contract | undefined;
}

export interface SignerSignResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: Signature | undefined;
}

export interface OffLineTxResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: TxBlob | undefined;
}

export interface TestTransaction {
  transactionJson?: Transaction | undefined;
  signatureNumber?: number | undefined;
}

export interface TestTransactionRequest {
  items?: TestTransaction[] | undefined;
}

export interface TestTransactionResult {
  stat?: TestTransactionResult_Stat | undefined;
  hash?: string | undefined;
  txs?: TestTransactionResult_TestTx[] | undefined;
}

export interface TestTransactionResult_Stat {
  applyTime?: number | undefined;
  memoryUsage?: number | undefined;
  stackUsage?: number | undefined;
  step?: number | undefined;
}

export interface TestTransactionResult_TransactionEnv {
  transaction?: Transaction | undefined;
}

export interface TestTransactionResult_TestTx {
  gas?: number | undefined;
  transactionEnv?: TestTransactionResult_TransactionEnv | undefined;
  actualFee?: number | undefined;
}

export interface TestTransactionResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: TestTransactionResult | undefined;
}

export interface CallContractRequest {
  contractAddress?: string | undefined;
  input?: string | undefined;
  feeLimit?: number | undefined;
  gasPrice?: number | undefined;
  sourceAddress?: string | undefined;
  optType?: number | undefined;
}

export interface CallContractResultSystem {
  queryRets?: QueryReturnSystem[] | undefined;
}

export interface QueryReturnSystem {
  error?: Error | undefined;
  result?: SystemContractResult | undefined;
}

export interface SystemContractResult {
  data?: string | undefined;
}

export interface CallContractResultJs {
  queryRets?: QueryReturnJs[] | undefined;
}

/** 查询返回消息 */
export interface QueryReturnJs {
  error?: Error | undefined;
  result?: JsContractResult | undefined;
}

export interface JsContractResult {
  /** "string" 或 "bool" */
  type?: string | undefined;
  value?: string | undefined;
}

export interface CallContractResultEvm {
  queryRets?: QueryReturnEvm[] | undefined;
}

export interface QueryReturnEvm {
  error?: Error | undefined;
  result?: EvmContractResult | undefined;
}

export interface EvmContractResult {
  code?: number | undefined;
  data?: string | undefined;
  desc?: string | undefined;
  eumcode?: string | undefined;
  gasused?: number | undefined;
}

/** 错误消息 */
export interface Error {
  data?: string | undefined;
}

export interface QueryReturn {
  error?: string | undefined;
  result?: string | undefined;
}

export interface CallContractResult {
  queryRets?: QueryReturn[] | undefined;
}

export interface CallContractResponse {
  trace?: string | undefined;
  result?: CallContractResult | undefined;
  success?: boolean | undefined;
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
}

function createBaseChainInfo(): ChainInfo {
  return {
    licenseVersion: "",
    websocketPort: 0,
    chainVersion: "",
    currentTime: "",
    hashType: "",
    ledgerVersion: "",
    networkId: "",
  };
}

export const ChainInfo: MessageFns<ChainInfo> = {
  encode(
    message: ChainInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.licenseVersion !== undefined && message.licenseVersion !== "") {
      writer.uint32(10).string(message.licenseVersion);
    }
    if (message.websocketPort !== undefined && message.websocketPort !== 0) {
      writer.uint32(16).int64(message.websocketPort);
    }
    if (message.chainVersion !== undefined && message.chainVersion !== "") {
      writer.uint32(26).string(message.chainVersion);
    }
    if (message.currentTime !== undefined && message.currentTime !== "") {
      writer.uint32(34).string(message.currentTime);
    }
    if (message.hashType !== undefined && message.hashType !== "") {
      writer.uint32(42).string(message.hashType);
    }
    if (message.ledgerVersion !== undefined && message.ledgerVersion !== "") {
      writer.uint32(50).string(message.ledgerVersion);
    }
    if (message.networkId !== undefined && message.networkId !== "") {
      writer.uint32(58).string(message.networkId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.licenseVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.websocketPort = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chainVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currentTime = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hashType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ledgerVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.networkId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainInfo {
    return {
      licenseVersion: isSet(object.license_version)
        ? globalThis.String(object.license_version)
        : "",
      websocketPort: isSet(object.websocket_port)
        ? globalThis.Number(object.websocket_port)
        : 0,
      chainVersion: isSet(object.chain_version)
        ? globalThis.String(object.chain_version)
        : "",
      currentTime: isSet(object.current_time)
        ? globalThis.String(object.current_time)
        : "",
      hashType: isSet(object.hash_type)
        ? globalThis.String(object.hash_type)
        : "",
      ledgerVersion: isSet(object.ledger_version)
        ? globalThis.String(object.ledger_version)
        : "",
      networkId: isSet(object.network_id)
        ? globalThis.String(object.network_id)
        : "",
    };
  },

  toJSON(message: ChainInfo): unknown {
    const obj: any = {};
    if (message.licenseVersion !== undefined && message.licenseVersion !== "") {
      obj.license_version = message.licenseVersion;
    }
    if (message.websocketPort !== undefined && message.websocketPort !== 0) {
      obj.websocket_port = Math.round(message.websocketPort);
    }
    if (message.chainVersion !== undefined && message.chainVersion !== "") {
      obj.chain_version = message.chainVersion;
    }
    if (message.currentTime !== undefined && message.currentTime !== "") {
      obj.current_time = message.currentTime;
    }
    if (message.hashType !== undefined && message.hashType !== "") {
      obj.hash_type = message.hashType;
    }
    if (message.ledgerVersion !== undefined && message.ledgerVersion !== "") {
      obj.ledger_version = message.ledgerVersion;
    }
    if (message.networkId !== undefined && message.networkId !== "") {
      obj.network_id = message.networkId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainInfo>, I>>(base?: I): ChainInfo {
    return ChainInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainInfo>, I>>(
    object: I,
  ): ChainInfo {
    const message = createBaseChainInfo();
    message.licenseVersion = object.licenseVersion ?? "";
    message.websocketPort = object.websocketPort ?? 0;
    message.chainVersion = object.chainVersion ?? "";
    message.currentTime = object.currentTime ?? "";
    message.hashType = object.hashType ?? "";
    message.ledgerVersion = object.ledgerVersion ?? "";
    message.networkId = object.networkId ?? "";
    return message;
  },
};

function createBaseGetChainInfoResponse(): GetChainInfoResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const GetChainInfoResponse: MessageFns<GetChainInfoResponse> = {
  encode(
    message: GetChainInfoResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined) {
      ChainInfo.encode(message.result, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetChainInfoResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = ChainInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainInfoResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result)
        ? ChainInfo.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: GetChainInfoResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined) {
      obj.result = ChainInfo.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChainInfoResponse>, I>>(
    base?: I,
  ): GetChainInfoResponse {
    return GetChainInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChainInfoResponse>, I>>(
    object: I,
  ): GetChainInfoResponse {
    const message = createBaseGetChainInfoResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? ChainInfo.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseGetNetworkIdResponse(): GetNetworkIdResponse {
  return { errorCode: 0, errorDesc: "", result: "" };
}

export const GetNetworkIdResponse: MessageFns<GetNetworkIdResponse> = {
  encode(
    message: GetNetworkIdResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined && message.result !== "") {
      writer.uint32(26).string(message.result);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetNetworkIdResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNetworkIdResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result) ? globalThis.String(object.result) : "",
    };
  },

  toJSON(message: GetNetworkIdResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined && message.result !== "") {
      obj.result = message.result;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNetworkIdResponse>, I>>(
    base?: I,
  ): GetNetworkIdResponse {
    return GetNetworkIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNetworkIdResponse>, I>>(
    object: I,
  ): GetNetworkIdResponse {
    const message = createBaseGetNetworkIdResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result = object.result ?? "";
    return message;
  },
};

function createBaseLedgerHeader(): LedgerHeader {
  return {
    seq: 0,
    hash: "",
    previousHash: "",
    accountTreeHash: "",
    closeTime: 0,
    consensusValueHash: "",
    version: 0,
    txCount: 0,
    validatorsHash: "",
    feesHash: "",
  };
}

export const LedgerHeader: MessageFns<LedgerHeader> = {
  encode(
    message: LedgerHeader,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.seq !== undefined && message.seq !== 0) {
      writer.uint32(8).int64(message.seq);
    }
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    if (message.previousHash !== undefined && message.previousHash !== "") {
      writer.uint32(26).string(message.previousHash);
    }
    if (
      message.accountTreeHash !== undefined &&
      message.accountTreeHash !== ""
    ) {
      writer.uint32(34).string(message.accountTreeHash);
    }
    if (message.closeTime !== undefined && message.closeTime !== 0) {
      writer.uint32(40).int64(message.closeTime);
    }
    if (
      message.consensusValueHash !== undefined &&
      message.consensusValueHash !== ""
    ) {
      writer.uint32(50).string(message.consensusValueHash);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(56).int64(message.version);
    }
    if (message.txCount !== undefined && message.txCount !== 0) {
      writer.uint32(64).int64(message.txCount);
    }
    if (message.validatorsHash !== undefined && message.validatorsHash !== "") {
      writer.uint32(74).string(message.validatorsHash);
    }
    if (message.feesHash !== undefined && message.feesHash !== "") {
      writer.uint32(82).string(message.feesHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LedgerHeader {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seq = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.previousHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accountTreeHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.closeTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.consensusValueHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.txCount = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.validatorsHash = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.feesHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerHeader {
    return {
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      previousHash: isSet(object.previous_hash)
        ? globalThis.String(object.previous_hash)
        : "",
      accountTreeHash: isSet(object.account_tree_hash)
        ? globalThis.String(object.account_tree_hash)
        : "",
      closeTime: isSet(object.close_time)
        ? globalThis.Number(object.close_time)
        : 0,
      consensusValueHash: isSet(object.consensus_value_hash)
        ? globalThis.String(object.consensus_value_hash)
        : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      txCount: isSet(object.tx_count) ? globalThis.Number(object.tx_count) : 0,
      validatorsHash: isSet(object.validators_hash)
        ? globalThis.String(object.validators_hash)
        : "",
      feesHash: isSet(object.fees_hash)
        ? globalThis.String(object.fees_hash)
        : "",
    };
  },

  toJSON(message: LedgerHeader): unknown {
    const obj: any = {};
    if (message.seq !== undefined && message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.previousHash !== undefined && message.previousHash !== "") {
      obj.previous_hash = message.previousHash;
    }
    if (
      message.accountTreeHash !== undefined &&
      message.accountTreeHash !== ""
    ) {
      obj.account_tree_hash = message.accountTreeHash;
    }
    if (message.closeTime !== undefined && message.closeTime !== 0) {
      obj.close_time = Math.round(message.closeTime);
    }
    if (
      message.consensusValueHash !== undefined &&
      message.consensusValueHash !== ""
    ) {
      obj.consensus_value_hash = message.consensusValueHash;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.txCount !== undefined && message.txCount !== 0) {
      obj.tx_count = Math.round(message.txCount);
    }
    if (message.validatorsHash !== undefined && message.validatorsHash !== "") {
      obj.validators_hash = message.validatorsHash;
    }
    if (message.feesHash !== undefined && message.feesHash !== "") {
      obj.fees_hash = message.feesHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerHeader>, I>>(
    base?: I,
  ): LedgerHeader {
    return LedgerHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerHeader>, I>>(
    object: I,
  ): LedgerHeader {
    const message = createBaseLedgerHeader();
    message.seq = object.seq ?? 0;
    message.hash = object.hash ?? "";
    message.previousHash = object.previousHash ?? "";
    message.accountTreeHash = object.accountTreeHash ?? "";
    message.closeTime = object.closeTime ?? 0;
    message.consensusValueHash = object.consensusValueHash ?? "";
    message.version = object.version ?? 0;
    message.txCount = object.txCount ?? 0;
    message.validatorsHash = object.validatorsHash ?? "";
    message.feesHash = object.feesHash ?? "";
    return message;
  },
};

function createBaseLedgerResponse(): LedgerResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const LedgerResponse: MessageFns<LedgerResponse> = {
  encode(
    message: LedgerResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined) {
      LedgerHeader.encode(message.result, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LedgerResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = LedgerHeader.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result)
        ? LedgerHeader.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: LedgerResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined) {
      obj.result = LedgerHeader.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerResponse>, I>>(
    base?: I,
  ): LedgerResponse {
    return LedgerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerResponse>, I>>(
    object: I,
  ): LedgerResponse {
    const message = createBaseLedgerResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? LedgerHeader.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseLedgerNumberResponse(): LedgerNumberResponse {
  return { errorCode: 0, errorDesc: "", result: 0 };
}

export const LedgerNumberResponse: MessageFns<LedgerNumberResponse> = {
  encode(
    message: LedgerNumberResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(24).int64(message.result);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LedgerNumberResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerNumberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.result = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerNumberResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result) ? globalThis.Number(object.result) : 0,
    };
  },

  toJSON(message: LedgerNumberResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined && message.result !== 0) {
      obj.result = Math.round(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerNumberResponse>, I>>(
    base?: I,
  ): LedgerNumberResponse {
    return LedgerNumberResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerNumberResponse>, I>>(
    object: I,
  ): LedgerNumberResponse {
    const message = createBaseLedgerNumberResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseLedgerLeaderResponse(): LedgerLeaderResponse {
  return { errorCode: 0, errorDesc: "", result: "" };
}

export const LedgerLeaderResponse: MessageFns<LedgerLeaderResponse> = {
  encode(
    message: LedgerLeaderResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined && message.result !== "") {
      writer.uint32(26).string(message.result);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LedgerLeaderResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerLeaderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerLeaderResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result) ? globalThis.String(object.result) : "",
    };
  },

  toJSON(message: LedgerLeaderResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined && message.result !== "") {
      obj.result = message.result;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerLeaderResponse>, I>>(
    base?: I,
  ): LedgerLeaderResponse {
    return LedgerLeaderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerLeaderResponse>, I>>(
    object: I,
  ): LedgerLeaderResponse {
    const message = createBaseLedgerLeaderResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result = object.result ?? "";
    return message;
  },
};

function createBaseLedgerValidatorsResponse(): LedgerValidatorsResponse {
  return { errorCode: 0, errorDesc: "", result: [] };
}

export const LedgerValidatorsResponse: MessageFns<LedgerValidatorsResponse> = {
  encode(
    message: LedgerValidatorsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined && message.result.length !== 0) {
      for (const v of message.result) {
        writer.uint32(26).string(v!);
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LedgerValidatorsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerValidatorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.result!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerValidatorsResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: LedgerValidatorsResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result?.length) {
      obj.result = message.result;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerValidatorsResponse>, I>>(
    base?: I,
  ): LedgerValidatorsResponse {
    return LedgerValidatorsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerValidatorsResponse>, I>>(
    object: I,
  ): LedgerValidatorsResponse {
    const message = createBaseLedgerValidatorsResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result = object.result?.map((e) => e) || [];
    return message;
  },
};

function createBaseLedgerTxHashesResponse(): LedgerTxHashesResponse {
  return { errorCode: 0, errorDesc: "", result: [] };
}

export const LedgerTxHashesResponse: MessageFns<LedgerTxHashesResponse> = {
  encode(
    message: LedgerTxHashesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined && message.result.length !== 0) {
      for (const v of message.result) {
        writer.uint32(26).string(v!);
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LedgerTxHashesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerTxHashesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.result!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerTxHashesResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: LedgerTxHashesResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result?.length) {
      obj.result = message.result;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerTxHashesResponse>, I>>(
    base?: I,
  ): LedgerTxHashesResponse {
    return LedgerTxHashesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerTxHashesResponse>, I>>(
    object: I,
  ): LedgerTxHashesResponse {
    const message = createBaseLedgerTxHashesResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result = object.result?.map((e) => e) || [];
    return message;
  },
};

function createBaseContract(): Contract {
  return { type: 0, payload: "" };
}

export const Contract: MessageFns<Contract> = {
  encode(
    message: Contract,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload !== undefined && message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Contract {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Contract {
    return {
      type: isSet(object.type) ? contractTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
    };
  },

  toJSON(message: Contract): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = contractTypeToJSON(message.type);
    }
    if (message.payload !== undefined && message.payload !== "") {
      obj.payload = message.payload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Contract>, I>>(base?: I): Contract {
    return Contract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Contract>, I>>(object: I): Contract {
    const message = createBaseContract();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? "";
    return message;
  },
};

function createBaseSigner(): Signer {
  return { address: "", weight: 0 };
}

export const Signer: MessageFns<Signer> = {
  encode(
    message: Signer,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.address !== undefined && message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.weight !== undefined && message.weight !== 0) {
      writer.uint32(16).int64(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signer {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.weight = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signer {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: Signer): unknown {
    const obj: any = {};
    if (message.address !== undefined && message.address !== "") {
      obj.address = message.address;
    }
    if (message.weight !== undefined && message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Signer>, I>>(base?: I): Signer {
    return Signer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Signer>, I>>(object: I): Signer {
    const message = createBaseSigner();
    message.address = object.address ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseOperationTypeThreshold(): OperationTypeThreshold {
  return { type: 0, threshold: 0 };
}

export const OperationTypeThreshold: MessageFns<OperationTypeThreshold> = {
  encode(
    message: OperationTypeThreshold,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.threshold !== undefined && message.threshold !== 0) {
      writer.uint32(16).int64(message.threshold);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationTypeThreshold {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationTypeThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.threshold = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationTypeThreshold {
    return {
      type: isSet(object.type)
        ? operationTypeThreshold_TypeFromJSON(object.type)
        : 0,
      threshold: isSet(object.threshold)
        ? globalThis.Number(object.threshold)
        : 0,
    };
  },

  toJSON(message: OperationTypeThreshold): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = operationTypeThreshold_TypeToJSON(message.type);
    }
    if (message.threshold !== undefined && message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationTypeThreshold>, I>>(
    base?: I,
  ): OperationTypeThreshold {
    return OperationTypeThreshold.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationTypeThreshold>, I>>(
    object: I,
  ): OperationTypeThreshold {
    const message = createBaseOperationTypeThreshold();
    message.type = object.type ?? 0;
    message.threshold = object.threshold ?? 0;
    return message;
  },
};

function createBaseAccountThreshold(): AccountThreshold {
  return { txThreshold: 0, typeThresholds: [] };
}

export const AccountThreshold: MessageFns<AccountThreshold> = {
  encode(
    message: AccountThreshold,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.txThreshold !== undefined && message.txThreshold !== 0) {
      writer.uint32(8).int64(message.txThreshold);
    }
    if (
      message.typeThresholds !== undefined &&
      message.typeThresholds.length !== 0
    ) {
      for (const v of message.typeThresholds) {
        OperationTypeThreshold.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountThreshold {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txThreshold = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = OperationTypeThreshold.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.typeThresholds!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountThreshold {
    return {
      txThreshold: isSet(object.tx_threshold)
        ? globalThis.Number(object.tx_threshold)
        : 0,
      typeThresholds: globalThis.Array.isArray(object?.type_thresholds)
        ? object.type_thresholds.map((e: any) =>
            OperationTypeThreshold.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: AccountThreshold): unknown {
    const obj: any = {};
    if (message.txThreshold !== undefined && message.txThreshold !== 0) {
      obj.tx_threshold = Math.round(message.txThreshold);
    }
    if (message.typeThresholds?.length) {
      obj.type_thresholds = message.typeThresholds.map((e) =>
        OperationTypeThreshold.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountThreshold>, I>>(
    base?: I,
  ): AccountThreshold {
    return AccountThreshold.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountThreshold>, I>>(
    object: I,
  ): AccountThreshold {
    const message = createBaseAccountThreshold();
    message.txThreshold = object.txThreshold ?? 0;
    message.typeThresholds =
      object.typeThresholds?.map((e) =>
        OperationTypeThreshold.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseAccountPrivilege(): AccountPrivilege {
  return { masterWeight: 0, signers: [], thresholds: undefined };
}

export const AccountPrivilege: MessageFns<AccountPrivilege> = {
  encode(
    message: AccountPrivilege,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.masterWeight !== undefined && message.masterWeight !== 0) {
      writer.uint32(8).int64(message.masterWeight);
    }
    if (message.signers !== undefined && message.signers.length !== 0) {
      for (const v of message.signers) {
        Signer.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.thresholds !== undefined) {
      AccountThreshold.encode(
        message.thresholds,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountPrivilege {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountPrivilege();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.masterWeight = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = Signer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signers!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thresholds = AccountThreshold.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountPrivilege {
    return {
      masterWeight: isSet(object.master_weight)
        ? globalThis.Number(object.master_weight)
        : 0,
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => Signer.fromJSON(e))
        : [],
      thresholds: isSet(object.thresholds)
        ? AccountThreshold.fromJSON(object.thresholds)
        : undefined,
    };
  },

  toJSON(message: AccountPrivilege): unknown {
    const obj: any = {};
    if (message.masterWeight !== undefined && message.masterWeight !== 0) {
      obj.master_weight = Math.round(message.masterWeight);
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    if (message.thresholds !== undefined) {
      obj.thresholds = AccountThreshold.toJSON(message.thresholds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountPrivilege>, I>>(
    base?: I,
  ): AccountPrivilege {
    return AccountPrivilege.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountPrivilege>, I>>(
    object: I,
  ): AccountPrivilege {
    const message = createBaseAccountPrivilege();
    message.masterWeight = object.masterWeight ?? 0;
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    message.thresholds =
      object.thresholds !== undefined && object.thresholds !== null
        ? AccountThreshold.fromPartial(object.thresholds)
        : undefined;
    return message;
  },
};

function createBaseAccountInfo(): AccountInfo {
  return {
    address: "",
    balance: 0,
    nonce: 0,
    authTransfer: false,
    metadatasHash: "",
    contract: undefined,
    priv: undefined,
  };
}

export const AccountInfo: MessageFns<AccountInfo> = {
  encode(
    message: AccountInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.address !== undefined && message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.balance !== undefined && message.balance !== 0) {
      writer.uint32(16).int64(message.balance);
    }
    if (message.nonce !== undefined && message.nonce !== 0) {
      writer.uint32(24).int64(message.nonce);
    }
    if (message.authTransfer !== undefined && message.authTransfer !== false) {
      writer.uint32(32).bool(message.authTransfer);
    }
    if (message.metadatasHash !== undefined && message.metadatasHash !== "") {
      writer.uint32(42).string(message.metadatasHash);
    }
    if (message.contract !== undefined) {
      Contract.encode(message.contract, writer.uint32(50).fork()).join();
    }
    if (message.priv !== undefined) {
      AccountPrivilege.encode(message.priv, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.balance = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nonce = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.authTransfer = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadatasHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.contract = Contract.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.priv = AccountPrivilege.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountInfo {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      authTransfer: isSet(object.auth_transfer)
        ? globalThis.Boolean(object.auth_transfer)
        : false,
      metadatasHash: isSet(object.metadatas_hash)
        ? globalThis.String(object.metadatas_hash)
        : "",
      contract: isSet(object.contract)
        ? Contract.fromJSON(object.contract)
        : undefined,
      priv: isSet(object.priv)
        ? AccountPrivilege.fromJSON(object.priv)
        : undefined,
    };
  },

  toJSON(message: AccountInfo): unknown {
    const obj: any = {};
    if (message.address !== undefined && message.address !== "") {
      obj.address = message.address;
    }
    if (message.balance !== undefined && message.balance !== 0) {
      obj.balance = Math.round(message.balance);
    }
    if (message.nonce !== undefined && message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.authTransfer !== undefined && message.authTransfer !== false) {
      obj.auth_transfer = message.authTransfer;
    }
    if (message.metadatasHash !== undefined && message.metadatasHash !== "") {
      obj.metadatas_hash = message.metadatasHash;
    }
    if (message.contract !== undefined) {
      obj.contract = Contract.toJSON(message.contract);
    }
    if (message.priv !== undefined) {
      obj.priv = AccountPrivilege.toJSON(message.priv);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountInfo>, I>>(base?: I): AccountInfo {
    return AccountInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountInfo>, I>>(
    object: I,
  ): AccountInfo {
    const message = createBaseAccountInfo();
    message.address = object.address ?? "";
    message.balance = object.balance ?? 0;
    message.nonce = object.nonce ?? 0;
    message.authTransfer = object.authTransfer ?? false;
    message.metadatasHash = object.metadatasHash ?? "";
    message.contract =
      object.contract !== undefined && object.contract !== null
        ? Contract.fromPartial(object.contract)
        : undefined;
    message.priv =
      object.priv !== undefined && object.priv !== null
        ? AccountPrivilege.fromPartial(object.priv)
        : undefined;
    return message;
  },
};

function createBaseGetAccountResponse(): GetAccountResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const GetAccountResponse: MessageFns<GetAccountResponse> = {
  encode(
    message: GetAccountResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined) {
      AccountInfo.encode(message.result, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAccountResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = AccountInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccountResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result)
        ? AccountInfo.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: GetAccountResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined) {
      obj.result = AccountInfo.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAccountResponse>, I>>(
    base?: I,
  ): GetAccountResponse {
    return GetAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAccountResponse>, I>>(
    object: I,
  ): GetAccountResponse {
    const message = createBaseGetAccountResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? AccountInfo.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseKeyPair(): KeyPair {
  return { key: "", value: "", version: 0 };
}

export const KeyPair: MessageFns<KeyPair> = {
  encode(
    message: KeyPair,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(24).int64(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyPair {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyPair {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: KeyPair): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyPair>, I>>(base?: I): KeyPair {
    return KeyPair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyPair>, I>>(object: I): KeyPair {
    const message = createBaseKeyPair();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseGetAccountMetadataResponse(): GetAccountMetadataResponse {
  return { errorCode: 0, errorDesc: "", result: [] };
}

export const GetAccountMetadataResponse: MessageFns<GetAccountMetadataResponse> =
  {
    encode(
      message: GetAccountMetadataResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(8).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(18).string(message.errorDesc);
      }
      if (message.result !== undefined && message.result.length !== 0) {
        for (const v of message.result) {
          KeyPair.encode(v!, writer.uint32(26).fork()).join();
        }
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetAccountMetadataResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetAccountMetadataResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            const el = KeyPair.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.result!.push(el);
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetAccountMetadataResponse {
      return {
        errorCode: isSet(object.error_code)
          ? sdkStatusCodeFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
        result: globalThis.Array.isArray(object?.result)
          ? object.result.map((e: any) => KeyPair.fromJSON(e))
          : [],
      };
    },

    toJSON(message: GetAccountMetadataResponse): unknown {
      const obj: any = {};
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = sdkStatusCodeToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      if (message.result?.length) {
        obj.result = message.result.map((e) => KeyPair.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetAccountMetadataResponse>, I>>(
      base?: I,
    ): GetAccountMetadataResponse {
      return GetAccountMetadataResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetAccountMetadataResponse>, I>>(
      object: I,
    ): GetAccountMetadataResponse {
      const message = createBaseGetAccountMetadataResponse();
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      message.result = object.result?.map((e) => KeyPair.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseGetAccountIncreaseNonceResponse(): GetAccountIncreaseNonceResponse {
  return { errorCode: 0, errorDesc: "", result: 0 };
}

export const GetAccountIncreaseNonceResponse: MessageFns<GetAccountIncreaseNonceResponse> =
  {
    encode(
      message: GetAccountIncreaseNonceResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(8).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(18).string(message.errorDesc);
      }
      if (message.result !== undefined && message.result !== 0) {
        writer.uint32(24).int64(message.result);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetAccountIncreaseNonceResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetAccountIncreaseNonceResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.result = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetAccountIncreaseNonceResponse {
      return {
        errorCode: isSet(object.error_code)
          ? sdkStatusCodeFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
        result: isSet(object.result) ? globalThis.Number(object.result) : 0,
      };
    },

    toJSON(message: GetAccountIncreaseNonceResponse): unknown {
      const obj: any = {};
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = sdkStatusCodeToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      if (message.result !== undefined && message.result !== 0) {
        obj.result = Math.round(message.result);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetAccountIncreaseNonceResponse>, I>>(
      base?: I,
    ): GetAccountIncreaseNonceResponse {
      return GetAccountIncreaseNonceResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<GetAccountIncreaseNonceResponse>, I>,
    >(object: I): GetAccountIncreaseNonceResponse {
      const message = createBaseGetAccountIncreaseNonceResponse();
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      message.result = object.result ?? 0;
      return message;
    },
  };

function createBaseGetAccountBalanceResponse(): GetAccountBalanceResponse {
  return { errorCode: 0, errorDesc: "", result: 0 };
}

export const GetAccountBalanceResponse: MessageFns<GetAccountBalanceResponse> =
  {
    encode(
      message: GetAccountBalanceResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(8).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(18).string(message.errorDesc);
      }
      if (message.result !== undefined && message.result !== 0) {
        writer.uint32(24).int64(message.result);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetAccountBalanceResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetAccountBalanceResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.result = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetAccountBalanceResponse {
      return {
        errorCode: isSet(object.error_code)
          ? sdkStatusCodeFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
        result: isSet(object.result) ? globalThis.Number(object.result) : 0,
      };
    },

    toJSON(message: GetAccountBalanceResponse): unknown {
      const obj: any = {};
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = sdkStatusCodeToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      if (message.result !== undefined && message.result !== 0) {
        obj.result = Math.round(message.result);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetAccountBalanceResponse>, I>>(
      base?: I,
    ): GetAccountBalanceResponse {
      return GetAccountBalanceResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetAccountBalanceResponse>, I>>(
      object: I,
    ): GetAccountBalanceResponse {
      const message = createBaseGetAccountBalanceResponse();
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      message.result = object.result ?? 0;
      return message;
    },
  };

function createBaseGetAccountPrivResponse(): GetAccountPrivResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const GetAccountPrivResponse: MessageFns<GetAccountPrivResponse> = {
  encode(
    message: GetAccountPrivResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined) {
      AccountPrivilege.encode(message.result, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAccountPrivResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccountPrivResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = AccountPrivilege.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccountPrivResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result)
        ? AccountPrivilege.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: GetAccountPrivResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined) {
      obj.result = AccountPrivilege.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAccountPrivResponse>, I>>(
    base?: I,
  ): GetAccountPrivResponse {
    return GetAccountPrivResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAccountPrivResponse>, I>>(
    object: I,
  ): GetAccountPrivResponse {
    const message = createBaseGetAccountPrivResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? AccountPrivilege.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseGetTxPoolSizeResponse(): GetTxPoolSizeResponse {
  return { errorCode: 0, errorDesc: "", result: 0 };
}

export const GetTxPoolSizeResponse: MessageFns<GetTxPoolSizeResponse> = {
  encode(
    message: GetTxPoolSizeResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(24).int64(message.result);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetTxPoolSizeResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTxPoolSizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.result = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTxPoolSizeResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result) ? globalThis.Number(object.result) : 0,
    };
  },

  toJSON(message: GetTxPoolSizeResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined && message.result !== 0) {
      obj.result = Math.round(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTxPoolSizeResponse>, I>>(
    base?: I,
  ): GetTxPoolSizeResponse {
    return GetTxPoolSizeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTxPoolSizeResponse>, I>>(
    object: I,
  ): GetTxPoolSizeResponse {
    const message = createBaseGetTxPoolSizeResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseSignature(): Signature {
  return { publicKey: "", signData: "" };
}

export const Signature: MessageFns<Signature> = {
  encode(
    message: Signature,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.publicKey !== undefined && message.publicKey !== "") {
      writer.uint32(10).string(message.publicKey);
    }
    if (message.signData !== undefined && message.signData !== "") {
      writer.uint32(18).string(message.signData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signature {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signature {
    return {
      publicKey: isSet(object.public_key)
        ? globalThis.String(object.public_key)
        : "",
      signData: isSet(object.sign_data)
        ? globalThis.String(object.sign_data)
        : "",
    };
  },

  toJSON(message: Signature): unknown {
    const obj: any = {};
    if (message.publicKey !== undefined && message.publicKey !== "") {
      obj.public_key = message.publicKey;
    }
    if (message.signData !== undefined && message.signData !== "") {
      obj.sign_data = message.signData;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Signature>, I>>(base?: I): Signature {
    return Signature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Signature>, I>>(
    object: I,
  ): Signature {
    const message = createBaseSignature();
    message.publicKey = object.publicKey ?? "";
    message.signData = object.signData ?? "";
    return message;
  },
};

function createBaseOperationCreateAccount(): OperationCreateAccount {
  return {
    destAddress: "",
    contract: undefined,
    priv: undefined,
    metadatas: [],
    initBalance: 0,
    initInput: "",
  };
}

export const OperationCreateAccount: MessageFns<OperationCreateAccount> = {
  encode(
    message: OperationCreateAccount,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.destAddress !== undefined && message.destAddress !== "") {
      writer.uint32(10).string(message.destAddress);
    }
    if (message.contract !== undefined) {
      Contract.encode(message.contract, writer.uint32(18).fork()).join();
    }
    if (message.priv !== undefined) {
      AccountPrivilege.encode(message.priv, writer.uint32(26).fork()).join();
    }
    if (message.metadatas !== undefined && message.metadatas.length !== 0) {
      for (const v of message.metadatas) {
        KeyPair.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.initBalance !== undefined && message.initBalance !== 0) {
      writer.uint32(40).int64(message.initBalance);
    }
    if (message.initInput !== undefined && message.initInput !== "") {
      writer.uint32(50).string(message.initInput);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationCreateAccount {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationCreateAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contract = Contract.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.priv = AccountPrivilege.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = KeyPair.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.metadatas!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.initBalance = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.initInput = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationCreateAccount {
    return {
      destAddress: isSet(object.dest_address)
        ? globalThis.String(object.dest_address)
        : "",
      contract: isSet(object.contract)
        ? Contract.fromJSON(object.contract)
        : undefined,
      priv: isSet(object.priv)
        ? AccountPrivilege.fromJSON(object.priv)
        : undefined,
      metadatas: globalThis.Array.isArray(object?.metadatas)
        ? object.metadatas.map((e: any) => KeyPair.fromJSON(e))
        : [],
      initBalance: isSet(object.init_balance)
        ? globalThis.Number(object.init_balance)
        : 0,
      initInput: isSet(object.init_input)
        ? globalThis.String(object.init_input)
        : "",
    };
  },

  toJSON(message: OperationCreateAccount): unknown {
    const obj: any = {};
    if (message.destAddress !== undefined && message.destAddress !== "") {
      obj.dest_address = message.destAddress;
    }
    if (message.contract !== undefined) {
      obj.contract = Contract.toJSON(message.contract);
    }
    if (message.priv !== undefined) {
      obj.priv = AccountPrivilege.toJSON(message.priv);
    }
    if (message.metadatas?.length) {
      obj.metadatas = message.metadatas.map((e) => KeyPair.toJSON(e));
    }
    if (message.initBalance !== undefined && message.initBalance !== 0) {
      obj.init_balance = Math.round(message.initBalance);
    }
    if (message.initInput !== undefined && message.initInput !== "") {
      obj.init_input = message.initInput;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationCreateAccount>, I>>(
    base?: I,
  ): OperationCreateAccount {
    return OperationCreateAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationCreateAccount>, I>>(
    object: I,
  ): OperationCreateAccount {
    const message = createBaseOperationCreateAccount();
    message.destAddress = object.destAddress ?? "";
    message.contract =
      object.contract !== undefined && object.contract !== null
        ? Contract.fromPartial(object.contract)
        : undefined;
    message.priv =
      object.priv !== undefined && object.priv !== null
        ? AccountPrivilege.fromPartial(object.priv)
        : undefined;
    message.metadatas =
      object.metadatas?.map((e) => KeyPair.fromPartial(e)) || [];
    message.initBalance = object.initBalance ?? 0;
    message.initInput = object.initInput ?? "";
    return message;
  },
};

function createBaseOperationPayCoin(): OperationPayCoin {
  return { destAddress: "", amount: 0, input: "" };
}

export const OperationPayCoin: MessageFns<OperationPayCoin> = {
  encode(
    message: OperationPayCoin,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.destAddress !== undefined && message.destAddress !== "") {
      writer.uint32(10).string(message.destAddress);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.input !== undefined && message.input !== "") {
      writer.uint32(26).string(message.input);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationPayCoin {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationPayCoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.input = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationPayCoin {
    return {
      destAddress: isSet(object.dest_address)
        ? globalThis.String(object.dest_address)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      input: isSet(object.input) ? globalThis.String(object.input) : "",
    };
  },

  toJSON(message: OperationPayCoin): unknown {
    const obj: any = {};
    if (message.destAddress !== undefined && message.destAddress !== "") {
      obj.dest_address = message.destAddress;
    }
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.input !== undefined && message.input !== "") {
      obj.input = message.input;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationPayCoin>, I>>(
    base?: I,
  ): OperationPayCoin {
    return OperationPayCoin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationPayCoin>, I>>(
    object: I,
  ): OperationPayCoin {
    const message = createBaseOperationPayCoin();
    message.destAddress = object.destAddress ?? "";
    message.amount = object.amount ?? 0;
    message.input = object.input ?? "";
    return message;
  },
};

function createBaseOperationSetMetadata(): OperationSetMetadata {
  return { key: "", value: "", version: 0, deleteFlag: false };
}

export const OperationSetMetadata: MessageFns<OperationSetMetadata> = {
  encode(
    message: OperationSetMetadata,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(24).int64(message.version);
    }
    if (message.deleteFlag !== undefined && message.deleteFlag !== false) {
      writer.uint32(32).bool(message.deleteFlag);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationSetMetadata {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationSetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deleteFlag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationSetMetadata {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      deleteFlag: isSet(object.delete_flag)
        ? globalThis.Boolean(object.delete_flag)
        : false,
    };
  },

  toJSON(message: OperationSetMetadata): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.deleteFlag !== undefined && message.deleteFlag !== false) {
      obj.delete_flag = message.deleteFlag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationSetMetadata>, I>>(
    base?: I,
  ): OperationSetMetadata {
    return OperationSetMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationSetMetadata>, I>>(
    object: I,
  ): OperationSetMetadata {
    const message = createBaseOperationSetMetadata();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.version = object.version ?? 0;
    message.deleteFlag = object.deleteFlag ?? false;
    return message;
  },
};

function createBaseOperationUpgradeContract(): OperationUpgradeContract {
  return { destAddress: "", payload: "", type: 0 };
}

export const OperationUpgradeContract: MessageFns<OperationUpgradeContract> = {
  encode(
    message: OperationUpgradeContract,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.destAddress !== undefined && message.destAddress !== "") {
      writer.uint32(10).string(message.destAddress);
    }
    if (message.payload !== undefined && message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(24).int64(message.type);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationUpgradeContract {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationUpgradeContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationUpgradeContract {
    return {
      destAddress: isSet(object.dest_address)
        ? globalThis.String(object.dest_address)
        : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
    };
  },

  toJSON(message: OperationUpgradeContract): unknown {
    const obj: any = {};
    if (message.destAddress !== undefined && message.destAddress !== "") {
      obj.dest_address = message.destAddress;
    }
    if (message.payload !== undefined && message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationUpgradeContract>, I>>(
    base?: I,
  ): OperationUpgradeContract {
    return OperationUpgradeContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationUpgradeContract>, I>>(
    object: I,
  ): OperationUpgradeContract {
    const message = createBaseOperationUpgradeContract();
    message.destAddress = object.destAddress ?? "";
    message.payload = object.payload ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseOperationSetSignerWeight(): OperationSetSignerWeight {
  return { masterWeight: 0, signers: [] };
}

export const OperationSetSignerWeight: MessageFns<OperationSetSignerWeight> = {
  encode(
    message: OperationSetSignerWeight,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.masterWeight !== undefined && message.masterWeight !== 0) {
      writer.uint32(8).int64(message.masterWeight);
    }
    if (message.signers !== undefined && message.signers.length !== 0) {
      for (const v of message.signers) {
        Signer.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationSetSignerWeight {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationSetSignerWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.masterWeight = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = Signer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationSetSignerWeight {
    return {
      masterWeight: isSet(object.master_weight)
        ? globalThis.Number(object.master_weight)
        : 0,
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => Signer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OperationSetSignerWeight): unknown {
    const obj: any = {};
    if (message.masterWeight !== undefined && message.masterWeight !== 0) {
      obj.master_weight = Math.round(message.masterWeight);
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationSetSignerWeight>, I>>(
    base?: I,
  ): OperationSetSignerWeight {
    return OperationSetSignerWeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationSetSignerWeight>, I>>(
    object: I,
  ): OperationSetSignerWeight {
    const message = createBaseOperationSetSignerWeight();
    message.masterWeight = object.masterWeight ?? 0;
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperationSetThreshold(): OperationSetThreshold {
  return { txThreshold: 0, typeThresholds: [] };
}

export const OperationSetThreshold: MessageFns<OperationSetThreshold> = {
  encode(
    message: OperationSetThreshold,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.txThreshold !== undefined && message.txThreshold !== 0) {
      writer.uint32(8).int64(message.txThreshold);
    }
    if (
      message.typeThresholds !== undefined &&
      message.typeThresholds.length !== 0
    ) {
      for (const v of message.typeThresholds) {
        OperationTypeThreshold.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationSetThreshold {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationSetThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txThreshold = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = OperationTypeThreshold.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.typeThresholds!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationSetThreshold {
    return {
      txThreshold: isSet(object.tx_threshold)
        ? globalThis.Number(object.tx_threshold)
        : 0,
      typeThresholds: globalThis.Array.isArray(object?.typeThresholds)
        ? object.typeThresholds.map((e: any) =>
            OperationTypeThreshold.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: OperationSetThreshold): unknown {
    const obj: any = {};
    if (message.txThreshold !== undefined && message.txThreshold !== 0) {
      obj.tx_threshold = Math.round(message.txThreshold);
    }
    if (message.typeThresholds?.length) {
      obj.typeThresholds = message.typeThresholds.map((e) =>
        OperationTypeThreshold.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationSetThreshold>, I>>(
    base?: I,
  ): OperationSetThreshold {
    return OperationSetThreshold.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationSetThreshold>, I>>(
    object: I,
  ): OperationSetThreshold {
    const message = createBaseOperationSetThreshold();
    message.txThreshold = object.txThreshold ?? 0;
    message.typeThresholds =
      object.typeThresholds?.map((e) =>
        OperationTypeThreshold.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseOperationLog(): OperationLog {
  return { topic: "", datas: [], topics: [] };
}

export const OperationLog: MessageFns<OperationLog> = {
  encode(
    message: OperationLog,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.topic !== undefined && message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.datas !== undefined && message.datas.length !== 0) {
      for (const v of message.datas) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.topics !== undefined && message.topics.length !== 0) {
      for (const v of message.topics) {
        writer.uint32(26).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationLog {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.datas!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.topics!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationLog {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      datas: globalThis.Array.isArray(object?.datas)
        ? object.datas.map((e: any) => globalThis.String(e))
        : [],
      topics: globalThis.Array.isArray(object?.topics)
        ? object.topics.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OperationLog): unknown {
    const obj: any = {};
    if (message.topic !== undefined && message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.datas?.length) {
      obj.datas = message.datas;
    }
    if (message.topics?.length) {
      obj.topics = message.topics;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationLog>, I>>(
    base?: I,
  ): OperationLog {
    return OperationLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationLog>, I>>(
    object: I,
  ): OperationLog {
    const message = createBaseOperationLog();
    message.topic = object.topic ?? "";
    message.datas = object.datas?.map((e) => e) || [];
    message.topics = object.topics?.map((e) => e) || [];
    return message;
  },
};

function createBaseOperationSetPrivilege(): OperationSetPrivilege {
  return { masterWeight: "", signers: [], txThreshold: "", typeThresholds: [] };
}

export const OperationSetPrivilege: MessageFns<OperationSetPrivilege> = {
  encode(
    message: OperationSetPrivilege,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.masterWeight !== undefined && message.masterWeight !== "") {
      writer.uint32(10).string(message.masterWeight);
    }
    if (message.signers !== undefined && message.signers.length !== 0) {
      for (const v of message.signers) {
        Signer.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.txThreshold !== undefined && message.txThreshold !== "") {
      writer.uint32(26).string(message.txThreshold);
    }
    if (
      message.typeThresholds !== undefined &&
      message.typeThresholds.length !== 0
    ) {
      for (const v of message.typeThresholds) {
        OperationTypeThreshold.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationSetPrivilege {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationSetPrivilege();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.masterWeight = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = Signer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signers!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.txThreshold = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = OperationTypeThreshold.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.typeThresholds!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationSetPrivilege {
    return {
      masterWeight: isSet(object.master_weight)
        ? globalThis.String(object.master_weight)
        : "",
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => Signer.fromJSON(e))
        : [],
      txThreshold: isSet(object.tx_threshold)
        ? globalThis.String(object.tx_threshold)
        : "",
      typeThresholds: globalThis.Array.isArray(object?.typeThresholds)
        ? object.typeThresholds.map((e: any) =>
            OperationTypeThreshold.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: OperationSetPrivilege): unknown {
    const obj: any = {};
    if (message.masterWeight !== undefined && message.masterWeight !== "") {
      obj.master_weight = message.masterWeight;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    if (message.txThreshold !== undefined && message.txThreshold !== "") {
      obj.tx_threshold = message.txThreshold;
    }
    if (message.typeThresholds?.length) {
      obj.typeThresholds = message.typeThresholds.map((e) =>
        OperationTypeThreshold.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationSetPrivilege>, I>>(
    base?: I,
  ): OperationSetPrivilege {
    return OperationSetPrivilege.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationSetPrivilege>, I>>(
    object: I,
  ): OperationSetPrivilege {
    const message = createBaseOperationSetPrivilege();
    message.masterWeight = object.masterWeight ?? "";
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    message.txThreshold = object.txThreshold ?? "";
    message.typeThresholds =
      object.typeThresholds?.map((e) =>
        OperationTypeThreshold.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseControlledArea(): ControlledArea {
  return { trusted: 0, status: 0, attributes: [] };
}

export const ControlledArea: MessageFns<ControlledArea> = {
  encode(
    message: ControlledArea,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trusted !== undefined && message.trusted !== 0) {
      writer.uint32(8).int32(message.trusted);
    }
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.attributes !== undefined && message.attributes.length !== 0) {
      for (const v of message.attributes) {
        KeyPair.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlledArea {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlledArea();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.trusted = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = KeyPair.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.attributes!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlledArea {
    return {
      trusted: isSet(object.trusted)
        ? controlledArea_trustFlagFromJSON(object.trusted)
        : 0,
      status: isSet(object.status)
        ? controlledArea_statusFalgFromJSON(object.status)
        : 0,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => KeyPair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ControlledArea): unknown {
    const obj: any = {};
    if (message.trusted !== undefined && message.trusted !== 0) {
      obj.trusted = controlledArea_trustFlagToJSON(message.trusted);
    }
    if (message.status !== undefined && message.status !== 0) {
      obj.status = controlledArea_statusFalgToJSON(message.status);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => KeyPair.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ControlledArea>, I>>(
    base?: I,
  ): ControlledArea {
    return ControlledArea.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ControlledArea>, I>>(
    object: I,
  ): ControlledArea {
    const message = createBaseControlledArea();
    message.trusted = object.trusted ?? 0;
    message.status = object.status ?? 0;
    message.attributes =
      object.attributes?.map((e) => KeyPair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperationSetControlledArea(): OperationSetControlledArea {
  return {
    destAddress: "",
    sTrusted: false,
    sStatus: false,
    trusted: 0,
    status: 0,
    attributes: [],
  };
}

export const OperationSetControlledArea: MessageFns<OperationSetControlledArea> =
  {
    encode(
      message: OperationSetControlledArea,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.destAddress !== undefined && message.destAddress !== "") {
        writer.uint32(10).string(message.destAddress);
      }
      if (message.sTrusted !== undefined && message.sTrusted !== false) {
        writer.uint32(16).bool(message.sTrusted);
      }
      if (message.sStatus !== undefined && message.sStatus !== false) {
        writer.uint32(24).bool(message.sStatus);
      }
      if (message.trusted !== undefined && message.trusted !== 0) {
        writer.uint32(32).int32(message.trusted);
      }
      if (message.status !== undefined && message.status !== 0) {
        writer.uint32(40).int32(message.status);
      }
      if (message.attributes !== undefined && message.attributes.length !== 0) {
        for (const v of message.attributes) {
          KeyPair.encode(v!, writer.uint32(50).fork()).join();
        }
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): OperationSetControlledArea {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseOperationSetControlledArea();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.destAddress = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.sTrusted = reader.bool();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.sStatus = reader.bool();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.trusted = reader.int32() as any;
            continue;
          }
          case 5: {
            if (tag !== 40) {
              break;
            }

            message.status = reader.int32() as any;
            continue;
          }
          case 6: {
            if (tag !== 50) {
              break;
            }

            const el = KeyPair.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.attributes!.push(el);
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): OperationSetControlledArea {
      return {
        destAddress: isSet(object.dest_address)
          ? globalThis.String(object.dest_address)
          : "",
        sTrusted: isSet(object.s_trusted)
          ? globalThis.Boolean(object.s_trusted)
          : false,
        sStatus: isSet(object.s_status)
          ? globalThis.Boolean(object.s_status)
          : false,
        trusted: isSet(object.trusted)
          ? controlledArea_trustFlagFromJSON(object.trusted)
          : 0,
        status: isSet(object.status)
          ? controlledArea_statusFalgFromJSON(object.status)
          : 0,
        attributes: globalThis.Array.isArray(object?.attributes)
          ? object.attributes.map((e: any) => KeyPair.fromJSON(e))
          : [],
      };
    },

    toJSON(message: OperationSetControlledArea): unknown {
      const obj: any = {};
      if (message.destAddress !== undefined && message.destAddress !== "") {
        obj.dest_address = message.destAddress;
      }
      if (message.sTrusted !== undefined && message.sTrusted !== false) {
        obj.s_trusted = message.sTrusted;
      }
      if (message.sStatus !== undefined && message.sStatus !== false) {
        obj.s_status = message.sStatus;
      }
      if (message.trusted !== undefined && message.trusted !== 0) {
        obj.trusted = controlledArea_trustFlagToJSON(message.trusted);
      }
      if (message.status !== undefined && message.status !== 0) {
        obj.status = controlledArea_statusFalgToJSON(message.status);
      }
      if (message.attributes?.length) {
        obj.attributes = message.attributes.map((e) => KeyPair.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<OperationSetControlledArea>, I>>(
      base?: I,
    ): OperationSetControlledArea {
      return OperationSetControlledArea.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<OperationSetControlledArea>, I>>(
      object: I,
    ): OperationSetControlledArea {
      const message = createBaseOperationSetControlledArea();
      message.destAddress = object.destAddress ?? "";
      message.sTrusted = object.sTrusted ?? false;
      message.sStatus = object.sStatus ?? false;
      message.trusted = object.trusted ?? 0;
      message.status = object.status ?? 0;
      message.attributes =
        object.attributes?.map((e) => KeyPair.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseOperationAuthorizeTransfer(): OperationAuthorizeTransfer {
  return { destAddress: "", auth: false };
}

export const OperationAuthorizeTransfer: MessageFns<OperationAuthorizeTransfer> =
  {
    encode(
      message: OperationAuthorizeTransfer,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.destAddress !== undefined && message.destAddress !== "") {
        writer.uint32(10).string(message.destAddress);
      }
      if (message.auth !== undefined && message.auth !== false) {
        writer.uint32(16).bool(message.auth);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): OperationAuthorizeTransfer {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseOperationAuthorizeTransfer();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.destAddress = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.auth = reader.bool();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): OperationAuthorizeTransfer {
      return {
        destAddress: isSet(object.dest_address)
          ? globalThis.String(object.dest_address)
          : "",
        auth: isSet(object.auth) ? globalThis.Boolean(object.auth) : false,
      };
    },

    toJSON(message: OperationAuthorizeTransfer): unknown {
      const obj: any = {};
      if (message.destAddress !== undefined && message.destAddress !== "") {
        obj.dest_address = message.destAddress;
      }
      if (message.auth !== undefined && message.auth !== false) {
        obj.auth = message.auth;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<OperationAuthorizeTransfer>, I>>(
      base?: I,
    ): OperationAuthorizeTransfer {
      return OperationAuthorizeTransfer.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<OperationAuthorizeTransfer>, I>>(
      object: I,
    ): OperationAuthorizeTransfer {
      const message = createBaseOperationAuthorizeTransfer();
      message.destAddress = object.destAddress ?? "";
      message.auth = object.auth ?? false;
      return message;
    },
  };

function createBaseOperation(): Operation {
  return {
    type: 0,
    sourceAddress: "",
    metadata: "",
    createAccount: undefined,
    setMetadata: undefined,
    setSignerWeight: undefined,
    setThreshold: undefined,
    payCoin: undefined,
    log: undefined,
    setPrivilege: undefined,
    upgradeContract: undefined,
    setControlledArea: undefined,
    authorizeTransfer: undefined,
  };
}

export const Operation: MessageFns<Operation> = {
  encode(
    message: Operation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      writer.uint32(18).string(message.sourceAddress);
    }
    if (message.metadata !== undefined && message.metadata !== "") {
      writer.uint32(26).string(message.metadata);
    }
    if (message.createAccount !== undefined) {
      OperationCreateAccount.encode(
        message.createAccount,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.setMetadata !== undefined) {
      OperationSetMetadata.encode(
        message.setMetadata,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.setSignerWeight !== undefined) {
      OperationSetSignerWeight.encode(
        message.setSignerWeight,
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.setThreshold !== undefined) {
      OperationSetThreshold.encode(
        message.setThreshold,
        writer.uint32(74).fork(),
      ).join();
    }
    if (message.payCoin !== undefined) {
      OperationPayCoin.encode(message.payCoin, writer.uint32(82).fork()).join();
    }
    if (message.log !== undefined) {
      OperationLog.encode(message.log, writer.uint32(90).fork()).join();
    }
    if (message.setPrivilege !== undefined) {
      OperationSetPrivilege.encode(
        message.setPrivilege,
        writer.uint32(98).fork(),
      ).join();
    }
    if (message.upgradeContract !== undefined) {
      OperationUpgradeContract.encode(
        message.upgradeContract,
        writer.uint32(106).fork(),
      ).join();
    }
    if (message.setControlledArea !== undefined) {
      OperationSetControlledArea.encode(
        message.setControlledArea,
        writer.uint32(114).fork(),
      ).join();
    }
    if (message.authorizeTransfer !== undefined) {
      OperationAuthorizeTransfer.encode(
        message.authorizeTransfer,
        writer.uint32(122).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createAccount = OperationCreateAccount.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.setMetadata = OperationSetMetadata.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.setSignerWeight = OperationSetSignerWeight.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.setThreshold = OperationSetThreshold.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.payCoin = OperationPayCoin.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.log = OperationLog.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.setPrivilege = OperationSetPrivilege.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.upgradeContract = OperationUpgradeContract.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.setControlledArea = OperationSetControlledArea.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.authorizeTransfer = OperationAuthorizeTransfer.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation {
    return {
      type: isSet(object.type) ? operation_TypeFromJSON(object.type) : 0,
      sourceAddress: isSet(object.source_address)
        ? globalThis.String(object.source_address)
        : "",
      metadata: isSet(object.metadata)
        ? globalThis.String(object.metadata)
        : "",
      createAccount: isSet(object.create_account)
        ? OperationCreateAccount.fromJSON(object.create_account)
        : undefined,
      setMetadata: isSet(object.set_metadata)
        ? OperationSetMetadata.fromJSON(object.set_metadata)
        : undefined,
      setSignerWeight: isSet(object.set_signer_weight)
        ? OperationSetSignerWeight.fromJSON(object.set_signer_weight)
        : undefined,
      setThreshold: isSet(object.set_threshold)
        ? OperationSetThreshold.fromJSON(object.set_threshold)
        : undefined,
      payCoin: isSet(object.pay_coin)
        ? OperationPayCoin.fromJSON(object.pay_coin)
        : undefined,
      log: isSet(object.log) ? OperationLog.fromJSON(object.log) : undefined,
      setPrivilege: isSet(object.set_privilege)
        ? OperationSetPrivilege.fromJSON(object.set_privilege)
        : undefined,
      upgradeContract: isSet(object.upgrade_contract)
        ? OperationUpgradeContract.fromJSON(object.upgrade_contract)
        : undefined,
      setControlledArea: isSet(object.set_controlled_area)
        ? OperationSetControlledArea.fromJSON(object.set_controlled_area)
        : undefined,
      authorizeTransfer: isSet(object.authorize_transfer)
        ? OperationAuthorizeTransfer.fromJSON(object.authorize_transfer)
        : undefined,
    };
  },

  toJSON(message: Operation): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = operation_TypeToJSON(message.type);
    }
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      obj.source_address = message.sourceAddress;
    }
    if (message.metadata !== undefined && message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.createAccount !== undefined) {
      obj.create_account = OperationCreateAccount.toJSON(message.createAccount);
    }
    if (message.setMetadata !== undefined) {
      obj.set_metadata = OperationSetMetadata.toJSON(message.setMetadata);
    }
    if (message.setSignerWeight !== undefined) {
      obj.set_signer_weight = OperationSetSignerWeight.toJSON(
        message.setSignerWeight,
      );
    }
    if (message.setThreshold !== undefined) {
      obj.set_threshold = OperationSetThreshold.toJSON(message.setThreshold);
    }
    if (message.payCoin !== undefined) {
      obj.pay_coin = OperationPayCoin.toJSON(message.payCoin);
    }
    if (message.log !== undefined) {
      obj.log = OperationLog.toJSON(message.log);
    }
    if (message.setPrivilege !== undefined) {
      obj.set_privilege = OperationSetPrivilege.toJSON(message.setPrivilege);
    }
    if (message.upgradeContract !== undefined) {
      obj.upgrade_contract = OperationUpgradeContract.toJSON(
        message.upgradeContract,
      );
    }
    if (message.setControlledArea !== undefined) {
      obj.set_controlled_area = OperationSetControlledArea.toJSON(
        message.setControlledArea,
      );
    }
    if (message.authorizeTransfer !== undefined) {
      obj.authorize_transfer = OperationAuthorizeTransfer.toJSON(
        message.authorizeTransfer,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation>, I>>(base?: I): Operation {
    return Operation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation>, I>>(
    object: I,
  ): Operation {
    const message = createBaseOperation();
    message.type = object.type ?? 0;
    message.sourceAddress = object.sourceAddress ?? "";
    message.metadata = object.metadata ?? "";
    message.createAccount =
      object.createAccount !== undefined && object.createAccount !== null
        ? OperationCreateAccount.fromPartial(object.createAccount)
        : undefined;
    message.setMetadata =
      object.setMetadata !== undefined && object.setMetadata !== null
        ? OperationSetMetadata.fromPartial(object.setMetadata)
        : undefined;
    message.setSignerWeight =
      object.setSignerWeight !== undefined && object.setSignerWeight !== null
        ? OperationSetSignerWeight.fromPartial(object.setSignerWeight)
        : undefined;
    message.setThreshold =
      object.setThreshold !== undefined && object.setThreshold !== null
        ? OperationSetThreshold.fromPartial(object.setThreshold)
        : undefined;
    message.payCoin =
      object.payCoin !== undefined && object.payCoin !== null
        ? OperationPayCoin.fromPartial(object.payCoin)
        : undefined;
    message.log =
      object.log !== undefined && object.log !== null
        ? OperationLog.fromPartial(object.log)
        : undefined;
    message.setPrivilege =
      object.setPrivilege !== undefined && object.setPrivilege !== null
        ? OperationSetPrivilege.fromPartial(object.setPrivilege)
        : undefined;
    message.upgradeContract =
      object.upgradeContract !== undefined && object.upgradeContract !== null
        ? OperationUpgradeContract.fromPartial(object.upgradeContract)
        : undefined;
    message.setControlledArea =
      object.setControlledArea !== undefined &&
      object.setControlledArea !== null
        ? OperationSetControlledArea.fromPartial(object.setControlledArea)
        : undefined;
    message.authorizeTransfer =
      object.authorizeTransfer !== undefined &&
      object.authorizeTransfer !== null
        ? OperationAuthorizeTransfer.fromPartial(object.authorizeTransfer)
        : undefined;
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return {
    sourceAddress: "",
    feeLimit: 0,
    gasPrice: 0,
    nonce: "",
    metadata: "",
    nonceType: 0,
    maxLedgerSeq: 0,
    operations: [],
  };
}

export const Transaction: MessageFns<Transaction> = {
  encode(
    message: Transaction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      writer.uint32(10).string(message.sourceAddress);
    }
    if (message.feeLimit !== undefined && message.feeLimit !== 0) {
      writer.uint32(16).int64(message.feeLimit);
    }
    if (message.gasPrice !== undefined && message.gasPrice !== 0) {
      writer.uint32(24).int64(message.gasPrice);
    }
    if (message.nonce !== undefined && message.nonce !== "") {
      writer.uint32(34).string(message.nonce);
    }
    if (message.metadata !== undefined && message.metadata !== "") {
      writer.uint32(42).string(message.metadata);
    }
    if (message.nonceType !== undefined && message.nonceType !== 0) {
      writer.uint32(48).int32(message.nonceType);
    }
    if (message.maxLedgerSeq !== undefined && message.maxLedgerSeq !== 0) {
      writer.uint32(56).int64(message.maxLedgerSeq);
    }
    if (message.operations !== undefined && message.operations.length !== 0) {
      for (const v of message.operations) {
        Operation.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feeLimit = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gasPrice = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.nonceType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxLedgerSeq = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const el = Operation.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.operations!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      sourceAddress: isSet(object.source_address)
        ? globalThis.String(object.source_address)
        : "",
      feeLimit: isSet(object.fee_limit)
        ? globalThis.Number(object.fee_limit)
        : 0,
      gasPrice: isSet(object.gas_price)
        ? globalThis.Number(object.gas_price)
        : 0,
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
      metadata: isSet(object.metadata)
        ? globalThis.String(object.metadata)
        : "",
      nonceType: isSet(object.nonce_type)
        ? txTypeFromJSON(object.nonce_type)
        : 0,
      maxLedgerSeq: isSet(object.max_ledger_seq)
        ? globalThis.Number(object.max_ledger_seq)
        : 0,
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Operation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      obj.source_address = message.sourceAddress;
    }
    if (message.feeLimit !== undefined && message.feeLimit !== 0) {
      obj.fee_limit = Math.round(message.feeLimit);
    }
    if (message.gasPrice !== undefined && message.gasPrice !== 0) {
      obj.gas_price = Math.round(message.gasPrice);
    }
    if (message.nonce !== undefined && message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    if (message.metadata !== undefined && message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.nonceType !== undefined && message.nonceType !== 0) {
      obj.nonce_type = txTypeToJSON(message.nonceType);
    }
    if (message.maxLedgerSeq !== undefined && message.maxLedgerSeq !== 0) {
      obj.max_ledger_seq = Math.round(message.maxLedgerSeq);
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Operation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(
    object: I,
  ): Transaction {
    const message = createBaseTransaction();
    message.sourceAddress = object.sourceAddress ?? "";
    message.feeLimit = object.feeLimit ?? 0;
    message.gasPrice = object.gasPrice ?? 0;
    message.nonce = object.nonce ?? "";
    message.metadata = object.metadata ?? "";
    message.nonceType = object.nonceType ?? 0;
    message.maxLedgerSeq = object.maxLedgerSeq ?? 0;
    message.operations =
      object.operations?.map((e) => Operation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChainTransaction(): ChainTransaction {
  return {
    status: "",
    incomingTime: "",
    hash: "",
    signatures: [],
    transaction: undefined,
  };
}

export const ChainTransaction: MessageFns<ChainTransaction> = {
  encode(
    message: ChainTransaction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.status !== undefined && message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.incomingTime !== undefined && message.incomingTime !== "") {
      writer.uint32(18).string(message.incomingTime);
    }
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(26).string(message.hash);
    }
    if (message.signatures !== undefined && message.signatures.length !== 0) {
      for (const v of message.signatures) {
        Signature.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainTransaction {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.incomingTime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = Signature.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signatures!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainTransaction {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      incomingTime: isSet(object.incoming_time)
        ? globalThis.String(object.incoming_time)
        : "",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => Signature.fromJSON(e))
        : [],
      transaction: isSet(object.transaction)
        ? Transaction.fromJSON(object.transaction)
        : undefined,
    };
  },

  toJSON(message: ChainTransaction): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== "") {
      obj.status = message.status;
    }
    if (message.incomingTime !== undefined && message.incomingTime !== "") {
      obj.incoming_time = message.incomingTime;
    }
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => Signature.toJSON(e));
    }
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainTransaction>, I>>(
    base?: I,
  ): ChainTransaction {
    return ChainTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainTransaction>, I>>(
    object: I,
  ): ChainTransaction {
    const message = createBaseChainTransaction();
    message.status = object.status ?? "";
    message.incomingTime = object.incomingTime ?? "";
    message.hash = object.hash ?? "";
    message.signatures =
      object.signatures?.map((e) => Signature.fromPartial(e)) || [];
    message.transaction =
      object.transaction !== undefined && object.transaction !== null
        ? Transaction.fromPartial(object.transaction)
        : undefined;
    return message;
  },
};

function createBaseTransactionCacheChain(): TransactionCacheChain {
  return { totalCount: 0, transactions: [] };
}

export const TransactionCacheChain: MessageFns<TransactionCacheChain> = {
  encode(
    message: TransactionCacheChain,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.totalCount !== undefined && message.totalCount !== 0) {
      writer.uint32(8).int64(message.totalCount);
    }
    if (
      message.transactions !== undefined &&
      message.transactions.length !== 0
    ) {
      for (const v of message.transactions) {
        ChainTransaction.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TransactionCacheChain {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionCacheChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = ChainTransaction.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.transactions!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionCacheChain {
    return {
      totalCount: isSet(object.total_count)
        ? globalThis.Number(object.total_count)
        : 0,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ChainTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransactionCacheChain): unknown {
    const obj: any = {};
    if (message.totalCount !== undefined && message.totalCount !== 0) {
      obj.total_count = Math.round(message.totalCount);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) =>
        ChainTransaction.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionCacheChain>, I>>(
    base?: I,
  ): TransactionCacheChain {
    return TransactionCacheChain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionCacheChain>, I>>(
    object: I,
  ): TransactionCacheChain {
    const message = createBaseTransactionCacheChain();
    message.totalCount = object.totalCount ?? 0;
    message.transactions =
      object.transactions?.map((e) => ChainTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTransactionCacheResponse(): GetTransactionCacheResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const GetTransactionCacheResponse: MessageFns<GetTransactionCacheResponse> =
  {
    encode(
      message: GetTransactionCacheResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(8).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(18).string(message.errorDesc);
      }
      if (message.result !== undefined) {
        TransactionCacheChain.encode(
          message.result,
          writer.uint32(26).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetTransactionCacheResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetTransactionCacheResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.result = TransactionCacheChain.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetTransactionCacheResponse {
      return {
        errorCode: isSet(object.error_code)
          ? sdkStatusCodeFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
        result: isSet(object.result)
          ? TransactionCacheChain.fromJSON(object.result)
          : undefined,
      };
    },

    toJSON(message: GetTransactionCacheResponse): unknown {
      const obj: any = {};
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = sdkStatusCodeToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      if (message.result !== undefined) {
        obj.result = TransactionCacheChain.toJSON(message.result);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetTransactionCacheResponse>, I>>(
      base?: I,
    ): GetTransactionCacheResponse {
      return GetTransactionCacheResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetTransactionCacheResponse>, I>>(
      object: I,
    ): GetTransactionCacheResponse {
      const message = createBaseGetTransactionCacheResponse();
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      message.result =
        object.result !== undefined && object.result !== null
          ? TransactionCacheChain.fromPartial(object.result)
          : undefined;
      return message;
    },
  };

function createBaseTransactionEnv(): TransactionEnv {
  return {
    hash: "",
    actualFee: 0,
    closeTime: 0,
    contractTxHashes: [],
    errorCode: 0,
    errorDesc: "",
    ledgerSeq: 0,
    signatures: [],
    transaction: undefined,
    txSize: 0,
    blob: "",
  };
}

export const TransactionEnv: MessageFns<TransactionEnv> = {
  encode(
    message: TransactionEnv,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.actualFee !== undefined && message.actualFee !== 0) {
      writer.uint32(16).int64(message.actualFee);
    }
    if (message.closeTime !== undefined && message.closeTime !== 0) {
      writer.uint32(24).int64(message.closeTime);
    }
    if (
      message.contractTxHashes !== undefined &&
      message.contractTxHashes.length !== 0
    ) {
      for (const v of message.contractTxHashes) {
        writer.uint32(34).string(v!);
      }
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(40).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(50).string(message.errorDesc);
    }
    if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
      writer.uint32(56).int64(message.ledgerSeq);
    }
    if (message.signatures !== undefined && message.signatures.length !== 0) {
      for (const v of message.signatures) {
        Signature.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(74).fork()).join();
    }
    if (message.txSize !== undefined && message.txSize !== 0) {
      writer.uint32(80).int64(message.txSize);
    }
    if (message.blob !== undefined && message.blob !== "") {
      writer.uint32(90).string(message.blob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEnv {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEnv();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actualFee = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.closeTime = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.contractTxHashes!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ledgerSeq = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const el = Signature.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signatures!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.txSize = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.blob = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEnv {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      actualFee: isSet(object.actual_fee)
        ? globalThis.Number(object.actual_fee)
        : 0,
      closeTime: isSet(object.close_time)
        ? globalThis.Number(object.close_time)
        : 0,
      contractTxHashes: globalThis.Array.isArray(object?.contract_tx_hashes)
        ? object.contract_tx_hashes.map((e: any) => globalThis.String(e))
        : [],
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      ledgerSeq: isSet(object.ledger_seq)
        ? globalThis.Number(object.ledger_seq)
        : 0,
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => Signature.fromJSON(e))
        : [],
      transaction: isSet(object.transaction)
        ? Transaction.fromJSON(object.transaction)
        : undefined,
      txSize: isSet(object.tx_size) ? globalThis.Number(object.tx_size) : 0,
      blob: isSet(object.blob) ? globalThis.String(object.blob) : "",
    };
  },

  toJSON(message: TransactionEnv): unknown {
    const obj: any = {};
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.actualFee !== undefined && message.actualFee !== 0) {
      obj.actual_fee = Math.round(message.actualFee);
    }
    if (message.closeTime !== undefined && message.closeTime !== 0) {
      obj.close_time = Math.round(message.closeTime);
    }
    if (message.contractTxHashes?.length) {
      obj.contract_tx_hashes = message.contractTxHashes;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
      obj.ledger_seq = Math.round(message.ledgerSeq);
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => Signature.toJSON(e));
    }
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    if (message.txSize !== undefined && message.txSize !== 0) {
      obj.tx_size = Math.round(message.txSize);
    }
    if (message.blob !== undefined && message.blob !== "") {
      obj.blob = message.blob;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionEnv>, I>>(
    base?: I,
  ): TransactionEnv {
    return TransactionEnv.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionEnv>, I>>(
    object: I,
  ): TransactionEnv {
    const message = createBaseTransactionEnv();
    message.hash = object.hash ?? "";
    message.actualFee = object.actualFee ?? 0;
    message.closeTime = object.closeTime ?? 0;
    message.contractTxHashes = object.contractTxHashes?.map((e) => e) || [];
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.ledgerSeq = object.ledgerSeq ?? 0;
    message.signatures =
      object.signatures?.map((e) => Signature.fromPartial(e)) || [];
    message.transaction =
      object.transaction !== undefined && object.transaction !== null
        ? Transaction.fromPartial(object.transaction)
        : undefined;
    message.txSize = object.txSize ?? 0;
    message.blob = object.blob ?? "";
    return message;
  },
};

function createBaseTransactionHistory(): TransactionHistory {
  return { totalCount: 0, transactions: [] };
}

export const TransactionHistory: MessageFns<TransactionHistory> = {
  encode(
    message: TransactionHistory,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.totalCount !== undefined && message.totalCount !== 0) {
      writer.uint32(8).int64(message.totalCount);
    }
    if (
      message.transactions !== undefined &&
      message.transactions.length !== 0
    ) {
      for (const v of message.transactions) {
        TransactionEnv.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TransactionHistory {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCount = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = TransactionEnv.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.transactions!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionHistory {
    return {
      totalCount: isSet(object.total_count)
        ? globalThis.Number(object.total_count)
        : 0,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionEnv.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransactionHistory): unknown {
    const obj: any = {};
    if (message.totalCount !== undefined && message.totalCount !== 0) {
      obj.total_count = Math.round(message.totalCount);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) =>
        TransactionEnv.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionHistory>, I>>(
    base?: I,
  ): TransactionHistory {
    return TransactionHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionHistory>, I>>(
    object: I,
  ): TransactionHistory {
    const message = createBaseTransactionHistory();
    message.totalCount = object.totalCount ?? 0;
    message.transactions =
      object.transactions?.map((e) => TransactionEnv.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTransactionHistoryResponse(): GetTransactionHistoryResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const GetTransactionHistoryResponse: MessageFns<GetTransactionHistoryResponse> =
  {
    encode(
      message: GetTransactionHistoryResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(8).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(18).string(message.errorDesc);
      }
      if (message.result !== undefined) {
        TransactionHistory.encode(
          message.result,
          writer.uint32(26).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetTransactionHistoryResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetTransactionHistoryResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.result = TransactionHistory.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetTransactionHistoryResponse {
      return {
        errorCode: isSet(object.error_code)
          ? sdkStatusCodeFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
        result: isSet(object.result)
          ? TransactionHistory.fromJSON(object.result)
          : undefined,
      };
    },

    toJSON(message: GetTransactionHistoryResponse): unknown {
      const obj: any = {};
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = sdkStatusCodeToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      if (message.result !== undefined) {
        obj.result = TransactionHistory.toJSON(message.result);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetTransactionHistoryResponse>, I>>(
      base?: I,
    ): GetTransactionHistoryResponse {
      return GetTransactionHistoryResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetTransactionHistoryResponse>, I>>(
      object: I,
    ): GetTransactionHistoryResponse {
      const message = createBaseGetTransactionHistoryResponse();
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      message.result =
        object.result !== undefined && object.result !== null
          ? TransactionHistory.fromPartial(object.result)
          : undefined;
      return message;
    },
  };

function createBaseopBaseParams(): opBaseParams {
  return {
    nonceType: 0,
    ceilLedgerSeq: 0,
    gasPrice: 0,
    feeLimit: 0,
    remarks: "",
  };
}

export const opBaseParams: MessageFns<opBaseParams> = {
  encode(
    message: opBaseParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nonceType !== undefined && message.nonceType !== 0) {
      writer.uint32(8).int32(message.nonceType);
    }
    if (message.ceilLedgerSeq !== undefined && message.ceilLedgerSeq !== 0) {
      writer.uint32(16).int64(message.ceilLedgerSeq);
    }
    if (message.gasPrice !== undefined && message.gasPrice !== 0) {
      writer.uint32(24).int64(message.gasPrice);
    }
    if (message.feeLimit !== undefined && message.feeLimit !== 0) {
      writer.uint32(32).int64(message.feeLimit);
    }
    if (message.remarks !== undefined && message.remarks !== "") {
      writer.uint32(42).string(message.remarks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): opBaseParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseopBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nonceType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ceilLedgerSeq = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gasPrice = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.feeLimit = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.remarks = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): opBaseParams {
    return {
      nonceType: isSet(object.nonceType) ? txTypeFromJSON(object.nonceType) : 0,
      ceilLedgerSeq: isSet(object.ceilLedgerSeq)
        ? globalThis.Number(object.ceilLedgerSeq)
        : 0,
      gasPrice: isSet(object.gasPrice) ? globalThis.Number(object.gasPrice) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.Number(object.feeLimit) : 0,
      remarks: isSet(object.remarks) ? globalThis.String(object.remarks) : "",
    };
  },

  toJSON(message: opBaseParams): unknown {
    const obj: any = {};
    if (message.nonceType !== undefined && message.nonceType !== 0) {
      obj.nonceType = txTypeToJSON(message.nonceType);
    }
    if (message.ceilLedgerSeq !== undefined && message.ceilLedgerSeq !== 0) {
      obj.ceilLedgerSeq = Math.round(message.ceilLedgerSeq);
    }
    if (message.gasPrice !== undefined && message.gasPrice !== 0) {
      obj.gasPrice = Math.round(message.gasPrice);
    }
    if (message.feeLimit !== undefined && message.feeLimit !== 0) {
      obj.feeLimit = Math.round(message.feeLimit);
    }
    if (message.remarks !== undefined && message.remarks !== "") {
      obj.remarks = message.remarks;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<opBaseParams>, I>>(
    base?: I,
  ): opBaseParams {
    return opBaseParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<opBaseParams>, I>>(
    object: I,
  ): opBaseParams {
    const message = createBaseopBaseParams();
    message.nonceType = object.nonceType ?? 0;
    message.ceilLedgerSeq = object.ceilLedgerSeq ?? 0;
    message.gasPrice = object.gasPrice ?? 0;
    message.feeLimit = object.feeLimit ?? 0;
    message.remarks = object.remarks ?? "";
    return message;
  },
};

function createBaseGetTxResponse(): GetTxResponse {
  return { errorCode: 0, errorDesc: "", result: "" };
}

export const GetTxResponse: MessageFns<GetTxResponse> = {
  encode(
    message: GetTxResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined && message.result !== "") {
      writer.uint32(26).string(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTxResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTxResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result) ? globalThis.String(object.result) : "",
    };
  },

  toJSON(message: GetTxResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined && message.result !== "") {
      obj.result = message.result;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTxResponse>, I>>(
    base?: I,
  ): GetTxResponse {
    return GetTxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTxResponse>, I>>(
    object: I,
  ): GetTxResponse {
    const message = createBaseGetTxResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result = object.result ?? "";
    return message;
  },
};

function createBaseOpCreateAccountParams(): OpCreateAccountParams {
  return { params: undefined, destAddress: "", amount: 0 };
}

export const OpCreateAccountParams: MessageFns<OpCreateAccountParams> = {
  encode(
    message: OpCreateAccountParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.params !== undefined) {
      opBaseParams.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.destAddress !== undefined && message.destAddress !== "") {
      writer.uint32(18).string(message.destAddress);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OpCreateAccountParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpCreateAccountParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = opBaseParams.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpCreateAccountParams {
    return {
      params: isSet(object.params)
        ? opBaseParams.fromJSON(object.params)
        : undefined,
      destAddress: isSet(object.destAddress)
        ? globalThis.String(object.destAddress)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: OpCreateAccountParams): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = opBaseParams.toJSON(message.params);
    }
    if (message.destAddress !== undefined && message.destAddress !== "") {
      obj.destAddress = message.destAddress;
    }
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpCreateAccountParams>, I>>(
    base?: I,
  ): OpCreateAccountParams {
    return OpCreateAccountParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpCreateAccountParams>, I>>(
    object: I,
  ): OpCreateAccountParams {
    const message = createBaseOpCreateAccountParams();
    message.params =
      object.params !== undefined && object.params !== null
        ? opBaseParams.fromPartial(object.params)
        : undefined;
    message.destAddress = object.destAddress ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseOpCreateContractParams(): OpCreateContractParams {
  return {
    params: undefined,
    initBalance: 0,
    type: 0,
    payload: "",
    initInput: "",
  };
}

export const OpCreateContractParams: MessageFns<OpCreateContractParams> = {
  encode(
    message: OpCreateContractParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.params !== undefined) {
      opBaseParams.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.initBalance !== undefined && message.initBalance !== 0) {
      writer.uint32(16).int64(message.initBalance);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.payload !== undefined && message.payload !== "") {
      writer.uint32(34).string(message.payload);
    }
    if (message.initInput !== undefined && message.initInput !== "") {
      writer.uint32(42).string(message.initInput);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OpCreateContractParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpCreateContractParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = opBaseParams.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.initBalance = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.initInput = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpCreateContractParams {
    return {
      params: isSet(object.params)
        ? opBaseParams.fromJSON(object.params)
        : undefined,
      initBalance: isSet(object.initBalance)
        ? globalThis.Number(object.initBalance)
        : 0,
      type: isSet(object.type) ? contractTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      initInput: isSet(object.initInput)
        ? globalThis.String(object.initInput)
        : "",
    };
  },

  toJSON(message: OpCreateContractParams): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = opBaseParams.toJSON(message.params);
    }
    if (message.initBalance !== undefined && message.initBalance !== 0) {
      obj.initBalance = Math.round(message.initBalance);
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = contractTypeToJSON(message.type);
    }
    if (message.payload !== undefined && message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.initInput !== undefined && message.initInput !== "") {
      obj.initInput = message.initInput;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpCreateContractParams>, I>>(
    base?: I,
  ): OpCreateContractParams {
    return OpCreateContractParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpCreateContractParams>, I>>(
    object: I,
  ): OpCreateContractParams {
    const message = createBaseOpCreateContractParams();
    message.params =
      object.params !== undefined && object.params !== null
        ? opBaseParams.fromPartial(object.params)
        : undefined;
    message.initBalance = object.initBalance ?? 0;
    message.type = object.type ?? 0;
    message.payload = object.payload ?? "";
    message.initInput = object.initInput ?? "";
    return message;
  },
};

function createBaseOpGasSendParams(): OpGasSendParams {
  return { params: undefined, destAddress: "", amount: 0 };
}

export const OpGasSendParams: MessageFns<OpGasSendParams> = {
  encode(
    message: OpGasSendParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.params !== undefined) {
      opBaseParams.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.destAddress !== undefined && message.destAddress !== "") {
      writer.uint32(18).string(message.destAddress);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpGasSendParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpGasSendParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = opBaseParams.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.destAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpGasSendParams {
    return {
      params: isSet(object.params)
        ? opBaseParams.fromJSON(object.params)
        : undefined,
      destAddress: isSet(object.destAddress)
        ? globalThis.String(object.destAddress)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: OpGasSendParams): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = opBaseParams.toJSON(message.params);
    }
    if (message.destAddress !== undefined && message.destAddress !== "") {
      obj.destAddress = message.destAddress;
    }
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpGasSendParams>, I>>(
    base?: I,
  ): OpGasSendParams {
    return OpGasSendParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpGasSendParams>, I>>(
    object: I,
  ): OpGasSendParams {
    const message = createBaseOpGasSendParams();
    message.params =
      object.params !== undefined && object.params !== null
        ? opBaseParams.fromPartial(object.params)
        : undefined;
    message.destAddress = object.destAddress ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseOpGasSend(): OpGasSend {
  return { destAddress: "", amount: 0 };
}

export const OpGasSend: MessageFns<OpGasSend> = {
  encode(
    message: OpGasSend,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.destAddress !== undefined && message.destAddress !== "") {
      writer.uint32(10).string(message.destAddress);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpGasSend {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpGasSend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpGasSend {
    return {
      destAddress: isSet(object.destAddress)
        ? globalThis.String(object.destAddress)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: OpGasSend): unknown {
    const obj: any = {};
    if (message.destAddress !== undefined && message.destAddress !== "") {
      obj.destAddress = message.destAddress;
    }
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpGasSend>, I>>(base?: I): OpGasSend {
    return OpGasSend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpGasSend>, I>>(
    object: I,
  ): OpGasSend {
    const message = createBaseOpGasSend();
    message.destAddress = object.destAddress ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseOpContractInvokeParams(): OpContractInvokeParams {
  return { params: undefined, contractAddress: "", input: "", amount: 0 };
}

export const OpContractInvokeParams: MessageFns<OpContractInvokeParams> = {
  encode(
    message: OpContractInvokeParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.params !== undefined) {
      opBaseParams.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (
      message.contractAddress !== undefined &&
      message.contractAddress !== ""
    ) {
      writer.uint32(18).string(message.contractAddress);
    }
    if (message.input !== undefined && message.input !== "") {
      writer.uint32(26).string(message.input);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(32).int64(message.amount);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OpContractInvokeParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpContractInvokeParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = opBaseParams.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpContractInvokeParams {
    return {
      params: isSet(object.params)
        ? opBaseParams.fromJSON(object.params)
        : undefined,
      contractAddress: isSet(object.contractAddress)
        ? globalThis.String(object.contractAddress)
        : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: OpContractInvokeParams): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = opBaseParams.toJSON(message.params);
    }
    if (
      message.contractAddress !== undefined &&
      message.contractAddress !== ""
    ) {
      obj.contractAddress = message.contractAddress;
    }
    if (message.input !== undefined && message.input !== "") {
      obj.input = message.input;
    }
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpContractInvokeParams>, I>>(
    base?: I,
  ): OpContractInvokeParams {
    return OpContractInvokeParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpContractInvokeParams>, I>>(
    object: I,
  ): OpContractInvokeParams {
    const message = createBaseOpContractInvokeParams();
    message.params =
      object.params !== undefined && object.params !== null
        ? opBaseParams.fromPartial(object.params)
        : undefined;
    message.contractAddress = object.contractAddress ?? "";
    message.input = object.input ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseOpContractInvoke(): OpContractInvoke {
  return { contractAddress: "", input: "", amount: 0 };
}

export const OpContractInvoke: MessageFns<OpContractInvoke> = {
  encode(
    message: OpContractInvoke,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (
      message.contractAddress !== undefined &&
      message.contractAddress !== ""
    ) {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.input !== undefined && message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpContractInvoke {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpContractInvoke();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpContractInvoke {
    return {
      contractAddress: isSet(object.contractAddress)
        ? globalThis.String(object.contractAddress)
        : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: OpContractInvoke): unknown {
    const obj: any = {};
    if (
      message.contractAddress !== undefined &&
      message.contractAddress !== ""
    ) {
      obj.contractAddress = message.contractAddress;
    }
    if (message.input !== undefined && message.input !== "") {
      obj.input = message.input;
    }
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpContractInvoke>, I>>(
    base?: I,
  ): OpContractInvoke {
    return OpContractInvoke.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpContractInvoke>, I>>(
    object: I,
  ): OpContractInvoke {
    const message = createBaseOpContractInvoke();
    message.contractAddress = object.contractAddress ?? "";
    message.input = object.input ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseOpSetMetadataParams(): OpSetMetadataParams {
  return {
    params: undefined,
    key: "",
    value: "",
    version: 0,
    deleteFlag: false,
  };
}

export const OpSetMetadataParams: MessageFns<OpSetMetadataParams> = {
  encode(
    message: OpSetMetadataParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.params !== undefined) {
      opBaseParams.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(32).int64(message.version);
    }
    if (message.deleteFlag !== undefined && message.deleteFlag !== false) {
      writer.uint32(40).bool(message.deleteFlag);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OpSetMetadataParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpSetMetadataParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = opBaseParams.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.deleteFlag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpSetMetadataParams {
    return {
      params: isSet(object.params)
        ? opBaseParams.fromJSON(object.params)
        : undefined,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      deleteFlag: isSet(object.deleteFlag)
        ? globalThis.Boolean(object.deleteFlag)
        : false,
    };
  },

  toJSON(message: OpSetMetadataParams): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = opBaseParams.toJSON(message.params);
    }
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.deleteFlag !== undefined && message.deleteFlag !== false) {
      obj.deleteFlag = message.deleteFlag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpSetMetadataParams>, I>>(
    base?: I,
  ): OpSetMetadataParams {
    return OpSetMetadataParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpSetMetadataParams>, I>>(
    object: I,
  ): OpSetMetadataParams {
    const message = createBaseOpSetMetadataParams();
    message.params =
      object.params !== undefined && object.params !== null
        ? opBaseParams.fromPartial(object.params)
        : undefined;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.version = object.version ?? 0;
    message.deleteFlag = object.deleteFlag ?? false;
    return message;
  },
};

function createBaseOpSetPrivParams(): OpSetPrivParams {
  return {
    params: undefined,
    masterWeight: "",
    signers: [],
    txThreshold: "",
    typeThresholds: [],
  };
}

export const OpSetPrivParams: MessageFns<OpSetPrivParams> = {
  encode(
    message: OpSetPrivParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.params !== undefined) {
      opBaseParams.encode(message.params, writer.uint32(10).fork()).join();
    }
    if (message.masterWeight !== undefined && message.masterWeight !== "") {
      writer.uint32(18).string(message.masterWeight);
    }
    if (message.signers !== undefined && message.signers.length !== 0) {
      for (const v of message.signers) {
        Signer.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.txThreshold !== undefined && message.txThreshold !== "") {
      writer.uint32(34).string(message.txThreshold);
    }
    if (
      message.typeThresholds !== undefined &&
      message.typeThresholds.length !== 0
    ) {
      for (const v of message.typeThresholds) {
        OperationTypeThreshold.encode(v!, writer.uint32(42).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpSetPrivParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpSetPrivParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = opBaseParams.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.masterWeight = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = Signer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signers!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.txThreshold = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const el = OperationTypeThreshold.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.typeThresholds!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpSetPrivParams {
    return {
      params: isSet(object.params)
        ? opBaseParams.fromJSON(object.params)
        : undefined,
      masterWeight: isSet(object.masterWeight)
        ? globalThis.String(object.masterWeight)
        : "",
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => Signer.fromJSON(e))
        : [],
      txThreshold: isSet(object.txThreshold)
        ? globalThis.String(object.txThreshold)
        : "",
      typeThresholds: globalThis.Array.isArray(object?.typeThresholds)
        ? object.typeThresholds.map((e: any) =>
            OperationTypeThreshold.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: OpSetPrivParams): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = opBaseParams.toJSON(message.params);
    }
    if (message.masterWeight !== undefined && message.masterWeight !== "") {
      obj.masterWeight = message.masterWeight;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    if (message.txThreshold !== undefined && message.txThreshold !== "") {
      obj.txThreshold = message.txThreshold;
    }
    if (message.typeThresholds?.length) {
      obj.typeThresholds = message.typeThresholds.map((e) =>
        OperationTypeThreshold.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpSetPrivParams>, I>>(
    base?: I,
  ): OpSetPrivParams {
    return OpSetPrivParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpSetPrivParams>, I>>(
    object: I,
  ): OpSetPrivParams {
    const message = createBaseOpSetPrivParams();
    message.params =
      object.params !== undefined && object.params !== null
        ? opBaseParams.fromPartial(object.params)
        : undefined;
    message.masterWeight = object.masterWeight ?? "";
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    message.txThreshold = object.txThreshold ?? "";
    message.typeThresholds =
      object.typeThresholds?.map((e) =>
        OperationTypeThreshold.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseOpBatchGasSend(): OpBatchGasSend {
  return { base: undefined, params: [] };
}

export const OpBatchGasSend: MessageFns<OpBatchGasSend> = {
  encode(
    message: OpBatchGasSend,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.base !== undefined) {
      opBaseParams.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.params !== undefined && message.params.length !== 0) {
      for (const v of message.params) {
        OpGasSend.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpBatchGasSend {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpBatchGasSend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = opBaseParams.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = OpGasSend.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.params!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpBatchGasSend {
    return {
      base: isSet(object.base) ? opBaseParams.fromJSON(object.base) : undefined,
      params: globalThis.Array.isArray(object?.params)
        ? object.params.map((e: any) => OpGasSend.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OpBatchGasSend): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = opBaseParams.toJSON(message.base);
    }
    if (message.params?.length) {
      obj.params = message.params.map((e) => OpGasSend.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpBatchGasSend>, I>>(
    base?: I,
  ): OpBatchGasSend {
    return OpBatchGasSend.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpBatchGasSend>, I>>(
    object: I,
  ): OpBatchGasSend {
    const message = createBaseOpBatchGasSend();
    message.base =
      object.base !== undefined && object.base !== null
        ? opBaseParams.fromPartial(object.base)
        : undefined;
    message.params = object.params?.map((e) => OpGasSend.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOpBatchContractInvoke(): OpBatchContractInvoke {
  return { base: undefined, params: [] };
}

export const OpBatchContractInvoke: MessageFns<OpBatchContractInvoke> = {
  encode(
    message: OpBatchContractInvoke,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.base !== undefined) {
      opBaseParams.encode(message.base, writer.uint32(10).fork()).join();
    }
    if (message.params !== undefined && message.params.length !== 0) {
      for (const v of message.params) {
        OpContractInvoke.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OpBatchContractInvoke {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpBatchContractInvoke();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.base = opBaseParams.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = OpContractInvoke.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.params!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpBatchContractInvoke {
    return {
      base: isSet(object.base) ? opBaseParams.fromJSON(object.base) : undefined,
      params: globalThis.Array.isArray(object?.params)
        ? object.params.map((e: any) => OpContractInvoke.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OpBatchContractInvoke): unknown {
    const obj: any = {};
    if (message.base !== undefined) {
      obj.base = opBaseParams.toJSON(message.base);
    }
    if (message.params?.length) {
      obj.params = message.params.map((e) => OpContractInvoke.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpBatchContractInvoke>, I>>(
    base?: I,
  ): OpBatchContractInvoke {
    return OpBatchContractInvoke.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpBatchContractInvoke>, I>>(
    object: I,
  ): OpBatchContractInvoke {
    const message = createBaseOpBatchContractInvoke();
    message.base =
      object.base !== undefined && object.base !== null
        ? opBaseParams.fromPartial(object.base)
        : undefined;
    message.params =
      object.params?.map((e) => OpContractInvoke.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTxBlob(): TxBlob {
  return { transactionBlob: "", signatures: [] };
}

export const TxBlob: MessageFns<TxBlob> = {
  encode(
    message: TxBlob,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (
      message.transactionBlob !== undefined &&
      message.transactionBlob !== ""
    ) {
      writer.uint32(10).string(message.transactionBlob);
    }
    if (message.signatures !== undefined && message.signatures.length !== 0) {
      for (const v of message.signatures) {
        Signature.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TxBlob {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTxBlob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionBlob = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = Signature.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signatures!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TxBlob {
    return {
      transactionBlob: isSet(object.transaction_blob)
        ? globalThis.String(object.transaction_blob)
        : "",
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => Signature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TxBlob): unknown {
    const obj: any = {};
    if (
      message.transactionBlob !== undefined &&
      message.transactionBlob !== ""
    ) {
      obj.transaction_blob = message.transactionBlob;
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => Signature.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TxBlob>, I>>(base?: I): TxBlob {
    return TxBlob.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TxBlob>, I>>(object: I): TxBlob {
    const message = createBaseTxBlob();
    message.transactionBlob = object.transactionBlob ?? "";
    message.signatures =
      object.signatures?.map((e) => Signature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubmitTransactionParams(): SubmitTransactionParams {
  return { items: [] };
}

export const SubmitTransactionParams: MessageFns<SubmitTransactionParams> = {
  encode(
    message: SubmitTransactionParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.items !== undefined && message.items.length !== 0) {
      for (const v of message.items) {
        TxBlob.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SubmitTransactionParams {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = TxBlob.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.items!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTransactionParams {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => TxBlob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubmitTransactionParams): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => TxBlob.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTransactionParams>, I>>(
    base?: I,
  ): SubmitTransactionParams {
    return SubmitTransactionParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTransactionParams>, I>>(
    object: I,
  ): SubmitTransactionParams {
    const message = createBaseSubmitTransactionParams();
    message.items = object.items?.map((e) => TxBlob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubmitTransaction(): SubmitTransaction {
  return { hash: "", errorCode: 0, errorDesc: "" };
}

export const SubmitTransaction: MessageFns<SubmitTransaction> = {
  encode(
    message: SubmitTransaction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitTransaction {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTransaction {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: SubmitTransaction): unknown {
    const obj: any = {};
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTransaction>, I>>(
    base?: I,
  ): SubmitTransaction {
    return SubmitTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTransaction>, I>>(
    object: I,
  ): SubmitTransaction {
    const message = createBaseSubmitTransaction();
    message.hash = object.hash ?? "";
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseSubmitTransactionResponse(): SubmitTransactionResponse {
  return { successCount: 0, results: [] };
}

export const SubmitTransactionResponse: MessageFns<SubmitTransactionResponse> =
  {
    encode(
      message: SubmitTransactionResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.successCount !== undefined && message.successCount !== 0) {
        writer.uint32(8).int64(message.successCount);
      }
      if (message.results !== undefined && message.results.length !== 0) {
        for (const v of message.results) {
          SubmitTransaction.encode(v!, writer.uint32(18).fork()).join();
        }
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SubmitTransactionResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSubmitTransactionResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.successCount = longToNumber(reader.int64());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            const el = SubmitTransaction.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.results!.push(el);
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SubmitTransactionResponse {
      return {
        successCount: isSet(object.success_count)
          ? globalThis.Number(object.success_count)
          : 0,
        results: globalThis.Array.isArray(object?.results)
          ? object.results.map((e: any) => SubmitTransaction.fromJSON(e))
          : [],
      };
    },

    toJSON(message: SubmitTransactionResponse): unknown {
      const obj: any = {};
      if (message.successCount !== undefined && message.successCount !== 0) {
        obj.success_count = Math.round(message.successCount);
      }
      if (message.results?.length) {
        obj.results = message.results.map((e) => SubmitTransaction.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<SubmitTransactionResponse>, I>>(
      base?: I,
    ): SubmitTransactionResponse {
      return SubmitTransactionResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<SubmitTransactionResponse>, I>>(
      object: I,
    ): SubmitTransactionResponse {
      const message = createBaseSubmitTransactionResponse();
      message.successCount = object.successCount ?? 0;
      message.results =
        object.results?.map((e) => SubmitTransaction.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseCheckContractAccountResponse(): CheckContractAccountResponse {
  return { errorCode: 0, errorDesc: "", result: false };
}

export const CheckContractAccountResponse: MessageFns<CheckContractAccountResponse> =
  {
    encode(
      message: CheckContractAccountResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(8).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(18).string(message.errorDesc);
      }
      if (message.result !== undefined && message.result !== false) {
        writer.uint32(24).bool(message.result);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckContractAccountResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckContractAccountResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.result = reader.bool();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CheckContractAccountResponse {
      return {
        errorCode: isSet(object.error_code)
          ? sdkStatusCodeFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
        result: isSet(object.result)
          ? globalThis.Boolean(object.result)
          : false,
      };
    },

    toJSON(message: CheckContractAccountResponse): unknown {
      const obj: any = {};
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = sdkStatusCodeToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      if (message.result !== undefined && message.result !== false) {
        obj.result = message.result;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<CheckContractAccountResponse>, I>>(
      base?: I,
    ): CheckContractAccountResponse {
      return CheckContractAccountResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<CheckContractAccountResponse>, I>>(
      object: I,
    ): CheckContractAccountResponse {
      const message = createBaseCheckContractAccountResponse();
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      message.result = object.result ?? false;
      return message;
    },
  };

function createBaseGetContractInfoResponse(): GetContractInfoResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const GetContractInfoResponse: MessageFns<GetContractInfoResponse> = {
  encode(
    message: GetContractInfoResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined) {
      Contract.encode(message.result, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetContractInfoResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContractInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = Contract.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContractInfoResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result)
        ? Contract.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: GetContractInfoResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined) {
      obj.result = Contract.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContractInfoResponse>, I>>(
    base?: I,
  ): GetContractInfoResponse {
    return GetContractInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContractInfoResponse>, I>>(
    object: I,
  ): GetContractInfoResponse {
    const message = createBaseGetContractInfoResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? Contract.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseSignerSignResponse(): SignerSignResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const SignerSignResponse: MessageFns<SignerSignResponse> = {
  encode(
    message: SignerSignResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined) {
      Signature.encode(message.result, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SignerSignResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignerSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = Signature.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignerSignResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result)
        ? Signature.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: SignerSignResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined) {
      obj.result = Signature.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignerSignResponse>, I>>(
    base?: I,
  ): SignerSignResponse {
    return SignerSignResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignerSignResponse>, I>>(
    object: I,
  ): SignerSignResponse {
    const message = createBaseSignerSignResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? Signature.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseOffLineTxResponse(): OffLineTxResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const OffLineTxResponse: MessageFns<OffLineTxResponse> = {
  encode(
    message: OffLineTxResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined) {
      TxBlob.encode(message.result, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OffLineTxResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOffLineTxResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = TxBlob.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OffLineTxResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result) ? TxBlob.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: OffLineTxResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined) {
      obj.result = TxBlob.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OffLineTxResponse>, I>>(
    base?: I,
  ): OffLineTxResponse {
    return OffLineTxResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OffLineTxResponse>, I>>(
    object: I,
  ): OffLineTxResponse {
    const message = createBaseOffLineTxResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? TxBlob.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseTestTransaction(): TestTransaction {
  return { transactionJson: undefined, signatureNumber: 0 };
}

export const TestTransaction: MessageFns<TestTransaction> = {
  encode(
    message: TestTransaction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transactionJson !== undefined) {
      Transaction.encode(
        message.transactionJson,
        writer.uint32(10).fork(),
      ).join();
    }
    if (
      message.signatureNumber !== undefined &&
      message.signatureNumber !== 0
    ) {
      writer.uint32(16).int64(message.signatureNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestTransaction {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionJson = Transaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.signatureNumber = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestTransaction {
    return {
      transactionJson: isSet(object.transaction_json)
        ? Transaction.fromJSON(object.transaction_json)
        : undefined,
      signatureNumber: isSet(object.signature_number)
        ? globalThis.Number(object.signature_number)
        : 0,
    };
  },

  toJSON(message: TestTransaction): unknown {
    const obj: any = {};
    if (message.transactionJson !== undefined) {
      obj.transaction_json = Transaction.toJSON(message.transactionJson);
    }
    if (
      message.signatureNumber !== undefined &&
      message.signatureNumber !== 0
    ) {
      obj.signature_number = Math.round(message.signatureNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestTransaction>, I>>(
    base?: I,
  ): TestTransaction {
    return TestTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestTransaction>, I>>(
    object: I,
  ): TestTransaction {
    const message = createBaseTestTransaction();
    message.transactionJson =
      object.transactionJson !== undefined && object.transactionJson !== null
        ? Transaction.fromPartial(object.transactionJson)
        : undefined;
    message.signatureNumber = object.signatureNumber ?? 0;
    return message;
  },
};

function createBaseTestTransactionRequest(): TestTransactionRequest {
  return { items: [] };
}

export const TestTransactionRequest: MessageFns<TestTransactionRequest> = {
  encode(
    message: TestTransactionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.items !== undefined && message.items.length !== 0) {
      for (const v of message.items) {
        TestTransaction.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TestTransactionRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = TestTransaction.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.items!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestTransactionRequest {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => TestTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TestTransactionRequest): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => TestTransaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestTransactionRequest>, I>>(
    base?: I,
  ): TestTransactionRequest {
    return TestTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestTransactionRequest>, I>>(
    object: I,
  ): TestTransactionRequest {
    const message = createBaseTestTransactionRequest();
    message.items =
      object.items?.map((e) => TestTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTestTransactionResult(): TestTransactionResult {
  return { stat: undefined, hash: "", txs: [] };
}

export const TestTransactionResult: MessageFns<TestTransactionResult> = {
  encode(
    message: TestTransactionResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.stat !== undefined) {
      TestTransactionResult_Stat.encode(
        message.stat,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    if (message.txs !== undefined && message.txs.length !== 0) {
      for (const v of message.txs) {
        TestTransactionResult_TestTx.encode(
          v!,
          writer.uint32(26).fork(),
        ).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TestTransactionResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestTransactionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat = TestTransactionResult_Stat.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = TestTransactionResult_TestTx.decode(
            reader,
            reader.uint32(),
          );
          if (el !== undefined) {
            message.txs!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestTransactionResult {
    return {
      stat: isSet(object.stat)
        ? TestTransactionResult_Stat.fromJSON(object.stat)
        : undefined,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      txs: globalThis.Array.isArray(object?.txs)
        ? object.txs.map((e: any) => TestTransactionResult_TestTx.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TestTransactionResult): unknown {
    const obj: any = {};
    if (message.stat !== undefined) {
      obj.stat = TestTransactionResult_Stat.toJSON(message.stat);
    }
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.txs?.length) {
      obj.txs = message.txs.map((e) => TestTransactionResult_TestTx.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestTransactionResult>, I>>(
    base?: I,
  ): TestTransactionResult {
    return TestTransactionResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestTransactionResult>, I>>(
    object: I,
  ): TestTransactionResult {
    const message = createBaseTestTransactionResult();
    message.stat =
      object.stat !== undefined && object.stat !== null
        ? TestTransactionResult_Stat.fromPartial(object.stat)
        : undefined;
    message.hash = object.hash ?? "";
    message.txs =
      object.txs?.map((e) => TestTransactionResult_TestTx.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTestTransactionResult_Stat(): TestTransactionResult_Stat {
  return { applyTime: 0, memoryUsage: 0, stackUsage: 0, step: 0 };
}

export const TestTransactionResult_Stat: MessageFns<TestTransactionResult_Stat> =
  {
    encode(
      message: TestTransactionResult_Stat,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.applyTime !== undefined && message.applyTime !== 0) {
        writer.uint32(8).int64(message.applyTime);
      }
      if (message.memoryUsage !== undefined && message.memoryUsage !== 0) {
        writer.uint32(16).int64(message.memoryUsage);
      }
      if (message.stackUsage !== undefined && message.stackUsage !== 0) {
        writer.uint32(24).int64(message.stackUsage);
      }
      if (message.step !== undefined && message.step !== 0) {
        writer.uint32(32).int64(message.step);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): TestTransactionResult_Stat {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTestTransactionResult_Stat();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.applyTime = longToNumber(reader.int64());
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.memoryUsage = longToNumber(reader.int64());
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.stackUsage = longToNumber(reader.int64());
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.step = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): TestTransactionResult_Stat {
      return {
        applyTime: isSet(object.apply_time)
          ? globalThis.Number(object.apply_time)
          : 0,
        memoryUsage: isSet(object.memory_usage)
          ? globalThis.Number(object.memory_usage)
          : 0,
        stackUsage: isSet(object.stack_usage)
          ? globalThis.Number(object.stack_usage)
          : 0,
        step: isSet(object.step) ? globalThis.Number(object.step) : 0,
      };
    },

    toJSON(message: TestTransactionResult_Stat): unknown {
      const obj: any = {};
      if (message.applyTime !== undefined && message.applyTime !== 0) {
        obj.apply_time = Math.round(message.applyTime);
      }
      if (message.memoryUsage !== undefined && message.memoryUsage !== 0) {
        obj.memory_usage = Math.round(message.memoryUsage);
      }
      if (message.stackUsage !== undefined && message.stackUsage !== 0) {
        obj.stack_usage = Math.round(message.stackUsage);
      }
      if (message.step !== undefined && message.step !== 0) {
        obj.step = Math.round(message.step);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<TestTransactionResult_Stat>, I>>(
      base?: I,
    ): TestTransactionResult_Stat {
      return TestTransactionResult_Stat.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<TestTransactionResult_Stat>, I>>(
      object: I,
    ): TestTransactionResult_Stat {
      const message = createBaseTestTransactionResult_Stat();
      message.applyTime = object.applyTime ?? 0;
      message.memoryUsage = object.memoryUsage ?? 0;
      message.stackUsage = object.stackUsage ?? 0;
      message.step = object.step ?? 0;
      return message;
    },
  };

function createBaseTestTransactionResult_TransactionEnv(): TestTransactionResult_TransactionEnv {
  return { transaction: undefined };
}

export const TestTransactionResult_TransactionEnv: MessageFns<TestTransactionResult_TransactionEnv> =
  {
    encode(
      message: TestTransactionResult_TransactionEnv,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.transaction !== undefined) {
        Transaction.encode(
          message.transaction,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): TestTransactionResult_TransactionEnv {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTestTransactionResult_TransactionEnv();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.transaction = Transaction.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): TestTransactionResult_TransactionEnv {
      return {
        transaction: isSet(object.transaction)
          ? Transaction.fromJSON(object.transaction)
          : undefined,
      };
    },

    toJSON(message: TestTransactionResult_TransactionEnv): unknown {
      const obj: any = {};
      if (message.transaction !== undefined) {
        obj.transaction = Transaction.toJSON(message.transaction);
      }
      return obj;
    },

    create<
      I extends Exact<DeepPartial<TestTransactionResult_TransactionEnv>, I>,
    >(base?: I): TestTransactionResult_TransactionEnv {
      return TestTransactionResult_TransactionEnv.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<TestTransactionResult_TransactionEnv>, I>,
    >(object: I): TestTransactionResult_TransactionEnv {
      const message = createBaseTestTransactionResult_TransactionEnv();
      message.transaction =
        object.transaction !== undefined && object.transaction !== null
          ? Transaction.fromPartial(object.transaction)
          : undefined;
      return message;
    },
  };

function createBaseTestTransactionResult_TestTx(): TestTransactionResult_TestTx {
  return { gas: 0, transactionEnv: undefined, actualFee: 0 };
}

export const TestTransactionResult_TestTx: MessageFns<TestTransactionResult_TestTx> =
  {
    encode(
      message: TestTransactionResult_TestTx,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.gas !== undefined && message.gas !== 0) {
        writer.uint32(8).int64(message.gas);
      }
      if (message.transactionEnv !== undefined) {
        TestTransactionResult_TransactionEnv.encode(
          message.transactionEnv,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.actualFee !== undefined && message.actualFee !== 0) {
        writer.uint32(24).int64(message.actualFee);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): TestTransactionResult_TestTx {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTestTransactionResult_TestTx();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.gas = longToNumber(reader.int64());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.transactionEnv =
              TestTransactionResult_TransactionEnv.decode(
                reader,
                reader.uint32(),
              );
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.actualFee = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): TestTransactionResult_TestTx {
      return {
        gas: isSet(object.gas) ? globalThis.Number(object.gas) : 0,
        transactionEnv: isSet(object.transaction_env)
          ? TestTransactionResult_TransactionEnv.fromJSON(
              object.transaction_env,
            )
          : undefined,
        actualFee: isSet(object.actual_fee)
          ? globalThis.Number(object.actual_fee)
          : 0,
      };
    },

    toJSON(message: TestTransactionResult_TestTx): unknown {
      const obj: any = {};
      if (message.gas !== undefined && message.gas !== 0) {
        obj.gas = Math.round(message.gas);
      }
      if (message.transactionEnv !== undefined) {
        obj.transaction_env = TestTransactionResult_TransactionEnv.toJSON(
          message.transactionEnv,
        );
      }
      if (message.actualFee !== undefined && message.actualFee !== 0) {
        obj.actual_fee = Math.round(message.actualFee);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<TestTransactionResult_TestTx>, I>>(
      base?: I,
    ): TestTransactionResult_TestTx {
      return TestTransactionResult_TestTx.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<TestTransactionResult_TestTx>, I>>(
      object: I,
    ): TestTransactionResult_TestTx {
      const message = createBaseTestTransactionResult_TestTx();
      message.gas = object.gas ?? 0;
      message.transactionEnv =
        object.transactionEnv !== undefined && object.transactionEnv !== null
          ? TestTransactionResult_TransactionEnv.fromPartial(
              object.transactionEnv,
            )
          : undefined;
      message.actualFee = object.actualFee ?? 0;
      return message;
    },
  };

function createBaseTestTransactionResponse(): TestTransactionResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const TestTransactionResponse: MessageFns<TestTransactionResponse> = {
  encode(
    message: TestTransactionResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined) {
      TestTransactionResult.encode(
        message.result,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TestTransactionResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = TestTransactionResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestTransactionResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result)
        ? TestTransactionResult.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: TestTransactionResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined) {
      obj.result = TestTransactionResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestTransactionResponse>, I>>(
    base?: I,
  ): TestTransactionResponse {
    return TestTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestTransactionResponse>, I>>(
    object: I,
  ): TestTransactionResponse {
    const message = createBaseTestTransactionResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? TestTransactionResult.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseCallContractRequest(): CallContractRequest {
  return {
    contractAddress: "",
    input: "",
    feeLimit: 0,
    gasPrice: 0,
    sourceAddress: "",
    optType: 0,
  };
}

export const CallContractRequest: MessageFns<CallContractRequest> = {
  encode(
    message: CallContractRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (
      message.contractAddress !== undefined &&
      message.contractAddress !== ""
    ) {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.input !== undefined && message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.feeLimit !== undefined && message.feeLimit !== 0) {
      writer.uint32(32).int64(message.feeLimit);
    }
    if (message.gasPrice !== undefined && message.gasPrice !== 0) {
      writer.uint32(40).int64(message.gasPrice);
    }
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      writer.uint32(50).string(message.sourceAddress);
    }
    if (message.optType !== undefined && message.optType !== 0) {
      writer.uint32(56).int64(message.optType);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallContractRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.feeLimit = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gasPrice = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sourceAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.optType = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractRequest {
    return {
      contractAddress: isSet(object.contract_address)
        ? globalThis.String(object.contract_address)
        : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      feeLimit: isSet(object.fee_limit)
        ? globalThis.Number(object.fee_limit)
        : 0,
      gasPrice: isSet(object.gas_price)
        ? globalThis.Number(object.gas_price)
        : 0,
      sourceAddress: isSet(object.source_address)
        ? globalThis.String(object.source_address)
        : "",
      optType: isSet(object.opt_type) ? globalThis.Number(object.opt_type) : 0,
    };
  },

  toJSON(message: CallContractRequest): unknown {
    const obj: any = {};
    if (
      message.contractAddress !== undefined &&
      message.contractAddress !== ""
    ) {
      obj.contract_address = message.contractAddress;
    }
    if (message.input !== undefined && message.input !== "") {
      obj.input = message.input;
    }
    if (message.feeLimit !== undefined && message.feeLimit !== 0) {
      obj.fee_limit = Math.round(message.feeLimit);
    }
    if (message.gasPrice !== undefined && message.gasPrice !== 0) {
      obj.gas_price = Math.round(message.gasPrice);
    }
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      obj.source_address = message.sourceAddress;
    }
    if (message.optType !== undefined && message.optType !== 0) {
      obj.opt_type = Math.round(message.optType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractRequest>, I>>(
    base?: I,
  ): CallContractRequest {
    return CallContractRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractRequest>, I>>(
    object: I,
  ): CallContractRequest {
    const message = createBaseCallContractRequest();
    message.contractAddress = object.contractAddress ?? "";
    message.input = object.input ?? "";
    message.feeLimit = object.feeLimit ?? 0;
    message.gasPrice = object.gasPrice ?? 0;
    message.sourceAddress = object.sourceAddress ?? "";
    message.optType = object.optType ?? 0;
    return message;
  },
};

function createBaseCallContractResultSystem(): CallContractResultSystem {
  return { queryRets: [] };
}

export const CallContractResultSystem: MessageFns<CallContractResultSystem> = {
  encode(
    message: CallContractResultSystem,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.queryRets !== undefined && message.queryRets.length !== 0) {
      for (const v of message.queryRets) {
        QueryReturnSystem.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallContractResultSystem {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractResultSystem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = QueryReturnSystem.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.queryRets!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractResultSystem {
    return {
      queryRets: globalThis.Array.isArray(object?.query_rets)
        ? object.query_rets.map((e: any) => QueryReturnSystem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CallContractResultSystem): unknown {
    const obj: any = {};
    if (message.queryRets?.length) {
      obj.query_rets = message.queryRets.map((e) =>
        QueryReturnSystem.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractResultSystem>, I>>(
    base?: I,
  ): CallContractResultSystem {
    return CallContractResultSystem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractResultSystem>, I>>(
    object: I,
  ): CallContractResultSystem {
    const message = createBaseCallContractResultSystem();
    message.queryRets =
      object.queryRets?.map((e) => QueryReturnSystem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryReturnSystem(): QueryReturnSystem {
  return { error: undefined, result: undefined };
}

export const QueryReturnSystem: MessageFns<QueryReturnSystem> = {
  encode(
    message: QueryReturnSystem,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      SystemContractResult.encode(
        message.result,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryReturnSystem {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReturnSystem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = SystemContractResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReturnSystem {
    return {
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      result: isSet(object.result)
        ? SystemContractResult.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: QueryReturnSystem): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.result !== undefined) {
      obj.result = SystemContractResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReturnSystem>, I>>(
    base?: I,
  ): QueryReturnSystem {
    return QueryReturnSystem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReturnSystem>, I>>(
    object: I,
  ): QueryReturnSystem {
    const message = createBaseQueryReturnSystem();
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    message.result =
      object.result !== undefined && object.result !== null
        ? SystemContractResult.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseSystemContractResult(): SystemContractResult {
  return { data: "" };
}

export const SystemContractResult: MessageFns<SystemContractResult> = {
  encode(
    message: SystemContractResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.data !== undefined && message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SystemContractResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemContractResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemContractResult {
    return { data: isSet(object.data) ? globalThis.String(object.data) : "" };
  },

  toJSON(message: SystemContractResult): unknown {
    const obj: any = {};
    if (message.data !== undefined && message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemContractResult>, I>>(
    base?: I,
  ): SystemContractResult {
    return SystemContractResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemContractResult>, I>>(
    object: I,
  ): SystemContractResult {
    const message = createBaseSystemContractResult();
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseCallContractResultJs(): CallContractResultJs {
  return { queryRets: [] };
}

export const CallContractResultJs: MessageFns<CallContractResultJs> = {
  encode(
    message: CallContractResultJs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.queryRets !== undefined && message.queryRets.length !== 0) {
      for (const v of message.queryRets) {
        QueryReturnJs.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallContractResultJs {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractResultJs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = QueryReturnJs.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.queryRets!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractResultJs {
    return {
      queryRets: globalThis.Array.isArray(object?.query_rets)
        ? object.query_rets.map((e: any) => QueryReturnJs.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CallContractResultJs): unknown {
    const obj: any = {};
    if (message.queryRets?.length) {
      obj.query_rets = message.queryRets.map((e) => QueryReturnJs.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractResultJs>, I>>(
    base?: I,
  ): CallContractResultJs {
    return CallContractResultJs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractResultJs>, I>>(
    object: I,
  ): CallContractResultJs {
    const message = createBaseCallContractResultJs();
    message.queryRets =
      object.queryRets?.map((e) => QueryReturnJs.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryReturnJs(): QueryReturnJs {
  return { error: undefined, result: undefined };
}

export const QueryReturnJs: MessageFns<QueryReturnJs> = {
  encode(
    message: QueryReturnJs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      JsContractResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryReturnJs {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReturnJs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = JsContractResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReturnJs {
    return {
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      result: isSet(object.result)
        ? JsContractResult.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: QueryReturnJs): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.result !== undefined) {
      obj.result = JsContractResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReturnJs>, I>>(
    base?: I,
  ): QueryReturnJs {
    return QueryReturnJs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReturnJs>, I>>(
    object: I,
  ): QueryReturnJs {
    const message = createBaseQueryReturnJs();
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    message.result =
      object.result !== undefined && object.result !== null
        ? JsContractResult.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseJsContractResult(): JsContractResult {
  return { type: "", value: "" };
}

export const JsContractResult: MessageFns<JsContractResult> = {
  encode(
    message: JsContractResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined && message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JsContractResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsContractResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JsContractResult {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: JsContractResult): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== "") {
      obj.type = message.type;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsContractResult>, I>>(
    base?: I,
  ): JsContractResult {
    return JsContractResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsContractResult>, I>>(
    object: I,
  ): JsContractResult {
    const message = createBaseJsContractResult();
    message.type = object.type ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCallContractResultEvm(): CallContractResultEvm {
  return { queryRets: [] };
}

export const CallContractResultEvm: MessageFns<CallContractResultEvm> = {
  encode(
    message: CallContractResultEvm,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.queryRets !== undefined && message.queryRets.length !== 0) {
      for (const v of message.queryRets) {
        QueryReturnEvm.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallContractResultEvm {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractResultEvm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = QueryReturnEvm.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.queryRets!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractResultEvm {
    return {
      queryRets: globalThis.Array.isArray(object?.query_rets)
        ? object.query_rets.map((e: any) => QueryReturnEvm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CallContractResultEvm): unknown {
    const obj: any = {};
    if (message.queryRets?.length) {
      obj.query_rets = message.queryRets.map((e) => QueryReturnEvm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractResultEvm>, I>>(
    base?: I,
  ): CallContractResultEvm {
    return CallContractResultEvm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractResultEvm>, I>>(
    object: I,
  ): CallContractResultEvm {
    const message = createBaseCallContractResultEvm();
    message.queryRets =
      object.queryRets?.map((e) => QueryReturnEvm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryReturnEvm(): QueryReturnEvm {
  return { error: undefined, result: undefined };
}

export const QueryReturnEvm: MessageFns<QueryReturnEvm> = {
  encode(
    message: QueryReturnEvm,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      EvmContractResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryReturnEvm {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReturnEvm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = EvmContractResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReturnEvm {
    return {
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      result: isSet(object.result)
        ? EvmContractResult.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: QueryReturnEvm): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.result !== undefined) {
      obj.result = EvmContractResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReturnEvm>, I>>(
    base?: I,
  ): QueryReturnEvm {
    return QueryReturnEvm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReturnEvm>, I>>(
    object: I,
  ): QueryReturnEvm {
    const message = createBaseQueryReturnEvm();
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    message.result =
      object.result !== undefined && object.result !== null
        ? EvmContractResult.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseEvmContractResult(): EvmContractResult {
  return { code: 0, data: "", desc: "", eumcode: "", gasused: 0 };
}

export const EvmContractResult: MessageFns<EvmContractResult> = {
  encode(
    message: EvmContractResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.code !== undefined && message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.data !== undefined && message.data !== "") {
      writer.uint32(18).string(message.data);
    }
    if (message.desc !== undefined && message.desc !== "") {
      writer.uint32(26).string(message.desc);
    }
    if (message.eumcode !== undefined && message.eumcode !== "") {
      writer.uint32(34).string(message.eumcode);
    }
    if (message.gasused !== undefined && message.gasused !== 0) {
      writer.uint32(40).int64(message.gasused);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvmContractResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvmContractResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eumcode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gasused = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvmContractResult {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      eumcode: isSet(object.eumcode) ? globalThis.String(object.eumcode) : "",
      gasused: isSet(object.gasused) ? globalThis.Number(object.gasused) : 0,
    };
  },

  toJSON(message: EvmContractResult): unknown {
    const obj: any = {};
    if (message.code !== undefined && message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.data !== undefined && message.data !== "") {
      obj.data = message.data;
    }
    if (message.desc !== undefined && message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.eumcode !== undefined && message.eumcode !== "") {
      obj.eumcode = message.eumcode;
    }
    if (message.gasused !== undefined && message.gasused !== 0) {
      obj.gasused = Math.round(message.gasused);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvmContractResult>, I>>(
    base?: I,
  ): EvmContractResult {
    return EvmContractResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvmContractResult>, I>>(
    object: I,
  ): EvmContractResult {
    const message = createBaseEvmContractResult();
    message.code = object.code ?? 0;
    message.data = object.data ?? "";
    message.desc = object.desc ?? "";
    message.eumcode = object.eumcode ?? "";
    message.gasused = object.gasused ?? 0;
    return message;
  },
};

function createBaseError(): Error {
  return { data: "" };
}

export const Error: MessageFns<Error> = {
  encode(
    message: Error,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.data !== undefined && message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return { data: isSet(object.data) ? globalThis.String(object.data) : "" };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.data !== undefined && message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseQueryReturn(): QueryReturn {
  return { error: "", result: "" };
}

export const QueryReturn: MessageFns<QueryReturn> = {
  encode(
    message: QueryReturn,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.error !== undefined && message.error !== "") {
      writer.uint32(10).string(message.error);
    }
    if (message.result !== undefined && message.result !== "") {
      writer.uint32(18).string(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryReturn {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReturn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReturn {
    return {
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      result: isSet(object.result) ? globalThis.String(object.result) : "",
    };
  },

  toJSON(message: QueryReturn): unknown {
    const obj: any = {};
    if (message.error !== undefined && message.error !== "") {
      obj.error = message.error;
    }
    if (message.result !== undefined && message.result !== "") {
      obj.result = message.result;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReturn>, I>>(base?: I): QueryReturn {
    return QueryReturn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReturn>, I>>(
    object: I,
  ): QueryReturn {
    const message = createBaseQueryReturn();
    message.error = object.error ?? "";
    message.result = object.result ?? "";
    return message;
  },
};

function createBaseCallContractResult(): CallContractResult {
  return { queryRets: [] };
}

export const CallContractResult: MessageFns<CallContractResult> = {
  encode(
    message: CallContractResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.queryRets !== undefined && message.queryRets.length !== 0) {
      for (const v of message.queryRets) {
        QueryReturn.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallContractResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = QueryReturn.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.queryRets!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractResult {
    return {
      queryRets: globalThis.Array.isArray(object?.query_rets)
        ? object.query_rets.map((e: any) => QueryReturn.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CallContractResult): unknown {
    const obj: any = {};
    if (message.queryRets?.length) {
      obj.query_rets = message.queryRets.map((e) => QueryReturn.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractResult>, I>>(
    base?: I,
  ): CallContractResult {
    return CallContractResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractResult>, I>>(
    object: I,
  ): CallContractResult {
    const message = createBaseCallContractResult();
    message.queryRets =
      object.queryRets?.map((e) => QueryReturn.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCallContractResponse(): CallContractResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const CallContractResponse: MessageFns<CallContractResponse> = {
  encode(
    message: CallContractResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      CallContractResult.encode(
        message.result,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallContractResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = CallContractResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? CallContractResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: CallContractResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = CallContractResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractResponse>, I>>(
    base?: I,
  ): CallContractResponse {
    return CallContractResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractResponse>, I>>(
    object: I,
  ): CallContractResponse {
    const message = createBaseCallContractResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? CallContractResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
