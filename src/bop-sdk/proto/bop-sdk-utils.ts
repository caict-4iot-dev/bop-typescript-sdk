// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v3.20.3
// source: bop-sdk-utils.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  SdkStatusCode,
  sdkStatusCodeFromJSON,
  sdkStatusCodeToJSON,
} from "./bop-sdk-common";

export const protobufPackage = "bopsdkutils";

export enum KeyType {
  ED25519 = 0,
  SM2 = 1,
  UNRECOGNIZED = -1,
}

export function keyTypeFromJSON(object: any): KeyType {
  switch (object) {
    case 0:
    case "ED25519":
      return KeyType.ED25519;
    case 1:
    case "SM2":
      return KeyType.SM2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KeyType.UNRECOGNIZED;
  }
}

export function keyTypeToJSON(object: KeyType): string {
  switch (object) {
    case KeyType.ED25519:
      return "ED25519";
    case KeyType.SM2:
      return "SM2";
    case KeyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LanguageType {
  CHINESE = 0,
  ENGLISH = 1,
  UNRECOGNIZED = -1,
}

export function languageTypeFromJSON(object: any): LanguageType {
  switch (object) {
    case 0:
    case "CHINESE":
      return LanguageType.CHINESE;
    case 1:
    case "ENGLISH":
      return LanguageType.ENGLISH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LanguageType.UNRECOGNIZED;
  }
}

export function languageTypeToJSON(object: LanguageType): string {
  switch (object) {
    case LanguageType.CHINESE:
      return "CHINESE";
    case LanguageType.ENGLISH:
      return "ENGLISH";
    case LanguageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AccountKeyInfo {
  keyType?: KeyType | undefined;
  encPrivateKey?: string | undefined;
  encPublicKey?: string | undefined;
  rawPrivateKey?: string | undefined;
  rawPublicKey?: string | undefined;
  encAddress?: string | undefined;
}

export interface GetBidAndKeyPairResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: AccountKeyInfo | undefined;
}

export interface AccountPublicKeyInfo {
  keyType?: KeyType | undefined;
  encPublicKey?: string | undefined;
  rawPublicKey?: string | undefined;
  encAddress?: string | undefined;
}

export interface GetAccountPublicKeyInfoResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: AccountPublicKeyInfo | undefined;
}

export interface AccountPrivateKeyInfo {
  keyType?: KeyType | undefined;
  encPrivateKey?: string | undefined;
  rawPrivateKey?: string | undefined;
}

export interface GetAccountPrivateKeyInfoResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: AccountPrivateKeyInfo | undefined;
}

export interface GetKeyResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: string | undefined;
}

export interface CheckKeyResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: boolean | undefined;
}

export interface ChildAccountKeyInfo {
  privateKey?: string | undefined;
  publicKey?: string | undefined;
  address?: string | undefined;
  path?: string | undefined;
}

export interface GetChildBidAndKeyPairResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: ChildAccountKeyInfo | undefined;
}

export interface GetKeyTypeResponse {
  errorCode?: SdkStatusCode | undefined;
  errorDesc?: string | undefined;
  result?: KeyType | undefined;
}

function createBaseAccountKeyInfo(): AccountKeyInfo {
  return {
    keyType: 0,
    encPrivateKey: "",
    encPublicKey: "",
    rawPrivateKey: "",
    rawPublicKey: "",
    encAddress: "",
  };
}

export const AccountKeyInfo: MessageFns<AccountKeyInfo> = {
  encode(
    message: AccountKeyInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.keyType !== undefined && message.keyType !== 0) {
      writer.uint32(8).int32(message.keyType);
    }
    if (message.encPrivateKey !== undefined && message.encPrivateKey !== "") {
      writer.uint32(18).string(message.encPrivateKey);
    }
    if (message.encPublicKey !== undefined && message.encPublicKey !== "") {
      writer.uint32(26).string(message.encPublicKey);
    }
    if (message.rawPrivateKey !== undefined && message.rawPrivateKey !== "") {
      writer.uint32(34).string(message.rawPrivateKey);
    }
    if (message.rawPublicKey !== undefined && message.rawPublicKey !== "") {
      writer.uint32(42).string(message.rawPublicKey);
    }
    if (message.encAddress !== undefined && message.encAddress !== "") {
      writer.uint32(50).string(message.encAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountKeyInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountKeyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.encPrivateKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.encPublicKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rawPrivateKey = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rawPublicKey = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.encAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountKeyInfo {
    return {
      keyType: isSet(object.key_type) ? keyTypeFromJSON(object.key_type) : 0,
      encPrivateKey: isSet(object.enc_private_key)
        ? globalThis.String(object.enc_private_key)
        : "",
      encPublicKey: isSet(object.enc_public_key)
        ? globalThis.String(object.enc_public_key)
        : "",
      rawPrivateKey: isSet(object.raw_private_key)
        ? globalThis.String(object.raw_private_key)
        : "",
      rawPublicKey: isSet(object.raw_public_key)
        ? globalThis.String(object.raw_public_key)
        : "",
      encAddress: isSet(object.enc_address)
        ? globalThis.String(object.enc_address)
        : "",
    };
  },

  toJSON(message: AccountKeyInfo): unknown {
    const obj: any = {};
    if (message.keyType !== undefined && message.keyType !== 0) {
      obj.key_type = keyTypeToJSON(message.keyType);
    }
    if (message.encPrivateKey !== undefined && message.encPrivateKey !== "") {
      obj.enc_private_key = message.encPrivateKey;
    }
    if (message.encPublicKey !== undefined && message.encPublicKey !== "") {
      obj.enc_public_key = message.encPublicKey;
    }
    if (message.rawPrivateKey !== undefined && message.rawPrivateKey !== "") {
      obj.raw_private_key = message.rawPrivateKey;
    }
    if (message.rawPublicKey !== undefined && message.rawPublicKey !== "") {
      obj.raw_public_key = message.rawPublicKey;
    }
    if (message.encAddress !== undefined && message.encAddress !== "") {
      obj.enc_address = message.encAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountKeyInfo>, I>>(
    base?: I,
  ): AccountKeyInfo {
    return AccountKeyInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountKeyInfo>, I>>(
    object: I,
  ): AccountKeyInfo {
    const message = createBaseAccountKeyInfo();
    message.keyType = object.keyType ?? 0;
    message.encPrivateKey = object.encPrivateKey ?? "";
    message.encPublicKey = object.encPublicKey ?? "";
    message.rawPrivateKey = object.rawPrivateKey ?? "";
    message.rawPublicKey = object.rawPublicKey ?? "";
    message.encAddress = object.encAddress ?? "";
    return message;
  },
};

function createBaseGetBidAndKeyPairResponse(): GetBidAndKeyPairResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const GetBidAndKeyPairResponse: MessageFns<GetBidAndKeyPairResponse> = {
  encode(
    message: GetBidAndKeyPairResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined) {
      AccountKeyInfo.encode(message.result, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetBidAndKeyPairResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBidAndKeyPairResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = AccountKeyInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBidAndKeyPairResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result)
        ? AccountKeyInfo.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: GetBidAndKeyPairResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined) {
      obj.result = AccountKeyInfo.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBidAndKeyPairResponse>, I>>(
    base?: I,
  ): GetBidAndKeyPairResponse {
    return GetBidAndKeyPairResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBidAndKeyPairResponse>, I>>(
    object: I,
  ): GetBidAndKeyPairResponse {
    const message = createBaseGetBidAndKeyPairResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? AccountKeyInfo.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseAccountPublicKeyInfo(): AccountPublicKeyInfo {
  return { keyType: 0, encPublicKey: "", rawPublicKey: "", encAddress: "" };
}

export const AccountPublicKeyInfo: MessageFns<AccountPublicKeyInfo> = {
  encode(
    message: AccountPublicKeyInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.keyType !== undefined && message.keyType !== 0) {
      writer.uint32(8).int32(message.keyType);
    }
    if (message.encPublicKey !== undefined && message.encPublicKey !== "") {
      writer.uint32(18).string(message.encPublicKey);
    }
    if (message.rawPublicKey !== undefined && message.rawPublicKey !== "") {
      writer.uint32(26).string(message.rawPublicKey);
    }
    if (message.encAddress !== undefined && message.encAddress !== "") {
      writer.uint32(34).string(message.encAddress);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AccountPublicKeyInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountPublicKeyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.encPublicKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rawPublicKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.encAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountPublicKeyInfo {
    return {
      keyType: isSet(object.key_type) ? keyTypeFromJSON(object.key_type) : 0,
      encPublicKey: isSet(object.enc_public_key)
        ? globalThis.String(object.enc_public_key)
        : "",
      rawPublicKey: isSet(object.raw_public_key)
        ? globalThis.String(object.raw_public_key)
        : "",
      encAddress: isSet(object.enc_address)
        ? globalThis.String(object.enc_address)
        : "",
    };
  },

  toJSON(message: AccountPublicKeyInfo): unknown {
    const obj: any = {};
    if (message.keyType !== undefined && message.keyType !== 0) {
      obj.key_type = keyTypeToJSON(message.keyType);
    }
    if (message.encPublicKey !== undefined && message.encPublicKey !== "") {
      obj.enc_public_key = message.encPublicKey;
    }
    if (message.rawPublicKey !== undefined && message.rawPublicKey !== "") {
      obj.raw_public_key = message.rawPublicKey;
    }
    if (message.encAddress !== undefined && message.encAddress !== "") {
      obj.enc_address = message.encAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountPublicKeyInfo>, I>>(
    base?: I,
  ): AccountPublicKeyInfo {
    return AccountPublicKeyInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountPublicKeyInfo>, I>>(
    object: I,
  ): AccountPublicKeyInfo {
    const message = createBaseAccountPublicKeyInfo();
    message.keyType = object.keyType ?? 0;
    message.encPublicKey = object.encPublicKey ?? "";
    message.rawPublicKey = object.rawPublicKey ?? "";
    message.encAddress = object.encAddress ?? "";
    return message;
  },
};

function createBaseGetAccountPublicKeyInfoResponse(): GetAccountPublicKeyInfoResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const GetAccountPublicKeyInfoResponse: MessageFns<GetAccountPublicKeyInfoResponse> =
  {
    encode(
      message: GetAccountPublicKeyInfoResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(8).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(18).string(message.errorDesc);
      }
      if (message.result !== undefined) {
        AccountPublicKeyInfo.encode(
          message.result,
          writer.uint32(26).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetAccountPublicKeyInfoResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetAccountPublicKeyInfoResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.result = AccountPublicKeyInfo.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetAccountPublicKeyInfoResponse {
      return {
        errorCode: isSet(object.error_code)
          ? sdkStatusCodeFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
        result: isSet(object.result)
          ? AccountPublicKeyInfo.fromJSON(object.result)
          : undefined,
      };
    },

    toJSON(message: GetAccountPublicKeyInfoResponse): unknown {
      const obj: any = {};
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = sdkStatusCodeToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      if (message.result !== undefined) {
        obj.result = AccountPublicKeyInfo.toJSON(message.result);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetAccountPublicKeyInfoResponse>, I>>(
      base?: I,
    ): GetAccountPublicKeyInfoResponse {
      return GetAccountPublicKeyInfoResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<GetAccountPublicKeyInfoResponse>, I>,
    >(object: I): GetAccountPublicKeyInfoResponse {
      const message = createBaseGetAccountPublicKeyInfoResponse();
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      message.result =
        object.result !== undefined && object.result !== null
          ? AccountPublicKeyInfo.fromPartial(object.result)
          : undefined;
      return message;
    },
  };

function createBaseAccountPrivateKeyInfo(): AccountPrivateKeyInfo {
  return { keyType: 0, encPrivateKey: "", rawPrivateKey: "" };
}

export const AccountPrivateKeyInfo: MessageFns<AccountPrivateKeyInfo> = {
  encode(
    message: AccountPrivateKeyInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.keyType !== undefined && message.keyType !== 0) {
      writer.uint32(8).int32(message.keyType);
    }
    if (message.encPrivateKey !== undefined && message.encPrivateKey !== "") {
      writer.uint32(18).string(message.encPrivateKey);
    }
    if (message.rawPrivateKey !== undefined && message.rawPrivateKey !== "") {
      writer.uint32(26).string(message.rawPrivateKey);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AccountPrivateKeyInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountPrivateKeyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.encPrivateKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rawPrivateKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountPrivateKeyInfo {
    return {
      keyType: isSet(object.key_type) ? keyTypeFromJSON(object.key_type) : 0,
      encPrivateKey: isSet(object.enc_private_key)
        ? globalThis.String(object.enc_private_key)
        : "",
      rawPrivateKey: isSet(object.raw_private_key)
        ? globalThis.String(object.raw_private_key)
        : "",
    };
  },

  toJSON(message: AccountPrivateKeyInfo): unknown {
    const obj: any = {};
    if (message.keyType !== undefined && message.keyType !== 0) {
      obj.key_type = keyTypeToJSON(message.keyType);
    }
    if (message.encPrivateKey !== undefined && message.encPrivateKey !== "") {
      obj.enc_private_key = message.encPrivateKey;
    }
    if (message.rawPrivateKey !== undefined && message.rawPrivateKey !== "") {
      obj.raw_private_key = message.rawPrivateKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountPrivateKeyInfo>, I>>(
    base?: I,
  ): AccountPrivateKeyInfo {
    return AccountPrivateKeyInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountPrivateKeyInfo>, I>>(
    object: I,
  ): AccountPrivateKeyInfo {
    const message = createBaseAccountPrivateKeyInfo();
    message.keyType = object.keyType ?? 0;
    message.encPrivateKey = object.encPrivateKey ?? "";
    message.rawPrivateKey = object.rawPrivateKey ?? "";
    return message;
  },
};

function createBaseGetAccountPrivateKeyInfoResponse(): GetAccountPrivateKeyInfoResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const GetAccountPrivateKeyInfoResponse: MessageFns<GetAccountPrivateKeyInfoResponse> =
  {
    encode(
      message: GetAccountPrivateKeyInfoResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(8).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(18).string(message.errorDesc);
      }
      if (message.result !== undefined) {
        AccountPrivateKeyInfo.encode(
          message.result,
          writer.uint32(26).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetAccountPrivateKeyInfoResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetAccountPrivateKeyInfoResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.result = AccountPrivateKeyInfo.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetAccountPrivateKeyInfoResponse {
      return {
        errorCode: isSet(object.error_code)
          ? sdkStatusCodeFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
        result: isSet(object.result)
          ? AccountPrivateKeyInfo.fromJSON(object.result)
          : undefined,
      };
    },

    toJSON(message: GetAccountPrivateKeyInfoResponse): unknown {
      const obj: any = {};
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = sdkStatusCodeToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      if (message.result !== undefined) {
        obj.result = AccountPrivateKeyInfo.toJSON(message.result);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetAccountPrivateKeyInfoResponse>, I>>(
      base?: I,
    ): GetAccountPrivateKeyInfoResponse {
      return GetAccountPrivateKeyInfoResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<GetAccountPrivateKeyInfoResponse>, I>,
    >(object: I): GetAccountPrivateKeyInfoResponse {
      const message = createBaseGetAccountPrivateKeyInfoResponse();
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      message.result =
        object.result !== undefined && object.result !== null
          ? AccountPrivateKeyInfo.fromPartial(object.result)
          : undefined;
      return message;
    },
  };

function createBaseGetKeyResponse(): GetKeyResponse {
  return { errorCode: 0, errorDesc: "", result: "" };
}

export const GetKeyResponse: MessageFns<GetKeyResponse> = {
  encode(
    message: GetKeyResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined && message.result !== "") {
      writer.uint32(26).string(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeyResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.result = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result) ? globalThis.String(object.result) : "",
    };
  },

  toJSON(message: GetKeyResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined && message.result !== "") {
      obj.result = message.result;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetKeyResponse>, I>>(
    base?: I,
  ): GetKeyResponse {
    return GetKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetKeyResponse>, I>>(
    object: I,
  ): GetKeyResponse {
    const message = createBaseGetKeyResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result = object.result ?? "";
    return message;
  },
};

function createBaseCheckKeyResponse(): CheckKeyResponse {
  return { errorCode: 0, errorDesc: "", result: false };
}

export const CheckKeyResponse: MessageFns<CheckKeyResponse> = {
  encode(
    message: CheckKeyResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined && message.result !== false) {
      writer.uint32(24).bool(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckKeyResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.result = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckKeyResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result) ? globalThis.Boolean(object.result) : false,
    };
  },

  toJSON(message: CheckKeyResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined && message.result !== false) {
      obj.result = message.result;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckKeyResponse>, I>>(
    base?: I,
  ): CheckKeyResponse {
    return CheckKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckKeyResponse>, I>>(
    object: I,
  ): CheckKeyResponse {
    const message = createBaseCheckKeyResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result = object.result ?? false;
    return message;
  },
};

function createBaseChildAccountKeyInfo(): ChildAccountKeyInfo {
  return { privateKey: "", publicKey: "", address: "", path: "" };
}

export const ChildAccountKeyInfo: MessageFns<ChildAccountKeyInfo> = {
  encode(
    message: ChildAccountKeyInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.privateKey !== undefined && message.privateKey !== "") {
      writer.uint32(10).string(message.privateKey);
    }
    if (message.publicKey !== undefined && message.publicKey !== "") {
      writer.uint32(18).string(message.publicKey);
    }
    if (message.address !== undefined && message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.path !== undefined && message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ChildAccountKeyInfo {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChildAccountKeyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.privateKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChildAccountKeyInfo {
    return {
      privateKey: isSet(object.private_key)
        ? globalThis.String(object.private_key)
        : "",
      publicKey: isSet(object.public_key)
        ? globalThis.String(object.public_key)
        : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: ChildAccountKeyInfo): unknown {
    const obj: any = {};
    if (message.privateKey !== undefined && message.privateKey !== "") {
      obj.private_key = message.privateKey;
    }
    if (message.publicKey !== undefined && message.publicKey !== "") {
      obj.public_key = message.publicKey;
    }
    if (message.address !== undefined && message.address !== "") {
      obj.address = message.address;
    }
    if (message.path !== undefined && message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChildAccountKeyInfo>, I>>(
    base?: I,
  ): ChildAccountKeyInfo {
    return ChildAccountKeyInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChildAccountKeyInfo>, I>>(
    object: I,
  ): ChildAccountKeyInfo {
    const message = createBaseChildAccountKeyInfo();
    message.privateKey = object.privateKey ?? "";
    message.publicKey = object.publicKey ?? "";
    message.address = object.address ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseGetChildBidAndKeyPairResponse(): GetChildBidAndKeyPairResponse {
  return { errorCode: 0, errorDesc: "", result: undefined };
}

export const GetChildBidAndKeyPairResponse: MessageFns<GetChildBidAndKeyPairResponse> =
  {
    encode(
      message: GetChildBidAndKeyPairResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(8).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(18).string(message.errorDesc);
      }
      if (message.result !== undefined) {
        ChildAccountKeyInfo.encode(
          message.result,
          writer.uint32(26).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetChildBidAndKeyPairResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetChildBidAndKeyPairResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.result = ChildAccountKeyInfo.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetChildBidAndKeyPairResponse {
      return {
        errorCode: isSet(object.error_code)
          ? sdkStatusCodeFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
        result: isSet(object.result)
          ? ChildAccountKeyInfo.fromJSON(object.result)
          : undefined,
      };
    },

    toJSON(message: GetChildBidAndKeyPairResponse): unknown {
      const obj: any = {};
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = sdkStatusCodeToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      if (message.result !== undefined) {
        obj.result = ChildAccountKeyInfo.toJSON(message.result);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetChildBidAndKeyPairResponse>, I>>(
      base?: I,
    ): GetChildBidAndKeyPairResponse {
      return GetChildBidAndKeyPairResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetChildBidAndKeyPairResponse>, I>>(
      object: I,
    ): GetChildBidAndKeyPairResponse {
      const message = createBaseGetChildBidAndKeyPairResponse();
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      message.result =
        object.result !== undefined && object.result !== null
          ? ChildAccountKeyInfo.fromPartial(object.result)
          : undefined;
      return message;
    },
  };

function createBaseGetKeyTypeResponse(): GetKeyTypeResponse {
  return { errorCode: 0, errorDesc: "", result: 0 };
}

export const GetKeyTypeResponse: MessageFns<GetKeyTypeResponse> = {
  encode(
    message: GetKeyTypeResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(18).string(message.errorDesc);
    }
    if (message.result !== undefined && message.result !== 0) {
      writer.uint32(24).int32(message.result);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetKeyTypeResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyTypeResponse {
    return {
      errorCode: isSet(object.error_code)
        ? sdkStatusCodeFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      result: isSet(object.result) ? keyTypeFromJSON(object.result) : 0,
    };
  },

  toJSON(message: GetKeyTypeResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = sdkStatusCodeToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.result !== undefined && message.result !== 0) {
      obj.result = keyTypeToJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetKeyTypeResponse>, I>>(
    base?: I,
  ): GetKeyTypeResponse {
    return GetKeyTypeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetKeyTypeResponse>, I>>(
    object: I,
  ): GetKeyTypeResponse {
    const message = createBaseGetKeyTypeResponse();
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.result = object.result ?? 0;
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
