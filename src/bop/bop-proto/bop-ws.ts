// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v3.20.3
// source: bop-ws.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "bopws";

/** 定义心跳消息、错误提示和订阅类型的枚举 */
export enum MessageType {
  /** HEARTBEAT - 心跳消息 */
  HEARTBEAT = 0,
  /** ERROR - 连接返回错误提示 */
  ERROR = -1,
  /** BLOCK_HEADER - 订阅区块头 */
  BLOCK_HEADER = 1,
  /** BID_TRANSACTION - 订阅指定bid的交易 */
  BID_TRANSACTION = 2,
  /** TLOG - 订阅TLOG */
  TLOG = 3,
  /** DISCARD_TRANSACTION - 订阅丢弃交易 */
  DISCARD_TRANSACTION = 4,
}

export function messageTypeFromJSON(object: any): MessageType {
  switch (object) {
    case 0:
    case "HEARTBEAT":
      return MessageType.HEARTBEAT;
    case -1:
    case "ERROR":
      return MessageType.ERROR;
    case 1:
    case "BLOCK_HEADER":
      return MessageType.BLOCK_HEADER;
    case 2:
    case "BID_TRANSACTION":
      return MessageType.BID_TRANSACTION;
    case 3:
    case "TLOG":
      return MessageType.TLOG;
    case 4:
    case "DISCARD_TRANSACTION":
      return MessageType.DISCARD_TRANSACTION;
    default:
      return MessageType.ERROR;
  }
}

export function messageTypeToJSON(object: MessageType): string {
  switch (object) {
    case MessageType.HEARTBEAT:
      return "HEARTBEAT";
    case MessageType.ERROR:
      return "ERROR";
    case MessageType.BLOCK_HEADER:
      return "BLOCK_HEADER";
    case MessageType.BID_TRANSACTION:
      return "BID_TRANSACTION";
    case MessageType.TLOG:
      return "TLOG";
    case MessageType.DISCARD_TRANSACTION:
      return "DISCARD_TRANSACTION";
    default:
      return "ERROR";
  }
}

/** 心跳消息（可以是ping或pong） */
export interface HeartbeatMessage {
  /** 可选的附加信息，如"ping"或"pong" */
  message?: string | undefined;
}

export interface SubscribeRequest {
  message?: string[] | undefined;
}

export interface LedgerHeaderMessage {
  seq?: number | undefined;
  hash?: string | undefined;
  previousHash?: string | undefined;
  accountTreeHash?: string | undefined;
  closeTime?: number | undefined;
  consensusValueHash?: string | undefined;
  version?: number | undefined;
  txCount?: number | undefined;
  /** hash */
  validatorsHash?: string | undefined;
  feesHash?: string | undefined;
}

export interface Contract {
  type?: Contract_ContractType | undefined;
  payload?: string | undefined;
}

export enum Contract_ContractType {
  JAVASCRIPT = 0,
  EVM = 1,
  SYSTEM = 2,
  UNRECOGNIZED = -1,
}

export function contract_ContractTypeFromJSON(
  object: any,
): Contract_ContractType {
  switch (object) {
    case 0:
    case "JAVASCRIPT":
      return Contract_ContractType.JAVASCRIPT;
    case 1:
    case "EVM":
      return Contract_ContractType.EVM;
    case 2:
    case "SYSTEM":
      return Contract_ContractType.SYSTEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Contract_ContractType.UNRECOGNIZED;
  }
}

export function contract_ContractTypeToJSON(
  object: Contract_ContractType,
): string {
  switch (object) {
    case Contract_ContractType.JAVASCRIPT:
      return "JAVASCRIPT";
    case Contract_ContractType.EVM:
      return "EVM";
    case Contract_ContractType.SYSTEM:
      return "SYSTEM";
    case Contract_ContractType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Signer {
  address?: string | undefined;
  weight?: number | undefined;
}

export enum Signer_Limit {
  SIGNER_NONE = 0,
  SIGNER = 100,
  UNRECOGNIZED = -1,
}

export function signer_LimitFromJSON(object: any): Signer_Limit {
  switch (object) {
    case 0:
    case "SIGNER_NONE":
      return Signer_Limit.SIGNER_NONE;
    case 100:
    case "SIGNER":
      return Signer_Limit.SIGNER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Signer_Limit.UNRECOGNIZED;
  }
}

export function signer_LimitToJSON(object: Signer_Limit): string {
  switch (object) {
    case Signer_Limit.SIGNER_NONE:
      return "SIGNER_NONE";
    case Signer_Limit.SIGNER:
      return "SIGNER";
    case Signer_Limit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AccountPrivilege {
  masterWeight?: number | undefined;
  signers?: Signer[] | undefined;
  thresholds?: AccountThreshold | undefined;
}

export interface OperationTypeThreshold {
  type?: OperationTypeThreshold_Type | undefined;
  threshold?: number | undefined;
}

export enum OperationTypeThreshold_Type {
  UNKNOWN = 0,
  CREATE_ACCOUNT = 1,
  SET_METADATA = 4,
  SET_SIGNER_WEIGHT = 5,
  SET_THRESHOLD = 6,
  PAY_COIN = 7,
  LOG = 8,
  SET_PRIVILEGE = 9,
  UPGRADE_CONTRACT = 10,
  SET_CONTROLLED_AREA = 11,
  AUTHORIZE_TRANSFER = 12,
  UNRECOGNIZED = -1,
}

export function operationTypeThreshold_TypeFromJSON(
  object: any,
): OperationTypeThreshold_Type {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return OperationTypeThreshold_Type.UNKNOWN;
    case 1:
    case "CREATE_ACCOUNT":
      return OperationTypeThreshold_Type.CREATE_ACCOUNT;
    case 4:
    case "SET_METADATA":
      return OperationTypeThreshold_Type.SET_METADATA;
    case 5:
    case "SET_SIGNER_WEIGHT":
      return OperationTypeThreshold_Type.SET_SIGNER_WEIGHT;
    case 6:
    case "SET_THRESHOLD":
      return OperationTypeThreshold_Type.SET_THRESHOLD;
    case 7:
    case "PAY_COIN":
      return OperationTypeThreshold_Type.PAY_COIN;
    case 8:
    case "LOG":
      return OperationTypeThreshold_Type.LOG;
    case 9:
    case "SET_PRIVILEGE":
      return OperationTypeThreshold_Type.SET_PRIVILEGE;
    case 10:
    case "UPGRADE_CONTRACT":
      return OperationTypeThreshold_Type.UPGRADE_CONTRACT;
    case 11:
    case "SET_CONTROLLED_AREA":
      return OperationTypeThreshold_Type.SET_CONTROLLED_AREA;
    case 12:
    case "AUTHORIZE_TRANSFER":
      return OperationTypeThreshold_Type.AUTHORIZE_TRANSFER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperationTypeThreshold_Type.UNRECOGNIZED;
  }
}

export function operationTypeThreshold_TypeToJSON(
  object: OperationTypeThreshold_Type,
): string {
  switch (object) {
    case OperationTypeThreshold_Type.UNKNOWN:
      return "UNKNOWN";
    case OperationTypeThreshold_Type.CREATE_ACCOUNT:
      return "CREATE_ACCOUNT";
    case OperationTypeThreshold_Type.SET_METADATA:
      return "SET_METADATA";
    case OperationTypeThreshold_Type.SET_SIGNER_WEIGHT:
      return "SET_SIGNER_WEIGHT";
    case OperationTypeThreshold_Type.SET_THRESHOLD:
      return "SET_THRESHOLD";
    case OperationTypeThreshold_Type.PAY_COIN:
      return "PAY_COIN";
    case OperationTypeThreshold_Type.LOG:
      return "LOG";
    case OperationTypeThreshold_Type.SET_PRIVILEGE:
      return "SET_PRIVILEGE";
    case OperationTypeThreshold_Type.UPGRADE_CONTRACT:
      return "UPGRADE_CONTRACT";
    case OperationTypeThreshold_Type.SET_CONTROLLED_AREA:
      return "SET_CONTROLLED_AREA";
    case OperationTypeThreshold_Type.AUTHORIZE_TRANSFER:
      return "AUTHORIZE_TRANSFER";
    case OperationTypeThreshold_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AccountThreshold {
  /** required, [-1,MAX(INT64)] -1: indicates no setting */
  txThreshold?: number | undefined;
  typeThresholds?: OperationTypeThreshold[] | undefined;
}

export interface OperationCreateAccount {
  destAddress?: string | undefined;
  contract?: Contract | undefined;
  priv?: AccountPrivilege | undefined;
  metadatas?: KeyPair[] | undefined;
  initBalance?: number | undefined;
  initInput?: string | undefined;
}

export interface OperationPayCoin {
  destAddress?: string | undefined;
  amount?: number | undefined;
  input?: string | undefined;
}

export interface OperationSetMetadata {
  key?: string | undefined;
  value?: string | undefined;
  /** optional */
  version?: number | undefined;
  deleteFlag?: boolean | undefined;
}

export interface OperationUpgradeContract {
  destAddress?: string | undefined;
  payload?: string | undefined;
  type?: number | undefined;
}

export interface OperationSetSignerWeight {
  /** required, [-1,MAX(UINT32)] -1: indicates no setting */
  masterWeight?: number | undefined;
  /** address:weight, if weight is 0, it indicates deleting this signer */
  signers?: Signer[] | undefined;
}

export interface OperationSetThreshold {
  txThreshold?: number | undefined;
  /** type:threshold, threshold:0 indicates deleting this type */
  typeThresholds?: OperationTypeThreshold[] | undefined;
}

export interface OperationLog {
  topic?: string | undefined;
  datas?: string[] | undefined;
  /** for evm */
  topics?: string[] | undefined;
}

export interface OperationSetPrivilege {
  masterWeight?: string | undefined;
  signers?: Signer[] | undefined;
  txThreshold?: string | undefined;
  typeThresholds?: OperationTypeThreshold[] | undefined;
}

export interface ControlledArea {
  trusted?: ControlledArea_trustFlag | undefined;
  status?: ControlledArea_statusFalg | undefined;
  attributes?: KeyPair[] | undefined;
}

export enum ControlledArea_trustFlag {
  UNCERT = 0,
  TRUSTED = 1,
  UNTRUSTED = 2,
  UNRECOGNIZED = -1,
}

export function controlledArea_trustFlagFromJSON(
  object: any,
): ControlledArea_trustFlag {
  switch (object) {
    case 0:
    case "UNCERT":
      return ControlledArea_trustFlag.UNCERT;
    case 1:
    case "TRUSTED":
      return ControlledArea_trustFlag.TRUSTED;
    case 2:
    case "UNTRUSTED":
      return ControlledArea_trustFlag.UNTRUSTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ControlledArea_trustFlag.UNRECOGNIZED;
  }
}

export function controlledArea_trustFlagToJSON(
  object: ControlledArea_trustFlag,
): string {
  switch (object) {
    case ControlledArea_trustFlag.UNCERT:
      return "UNCERT";
    case ControlledArea_trustFlag.TRUSTED:
      return "TRUSTED";
    case ControlledArea_trustFlag.UNTRUSTED:
      return "UNTRUSTED";
    case ControlledArea_trustFlag.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ControlledArea_statusFalg {
  ENABLED = 0,
  DISABLED = 1,
  UNRECOGNIZED = -1,
}

export function controlledArea_statusFalgFromJSON(
  object: any,
): ControlledArea_statusFalg {
  switch (object) {
    case 0:
    case "ENABLED":
      return ControlledArea_statusFalg.ENABLED;
    case 1:
    case "DISABLED":
      return ControlledArea_statusFalg.DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ControlledArea_statusFalg.UNRECOGNIZED;
  }
}

export function controlledArea_statusFalgToJSON(
  object: ControlledArea_statusFalg,
): string {
  switch (object) {
    case ControlledArea_statusFalg.ENABLED:
      return "ENABLED";
    case ControlledArea_statusFalg.DISABLED:
      return "DISABLED";
    case ControlledArea_statusFalg.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OperationSetControlledArea {
  destAddress?: string | undefined;
  sTrusted?: boolean | undefined;
  sStatus?: boolean | undefined;
  trusted?: ControlledArea_trustFlag | undefined;
  status?: ControlledArea_statusFalg | undefined;
  attributes?: KeyPair[] | undefined;
}

export interface OperationAuthorizeTransfer {
  destAddress?: string | undefined;
  auth?: boolean | undefined;
}

export interface Operation {
  type?: Operation_Type | undefined;
  sourceAddress?: string | undefined;
  metadata?: string | undefined;
  createAccount?: OperationCreateAccount | undefined;
  setMetadata?: OperationSetMetadata | undefined;
  setSignerWeight?: OperationSetSignerWeight | undefined;
  setThreshold?: OperationSetThreshold | undefined;
  payCoin?: OperationPayCoin | undefined;
  log?: OperationLog | undefined;
  setPrivilege?: OperationSetPrivilege | undefined;
  upgradeContract?: OperationUpgradeContract | undefined;
  setControlledArea?: OperationSetControlledArea | undefined;
  authorizeTransfer?: OperationAuthorizeTransfer | undefined;
}

export enum Operation_Type {
  UNKNOWN = 0,
  CREATE_ACCOUNT = 1,
  SET_METADATA = 4,
  SET_SIGNER_WEIGHT = 5,
  SET_THRESHOLD = 6,
  PAY_COIN = 7,
  LOG = 8,
  SET_PRIVILEGE = 9,
  UPGRADE_CONTRACT = 10,
  SET_CONTROLLED_AREA = 11,
  AUTHORIZE_TRANSFER = 12,
  UNRECOGNIZED = -1,
}

export function operation_TypeFromJSON(object: any): Operation_Type {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Operation_Type.UNKNOWN;
    case 1:
    case "CREATE_ACCOUNT":
      return Operation_Type.CREATE_ACCOUNT;
    case 4:
    case "SET_METADATA":
      return Operation_Type.SET_METADATA;
    case 5:
    case "SET_SIGNER_WEIGHT":
      return Operation_Type.SET_SIGNER_WEIGHT;
    case 6:
    case "SET_THRESHOLD":
      return Operation_Type.SET_THRESHOLD;
    case 7:
    case "PAY_COIN":
      return Operation_Type.PAY_COIN;
    case 8:
    case "LOG":
      return Operation_Type.LOG;
    case 9:
    case "SET_PRIVILEGE":
      return Operation_Type.SET_PRIVILEGE;
    case 10:
    case "UPGRADE_CONTRACT":
      return Operation_Type.UPGRADE_CONTRACT;
    case 11:
    case "SET_CONTROLLED_AREA":
      return Operation_Type.SET_CONTROLLED_AREA;
    case 12:
    case "AUTHORIZE_TRANSFER":
      return Operation_Type.AUTHORIZE_TRANSFER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Operation_Type.UNRECOGNIZED;
  }
}

export function operation_TypeToJSON(object: Operation_Type): string {
  switch (object) {
    case Operation_Type.UNKNOWN:
      return "UNKNOWN";
    case Operation_Type.CREATE_ACCOUNT:
      return "CREATE_ACCOUNT";
    case Operation_Type.SET_METADATA:
      return "SET_METADATA";
    case Operation_Type.SET_SIGNER_WEIGHT:
      return "SET_SIGNER_WEIGHT";
    case Operation_Type.SET_THRESHOLD:
      return "SET_THRESHOLD";
    case Operation_Type.PAY_COIN:
      return "PAY_COIN";
    case Operation_Type.LOG:
      return "LOG";
    case Operation_Type.SET_PRIVILEGE:
      return "SET_PRIVILEGE";
    case Operation_Type.UPGRADE_CONTRACT:
      return "UPGRADE_CONTRACT";
    case Operation_Type.SET_CONTROLLED_AREA:
      return "SET_CONTROLLED_AREA";
    case Operation_Type.AUTHORIZE_TRANSFER:
      return "AUTHORIZE_TRANSFER";
    case Operation_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Transaction {
  sourceAddress?: string | undefined;
  feeLimit?: number | undefined;
  gasPrice?: number | undefined;
  nonce?: string | undefined;
  metadata?: string | undefined;
  nonceType?: Transaction_TxType | undefined;
  maxLedgerSeq?: number | undefined;
  operations?: Operation[] | undefined;
}

export enum Transaction_TxType {
  INCREASE_NONCE = 0,
  RANDOM_NONCE = 1,
  UNRECOGNIZED = -1,
}

export function transaction_TxTypeFromJSON(object: any): Transaction_TxType {
  switch (object) {
    case 0:
    case "INCREASE_NONCE":
      return Transaction_TxType.INCREASE_NONCE;
    case 1:
    case "RANDOM_NONCE":
      return Transaction_TxType.RANDOM_NONCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Transaction_TxType.UNRECOGNIZED;
  }
}

export function transaction_TxTypeToJSON(object: Transaction_TxType): string {
  switch (object) {
    case Transaction_TxType.INCREASE_NONCE:
      return "INCREASE_NONCE";
    case Transaction_TxType.RANDOM_NONCE:
      return "RANDOM_NONCE";
    case Transaction_TxType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Trigger {
  transactionType?: Trigger_TransactionType | undefined;
  /** If it is triggered by a specific block (temporarily not provided) */
  ledgerSeq?: number | undefined;
  /** If it's a transaction triggered */
  transaction?: Trigger_OperationTrigger | undefined;
}

export enum Trigger_TransactionType {
  NORMAL_TRANSACTION = 0,
  CONTRACT_TRANSACTION = 1,
  UNRECOGNIZED = -1,
}

export function trigger_TransactionTypeFromJSON(
  object: any,
): Trigger_TransactionType {
  switch (object) {
    case 0:
    case "NORMAL_TRANSACTION":
      return Trigger_TransactionType.NORMAL_TRANSACTION;
    case 1:
    case "CONTRACT_TRANSACTION":
      return Trigger_TransactionType.CONTRACT_TRANSACTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Trigger_TransactionType.UNRECOGNIZED;
  }
}

export function trigger_TransactionTypeToJSON(
  object: Trigger_TransactionType,
): string {
  switch (object) {
    case Trigger_TransactionType.NORMAL_TRANSACTION:
      return "NORMAL_TRANSACTION";
    case Trigger_TransactionType.CONTRACT_TRANSACTION:
      return "CONTRACT_TRANSACTION";
    case Trigger_TransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Trigger_OperationTrigger {
  hash?: Uint8Array | undefined;
  index?: number | undefined;
}

export interface TransactionEnv {
  transaction?: Transaction | undefined;
  signatures?: Signature[] | undefined;
  trigger?: Trigger | undefined;
}

export interface TransactionEnvStoreMessage {
  transactionEnv?: TransactionEnv | undefined;
  errorCode?: number | undefined;
  errorDesc?: string | undefined;
  ledgerSeq?: number | undefined;
  closeTime?: number | undefined;
  /** for notify */
  hash?: string | undefined;
  actualFee?: number | undefined;
  contractTxHashes?: string[] | undefined;
}

export interface Signature {
  publicKey?: string | undefined;
  signData?: string | undefined;
}

export interface KeyPair {
  key?: string | undefined;
  value?: string | undefined;
  version?: number | undefined;
}

export interface DropTxMessage {
  txHash?: string | undefined;
  source?: DropTxMessage_PoolType | undefined;
  timestamp?: number | undefined;
  /** 序列化Transaction数据 */
  tx?: string | undefined;
}

export enum DropTxMessage_PoolType {
  PLATFORM = 0,
  CHAIN = 1,
  UNRECOGNIZED = -1,
}

export function dropTxMessage_PoolTypeFromJSON(
  object: any,
): DropTxMessage_PoolType {
  switch (object) {
    case 0:
    case "PLATFORM":
      return DropTxMessage_PoolType.PLATFORM;
    case 1:
    case "CHAIN":
      return DropTxMessage_PoolType.CHAIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DropTxMessage_PoolType.UNRECOGNIZED;
  }
}

export function dropTxMessage_PoolTypeToJSON(
  object: DropTxMessage_PoolType,
): string {
  switch (object) {
    case DropTxMessage_PoolType.PLATFORM:
      return "PLATFORM";
    case DropTxMessage_PoolType.CHAIN:
      return "CHAIN";
    case DropTxMessage_PoolType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseHeartbeatMessage(): HeartbeatMessage {
  return { message: "" };
}

export const HeartbeatMessage: MessageFns<HeartbeatMessage> = {
  encode(
    message: HeartbeatMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HeartbeatMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatMessage {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: HeartbeatMessage): unknown {
    const obj: any = {};
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatMessage>, I>>(
    base?: I,
  ): HeartbeatMessage {
    return HeartbeatMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatMessage>, I>>(
    object: I,
  ): HeartbeatMessage {
    const message = createBaseHeartbeatMessage();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseSubscribeRequest(): SubscribeRequest {
  return { message: [] };
}

export const SubscribeRequest: MessageFns<SubscribeRequest> = {
  encode(
    message: SubscribeRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.message !== undefined && message.message.length !== 0) {
      for (const v of message.message) {
        writer.uint32(10).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.message!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequest {
    return {
      message: globalThis.Array.isArray(object?.message)
        ? object.message.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SubscribeRequest): unknown {
    const obj: any = {};
    if (message.message?.length) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeRequest>, I>>(
    base?: I,
  ): SubscribeRequest {
    return SubscribeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeRequest>, I>>(
    object: I,
  ): SubscribeRequest {
    const message = createBaseSubscribeRequest();
    message.message = object.message?.map((e) => e) || [];
    return message;
  },
};

function createBaseLedgerHeaderMessage(): LedgerHeaderMessage {
  return {
    seq: 0,
    hash: "",
    previousHash: "",
    accountTreeHash: "",
    closeTime: 0,
    consensusValueHash: "",
    version: 0,
    txCount: 0,
    validatorsHash: "",
    feesHash: "",
  };
}

export const LedgerHeaderMessage: MessageFns<LedgerHeaderMessage> = {
  encode(
    message: LedgerHeaderMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.seq !== undefined && message.seq !== 0) {
      writer.uint32(8).int64(message.seq);
    }
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    if (message.previousHash !== undefined && message.previousHash !== "") {
      writer.uint32(26).string(message.previousHash);
    }
    if (
      message.accountTreeHash !== undefined &&
      message.accountTreeHash !== ""
    ) {
      writer.uint32(34).string(message.accountTreeHash);
    }
    if (message.closeTime !== undefined && message.closeTime !== 0) {
      writer.uint32(40).int64(message.closeTime);
    }
    if (
      message.consensusValueHash !== undefined &&
      message.consensusValueHash !== ""
    ) {
      writer.uint32(50).string(message.consensusValueHash);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(56).int64(message.version);
    }
    if (message.txCount !== undefined && message.txCount !== 0) {
      writer.uint32(64).int64(message.txCount);
    }
    if (message.validatorsHash !== undefined && message.validatorsHash !== "") {
      writer.uint32(74).string(message.validatorsHash);
    }
    if (message.feesHash !== undefined && message.feesHash !== "") {
      writer.uint32(82).string(message.feesHash);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): LedgerHeaderMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerHeaderMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seq = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.previousHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accountTreeHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.closeTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.consensusValueHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.txCount = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.validatorsHash = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.feesHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerHeaderMessage {
    return {
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      previousHash: isSet(object.previous_hash)
        ? globalThis.String(object.previous_hash)
        : "",
      accountTreeHash: isSet(object.account_tree_hash)
        ? globalThis.String(object.account_tree_hash)
        : "",
      closeTime: isSet(object.close_time)
        ? globalThis.Number(object.close_time)
        : 0,
      consensusValueHash: isSet(object.consensus_value_hash)
        ? globalThis.String(object.consensus_value_hash)
        : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      txCount: isSet(object.tx_count) ? globalThis.Number(object.tx_count) : 0,
      validatorsHash: isSet(object.validators_hash)
        ? globalThis.String(object.validators_hash)
        : "",
      feesHash: isSet(object.fees_hash)
        ? globalThis.String(object.fees_hash)
        : "",
    };
  },

  toJSON(message: LedgerHeaderMessage): unknown {
    const obj: any = {};
    if (message.seq !== undefined && message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.previousHash !== undefined && message.previousHash !== "") {
      obj.previous_hash = message.previousHash;
    }
    if (
      message.accountTreeHash !== undefined &&
      message.accountTreeHash !== ""
    ) {
      obj.account_tree_hash = message.accountTreeHash;
    }
    if (message.closeTime !== undefined && message.closeTime !== 0) {
      obj.close_time = Math.round(message.closeTime);
    }
    if (
      message.consensusValueHash !== undefined &&
      message.consensusValueHash !== ""
    ) {
      obj.consensus_value_hash = message.consensusValueHash;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.txCount !== undefined && message.txCount !== 0) {
      obj.tx_count = Math.round(message.txCount);
    }
    if (message.validatorsHash !== undefined && message.validatorsHash !== "") {
      obj.validators_hash = message.validatorsHash;
    }
    if (message.feesHash !== undefined && message.feesHash !== "") {
      obj.fees_hash = message.feesHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerHeaderMessage>, I>>(
    base?: I,
  ): LedgerHeaderMessage {
    return LedgerHeaderMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerHeaderMessage>, I>>(
    object: I,
  ): LedgerHeaderMessage {
    const message = createBaseLedgerHeaderMessage();
    message.seq = object.seq ?? 0;
    message.hash = object.hash ?? "";
    message.previousHash = object.previousHash ?? "";
    message.accountTreeHash = object.accountTreeHash ?? "";
    message.closeTime = object.closeTime ?? 0;
    message.consensusValueHash = object.consensusValueHash ?? "";
    message.version = object.version ?? 0;
    message.txCount = object.txCount ?? 0;
    message.validatorsHash = object.validatorsHash ?? "";
    message.feesHash = object.feesHash ?? "";
    return message;
  },
};

function createBaseContract(): Contract {
  return { type: 0, payload: "" };
}

export const Contract: MessageFns<Contract> = {
  encode(
    message: Contract,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload !== undefined && message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Contract {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Contract {
    return {
      type: isSet(object.type) ? contract_ContractTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
    };
  },

  toJSON(message: Contract): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = contract_ContractTypeToJSON(message.type);
    }
    if (message.payload !== undefined && message.payload !== "") {
      obj.payload = message.payload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Contract>, I>>(base?: I): Contract {
    return Contract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Contract>, I>>(object: I): Contract {
    const message = createBaseContract();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? "";
    return message;
  },
};

function createBaseSigner(): Signer {
  return { address: "", weight: 0 };
}

export const Signer: MessageFns<Signer> = {
  encode(
    message: Signer,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.address !== undefined && message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.weight !== undefined && message.weight !== 0) {
      writer.uint32(16).int64(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signer {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.weight = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signer {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: Signer): unknown {
    const obj: any = {};
    if (message.address !== undefined && message.address !== "") {
      obj.address = message.address;
    }
    if (message.weight !== undefined && message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Signer>, I>>(base?: I): Signer {
    return Signer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Signer>, I>>(object: I): Signer {
    const message = createBaseSigner();
    message.address = object.address ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseAccountPrivilege(): AccountPrivilege {
  return { masterWeight: 0, signers: [], thresholds: undefined };
}

export const AccountPrivilege: MessageFns<AccountPrivilege> = {
  encode(
    message: AccountPrivilege,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.masterWeight !== undefined && message.masterWeight !== 0) {
      writer.uint32(8).int64(message.masterWeight);
    }
    if (message.signers !== undefined && message.signers.length !== 0) {
      for (const v of message.signers) {
        Signer.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.thresholds !== undefined) {
      AccountThreshold.encode(
        message.thresholds,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountPrivilege {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountPrivilege();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.masterWeight = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = Signer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signers!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thresholds = AccountThreshold.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountPrivilege {
    return {
      masterWeight: isSet(object.master_weight)
        ? globalThis.Number(object.master_weight)
        : 0,
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => Signer.fromJSON(e))
        : [],
      thresholds: isSet(object.thresholds)
        ? AccountThreshold.fromJSON(object.thresholds)
        : undefined,
    };
  },

  toJSON(message: AccountPrivilege): unknown {
    const obj: any = {};
    if (message.masterWeight !== undefined && message.masterWeight !== 0) {
      obj.master_weight = Math.round(message.masterWeight);
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    if (message.thresholds !== undefined) {
      obj.thresholds = AccountThreshold.toJSON(message.thresholds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountPrivilege>, I>>(
    base?: I,
  ): AccountPrivilege {
    return AccountPrivilege.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountPrivilege>, I>>(
    object: I,
  ): AccountPrivilege {
    const message = createBaseAccountPrivilege();
    message.masterWeight = object.masterWeight ?? 0;
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    message.thresholds =
      object.thresholds !== undefined && object.thresholds !== null
        ? AccountThreshold.fromPartial(object.thresholds)
        : undefined;
    return message;
  },
};

function createBaseOperationTypeThreshold(): OperationTypeThreshold {
  return { type: 0, threshold: 0 };
}

export const OperationTypeThreshold: MessageFns<OperationTypeThreshold> = {
  encode(
    message: OperationTypeThreshold,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.threshold !== undefined && message.threshold !== 0) {
      writer.uint32(16).int64(message.threshold);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationTypeThreshold {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationTypeThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.threshold = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationTypeThreshold {
    return {
      type: isSet(object.type)
        ? operationTypeThreshold_TypeFromJSON(object.type)
        : 0,
      threshold: isSet(object.threshold)
        ? globalThis.Number(object.threshold)
        : 0,
    };
  },

  toJSON(message: OperationTypeThreshold): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = operationTypeThreshold_TypeToJSON(message.type);
    }
    if (message.threshold !== undefined && message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationTypeThreshold>, I>>(
    base?: I,
  ): OperationTypeThreshold {
    return OperationTypeThreshold.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationTypeThreshold>, I>>(
    object: I,
  ): OperationTypeThreshold {
    const message = createBaseOperationTypeThreshold();
    message.type = object.type ?? 0;
    message.threshold = object.threshold ?? 0;
    return message;
  },
};

function createBaseAccountThreshold(): AccountThreshold {
  return { txThreshold: 0, typeThresholds: [] };
}

export const AccountThreshold: MessageFns<AccountThreshold> = {
  encode(
    message: AccountThreshold,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.txThreshold !== undefined && message.txThreshold !== 0) {
      writer.uint32(8).int64(message.txThreshold);
    }
    if (
      message.typeThresholds !== undefined &&
      message.typeThresholds.length !== 0
    ) {
      for (const v of message.typeThresholds) {
        OperationTypeThreshold.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountThreshold {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txThreshold = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = OperationTypeThreshold.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.typeThresholds!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountThreshold {
    return {
      txThreshold: isSet(object.tx_threshold)
        ? globalThis.Number(object.tx_threshold)
        : 0,
      typeThresholds: globalThis.Array.isArray(object?.type_thresholds)
        ? object.type_thresholds.map((e: any) =>
            OperationTypeThreshold.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: AccountThreshold): unknown {
    const obj: any = {};
    if (message.txThreshold !== undefined && message.txThreshold !== 0) {
      obj.tx_threshold = Math.round(message.txThreshold);
    }
    if (message.typeThresholds?.length) {
      obj.type_thresholds = message.typeThresholds.map((e) =>
        OperationTypeThreshold.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountThreshold>, I>>(
    base?: I,
  ): AccountThreshold {
    return AccountThreshold.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountThreshold>, I>>(
    object: I,
  ): AccountThreshold {
    const message = createBaseAccountThreshold();
    message.txThreshold = object.txThreshold ?? 0;
    message.typeThresholds =
      object.typeThresholds?.map((e) =>
        OperationTypeThreshold.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseOperationCreateAccount(): OperationCreateAccount {
  return {
    destAddress: "",
    contract: undefined,
    priv: undefined,
    metadatas: [],
    initBalance: 0,
    initInput: "",
  };
}

export const OperationCreateAccount: MessageFns<OperationCreateAccount> = {
  encode(
    message: OperationCreateAccount,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.destAddress !== undefined && message.destAddress !== "") {
      writer.uint32(10).string(message.destAddress);
    }
    if (message.contract !== undefined) {
      Contract.encode(message.contract, writer.uint32(18).fork()).join();
    }
    if (message.priv !== undefined) {
      AccountPrivilege.encode(message.priv, writer.uint32(26).fork()).join();
    }
    if (message.metadatas !== undefined && message.metadatas.length !== 0) {
      for (const v of message.metadatas) {
        KeyPair.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.initBalance !== undefined && message.initBalance !== 0) {
      writer.uint32(40).int64(message.initBalance);
    }
    if (message.initInput !== undefined && message.initInput !== "") {
      writer.uint32(50).string(message.initInput);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationCreateAccount {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationCreateAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contract = Contract.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.priv = AccountPrivilege.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = KeyPair.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.metadatas!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.initBalance = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.initInput = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationCreateAccount {
    return {
      destAddress: isSet(object.dest_address)
        ? globalThis.String(object.dest_address)
        : "",
      contract: isSet(object.contract)
        ? Contract.fromJSON(object.contract)
        : undefined,
      priv: isSet(object.priv)
        ? AccountPrivilege.fromJSON(object.priv)
        : undefined,
      metadatas: globalThis.Array.isArray(object?.metadatas)
        ? object.metadatas.map((e: any) => KeyPair.fromJSON(e))
        : [],
      initBalance: isSet(object.init_balance)
        ? globalThis.Number(object.init_balance)
        : 0,
      initInput: isSet(object.init_input)
        ? globalThis.String(object.init_input)
        : "",
    };
  },

  toJSON(message: OperationCreateAccount): unknown {
    const obj: any = {};
    if (message.destAddress !== undefined && message.destAddress !== "") {
      obj.dest_address = message.destAddress;
    }
    if (message.contract !== undefined) {
      obj.contract = Contract.toJSON(message.contract);
    }
    if (message.priv !== undefined) {
      obj.priv = AccountPrivilege.toJSON(message.priv);
    }
    if (message.metadatas?.length) {
      obj.metadatas = message.metadatas.map((e) => KeyPair.toJSON(e));
    }
    if (message.initBalance !== undefined && message.initBalance !== 0) {
      obj.init_balance = Math.round(message.initBalance);
    }
    if (message.initInput !== undefined && message.initInput !== "") {
      obj.init_input = message.initInput;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationCreateAccount>, I>>(
    base?: I,
  ): OperationCreateAccount {
    return OperationCreateAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationCreateAccount>, I>>(
    object: I,
  ): OperationCreateAccount {
    const message = createBaseOperationCreateAccount();
    message.destAddress = object.destAddress ?? "";
    message.contract =
      object.contract !== undefined && object.contract !== null
        ? Contract.fromPartial(object.contract)
        : undefined;
    message.priv =
      object.priv !== undefined && object.priv !== null
        ? AccountPrivilege.fromPartial(object.priv)
        : undefined;
    message.metadatas =
      object.metadatas?.map((e) => KeyPair.fromPartial(e)) || [];
    message.initBalance = object.initBalance ?? 0;
    message.initInput = object.initInput ?? "";
    return message;
  },
};

function createBaseOperationPayCoin(): OperationPayCoin {
  return { destAddress: "", amount: 0, input: "" };
}

export const OperationPayCoin: MessageFns<OperationPayCoin> = {
  encode(
    message: OperationPayCoin,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.destAddress !== undefined && message.destAddress !== "") {
      writer.uint32(10).string(message.destAddress);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.input !== undefined && message.input !== "") {
      writer.uint32(26).string(message.input);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationPayCoin {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationPayCoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.input = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationPayCoin {
    return {
      destAddress: isSet(object.dest_address)
        ? globalThis.String(object.dest_address)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      input: isSet(object.input) ? globalThis.String(object.input) : "",
    };
  },

  toJSON(message: OperationPayCoin): unknown {
    const obj: any = {};
    if (message.destAddress !== undefined && message.destAddress !== "") {
      obj.dest_address = message.destAddress;
    }
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.input !== undefined && message.input !== "") {
      obj.input = message.input;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationPayCoin>, I>>(
    base?: I,
  ): OperationPayCoin {
    return OperationPayCoin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationPayCoin>, I>>(
    object: I,
  ): OperationPayCoin {
    const message = createBaseOperationPayCoin();
    message.destAddress = object.destAddress ?? "";
    message.amount = object.amount ?? 0;
    message.input = object.input ?? "";
    return message;
  },
};

function createBaseOperationSetMetadata(): OperationSetMetadata {
  return { key: "", value: "", version: 0, deleteFlag: false };
}

export const OperationSetMetadata: MessageFns<OperationSetMetadata> = {
  encode(
    message: OperationSetMetadata,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(24).int64(message.version);
    }
    if (message.deleteFlag !== undefined && message.deleteFlag !== false) {
      writer.uint32(32).bool(message.deleteFlag);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationSetMetadata {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationSetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deleteFlag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationSetMetadata {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      deleteFlag: isSet(object.delete_flag)
        ? globalThis.Boolean(object.delete_flag)
        : false,
    };
  },

  toJSON(message: OperationSetMetadata): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.deleteFlag !== undefined && message.deleteFlag !== false) {
      obj.delete_flag = message.deleteFlag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationSetMetadata>, I>>(
    base?: I,
  ): OperationSetMetadata {
    return OperationSetMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationSetMetadata>, I>>(
    object: I,
  ): OperationSetMetadata {
    const message = createBaseOperationSetMetadata();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.version = object.version ?? 0;
    message.deleteFlag = object.deleteFlag ?? false;
    return message;
  },
};

function createBaseOperationUpgradeContract(): OperationUpgradeContract {
  return { destAddress: "", payload: "", type: 0 };
}

export const OperationUpgradeContract: MessageFns<OperationUpgradeContract> = {
  encode(
    message: OperationUpgradeContract,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.destAddress !== undefined && message.destAddress !== "") {
      writer.uint32(10).string(message.destAddress);
    }
    if (message.payload !== undefined && message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(24).int64(message.type);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationUpgradeContract {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationUpgradeContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationUpgradeContract {
    return {
      destAddress: isSet(object.dest_address)
        ? globalThis.String(object.dest_address)
        : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
    };
  },

  toJSON(message: OperationUpgradeContract): unknown {
    const obj: any = {};
    if (message.destAddress !== undefined && message.destAddress !== "") {
      obj.dest_address = message.destAddress;
    }
    if (message.payload !== undefined && message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationUpgradeContract>, I>>(
    base?: I,
  ): OperationUpgradeContract {
    return OperationUpgradeContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationUpgradeContract>, I>>(
    object: I,
  ): OperationUpgradeContract {
    const message = createBaseOperationUpgradeContract();
    message.destAddress = object.destAddress ?? "";
    message.payload = object.payload ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseOperationSetSignerWeight(): OperationSetSignerWeight {
  return { masterWeight: 0, signers: [] };
}

export const OperationSetSignerWeight: MessageFns<OperationSetSignerWeight> = {
  encode(
    message: OperationSetSignerWeight,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.masterWeight !== undefined && message.masterWeight !== 0) {
      writer.uint32(8).int64(message.masterWeight);
    }
    if (message.signers !== undefined && message.signers.length !== 0) {
      for (const v of message.signers) {
        Signer.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationSetSignerWeight {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationSetSignerWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.masterWeight = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = Signer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationSetSignerWeight {
    return {
      masterWeight: isSet(object.master_weight)
        ? globalThis.Number(object.master_weight)
        : 0,
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => Signer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OperationSetSignerWeight): unknown {
    const obj: any = {};
    if (message.masterWeight !== undefined && message.masterWeight !== 0) {
      obj.master_weight = Math.round(message.masterWeight);
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationSetSignerWeight>, I>>(
    base?: I,
  ): OperationSetSignerWeight {
    return OperationSetSignerWeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationSetSignerWeight>, I>>(
    object: I,
  ): OperationSetSignerWeight {
    const message = createBaseOperationSetSignerWeight();
    message.masterWeight = object.masterWeight ?? 0;
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperationSetThreshold(): OperationSetThreshold {
  return { txThreshold: 0, typeThresholds: [] };
}

export const OperationSetThreshold: MessageFns<OperationSetThreshold> = {
  encode(
    message: OperationSetThreshold,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.txThreshold !== undefined && message.txThreshold !== 0) {
      writer.uint32(8).int64(message.txThreshold);
    }
    if (
      message.typeThresholds !== undefined &&
      message.typeThresholds.length !== 0
    ) {
      for (const v of message.typeThresholds) {
        OperationTypeThreshold.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationSetThreshold {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationSetThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txThreshold = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = OperationTypeThreshold.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.typeThresholds!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationSetThreshold {
    return {
      txThreshold: isSet(object.txThreshold)
        ? globalThis.Number(object.txThreshold)
        : 0,
      typeThresholds: globalThis.Array.isArray(object?.type_thresholds)
        ? object.type_thresholds.map((e: any) =>
            OperationTypeThreshold.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: OperationSetThreshold): unknown {
    const obj: any = {};
    if (message.txThreshold !== undefined && message.txThreshold !== 0) {
      obj.txThreshold = Math.round(message.txThreshold);
    }
    if (message.typeThresholds?.length) {
      obj.type_thresholds = message.typeThresholds.map((e) =>
        OperationTypeThreshold.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationSetThreshold>, I>>(
    base?: I,
  ): OperationSetThreshold {
    return OperationSetThreshold.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationSetThreshold>, I>>(
    object: I,
  ): OperationSetThreshold {
    const message = createBaseOperationSetThreshold();
    message.txThreshold = object.txThreshold ?? 0;
    message.typeThresholds =
      object.typeThresholds?.map((e) =>
        OperationTypeThreshold.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseOperationLog(): OperationLog {
  return { topic: "", datas: [], topics: [] };
}

export const OperationLog: MessageFns<OperationLog> = {
  encode(
    message: OperationLog,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.topic !== undefined && message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.datas !== undefined && message.datas.length !== 0) {
      for (const v of message.datas) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.topics !== undefined && message.topics.length !== 0) {
      for (const v of message.topics) {
        writer.uint32(26).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationLog {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.datas!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.topics!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationLog {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      datas: globalThis.Array.isArray(object?.datas)
        ? object.datas.map((e: any) => globalThis.String(e))
        : [],
      topics: globalThis.Array.isArray(object?.topics)
        ? object.topics.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OperationLog): unknown {
    const obj: any = {};
    if (message.topic !== undefined && message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.datas?.length) {
      obj.datas = message.datas;
    }
    if (message.topics?.length) {
      obj.topics = message.topics;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationLog>, I>>(
    base?: I,
  ): OperationLog {
    return OperationLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationLog>, I>>(
    object: I,
  ): OperationLog {
    const message = createBaseOperationLog();
    message.topic = object.topic ?? "";
    message.datas = object.datas?.map((e) => e) || [];
    message.topics = object.topics?.map((e) => e) || [];
    return message;
  },
};

function createBaseOperationSetPrivilege(): OperationSetPrivilege {
  return { masterWeight: "", signers: [], txThreshold: "", typeThresholds: [] };
}

export const OperationSetPrivilege: MessageFns<OperationSetPrivilege> = {
  encode(
    message: OperationSetPrivilege,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.masterWeight !== undefined && message.masterWeight !== "") {
      writer.uint32(10).string(message.masterWeight);
    }
    if (message.signers !== undefined && message.signers.length !== 0) {
      for (const v of message.signers) {
        Signer.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.txThreshold !== undefined && message.txThreshold !== "") {
      writer.uint32(26).string(message.txThreshold);
    }
    if (
      message.typeThresholds !== undefined &&
      message.typeThresholds.length !== 0
    ) {
      for (const v of message.typeThresholds) {
        OperationTypeThreshold.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationSetPrivilege {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationSetPrivilege();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.masterWeight = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = Signer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signers!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.txThreshold = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = OperationTypeThreshold.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.typeThresholds!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationSetPrivilege {
    return {
      masterWeight: isSet(object.master_weight)
        ? globalThis.String(object.master_weight)
        : "",
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => Signer.fromJSON(e))
        : [],
      txThreshold: isSet(object.tx_threshold)
        ? globalThis.String(object.tx_threshold)
        : "",
      typeThresholds: globalThis.Array.isArray(object?.type_thresholds)
        ? object.type_thresholds.map((e: any) =>
            OperationTypeThreshold.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: OperationSetPrivilege): unknown {
    const obj: any = {};
    if (message.masterWeight !== undefined && message.masterWeight !== "") {
      obj.master_weight = message.masterWeight;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    if (message.txThreshold !== undefined && message.txThreshold !== "") {
      obj.tx_threshold = message.txThreshold;
    }
    if (message.typeThresholds?.length) {
      obj.type_thresholds = message.typeThresholds.map((e) =>
        OperationTypeThreshold.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationSetPrivilege>, I>>(
    base?: I,
  ): OperationSetPrivilege {
    return OperationSetPrivilege.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationSetPrivilege>, I>>(
    object: I,
  ): OperationSetPrivilege {
    const message = createBaseOperationSetPrivilege();
    message.masterWeight = object.masterWeight ?? "";
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    message.txThreshold = object.txThreshold ?? "";
    message.typeThresholds =
      object.typeThresholds?.map((e) =>
        OperationTypeThreshold.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseControlledArea(): ControlledArea {
  return { trusted: 0, status: 0, attributes: [] };
}

export const ControlledArea: MessageFns<ControlledArea> = {
  encode(
    message: ControlledArea,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trusted !== undefined && message.trusted !== 0) {
      writer.uint32(8).int32(message.trusted);
    }
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.attributes !== undefined && message.attributes.length !== 0) {
      for (const v of message.attributes) {
        KeyPair.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlledArea {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlledArea();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.trusted = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = KeyPair.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.attributes!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlledArea {
    return {
      trusted: isSet(object.trusted)
        ? controlledArea_trustFlagFromJSON(object.trusted)
        : 0,
      status: isSet(object.status)
        ? controlledArea_statusFalgFromJSON(object.status)
        : 0,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => KeyPair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ControlledArea): unknown {
    const obj: any = {};
    if (message.trusted !== undefined && message.trusted !== 0) {
      obj.trusted = controlledArea_trustFlagToJSON(message.trusted);
    }
    if (message.status !== undefined && message.status !== 0) {
      obj.status = controlledArea_statusFalgToJSON(message.status);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => KeyPair.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ControlledArea>, I>>(
    base?: I,
  ): ControlledArea {
    return ControlledArea.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ControlledArea>, I>>(
    object: I,
  ): ControlledArea {
    const message = createBaseControlledArea();
    message.trusted = object.trusted ?? 0;
    message.status = object.status ?? 0;
    message.attributes =
      object.attributes?.map((e) => KeyPair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperationSetControlledArea(): OperationSetControlledArea {
  return {
    destAddress: "",
    sTrusted: false,
    sStatus: false,
    trusted: 0,
    status: 0,
    attributes: [],
  };
}

export const OperationSetControlledArea: MessageFns<OperationSetControlledArea> =
  {
    encode(
      message: OperationSetControlledArea,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.destAddress !== undefined && message.destAddress !== "") {
        writer.uint32(10).string(message.destAddress);
      }
      if (message.sTrusted !== undefined && message.sTrusted !== false) {
        writer.uint32(16).bool(message.sTrusted);
      }
      if (message.sStatus !== undefined && message.sStatus !== false) {
        writer.uint32(24).bool(message.sStatus);
      }
      if (message.trusted !== undefined && message.trusted !== 0) {
        writer.uint32(32).int32(message.trusted);
      }
      if (message.status !== undefined && message.status !== 0) {
        writer.uint32(40).int32(message.status);
      }
      if (message.attributes !== undefined && message.attributes.length !== 0) {
        for (const v of message.attributes) {
          KeyPair.encode(v!, writer.uint32(50).fork()).join();
        }
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): OperationSetControlledArea {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseOperationSetControlledArea();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.destAddress = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.sTrusted = reader.bool();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.sStatus = reader.bool();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.trusted = reader.int32() as any;
            continue;
          }
          case 5: {
            if (tag !== 40) {
              break;
            }

            message.status = reader.int32() as any;
            continue;
          }
          case 6: {
            if (tag !== 50) {
              break;
            }

            const el = KeyPair.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.attributes!.push(el);
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): OperationSetControlledArea {
      return {
        destAddress: isSet(object.dest_address)
          ? globalThis.String(object.dest_address)
          : "",
        sTrusted: isSet(object.s_trusted)
          ? globalThis.Boolean(object.s_trusted)
          : false,
        sStatus: isSet(object.s_status)
          ? globalThis.Boolean(object.s_status)
          : false,
        trusted: isSet(object.trusted)
          ? controlledArea_trustFlagFromJSON(object.trusted)
          : 0,
        status: isSet(object.status)
          ? controlledArea_statusFalgFromJSON(object.status)
          : 0,
        attributes: globalThis.Array.isArray(object?.attributes)
          ? object.attributes.map((e: any) => KeyPair.fromJSON(e))
          : [],
      };
    },

    toJSON(message: OperationSetControlledArea): unknown {
      const obj: any = {};
      if (message.destAddress !== undefined && message.destAddress !== "") {
        obj.dest_address = message.destAddress;
      }
      if (message.sTrusted !== undefined && message.sTrusted !== false) {
        obj.s_trusted = message.sTrusted;
      }
      if (message.sStatus !== undefined && message.sStatus !== false) {
        obj.s_status = message.sStatus;
      }
      if (message.trusted !== undefined && message.trusted !== 0) {
        obj.trusted = controlledArea_trustFlagToJSON(message.trusted);
      }
      if (message.status !== undefined && message.status !== 0) {
        obj.status = controlledArea_statusFalgToJSON(message.status);
      }
      if (message.attributes?.length) {
        obj.attributes = message.attributes.map((e) => KeyPair.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<OperationSetControlledArea>, I>>(
      base?: I,
    ): OperationSetControlledArea {
      return OperationSetControlledArea.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<OperationSetControlledArea>, I>>(
      object: I,
    ): OperationSetControlledArea {
      const message = createBaseOperationSetControlledArea();
      message.destAddress = object.destAddress ?? "";
      message.sTrusted = object.sTrusted ?? false;
      message.sStatus = object.sStatus ?? false;
      message.trusted = object.trusted ?? 0;
      message.status = object.status ?? 0;
      message.attributes =
        object.attributes?.map((e) => KeyPair.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseOperationAuthorizeTransfer(): OperationAuthorizeTransfer {
  return { destAddress: "", auth: false };
}

export const OperationAuthorizeTransfer: MessageFns<OperationAuthorizeTransfer> =
  {
    encode(
      message: OperationAuthorizeTransfer,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.destAddress !== undefined && message.destAddress !== "") {
        writer.uint32(10).string(message.destAddress);
      }
      if (message.auth !== undefined && message.auth !== false) {
        writer.uint32(16).bool(message.auth);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): OperationAuthorizeTransfer {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseOperationAuthorizeTransfer();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.destAddress = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.auth = reader.bool();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): OperationAuthorizeTransfer {
      return {
        destAddress: isSet(object.dest_address)
          ? globalThis.String(object.dest_address)
          : "",
        auth: isSet(object.auth) ? globalThis.Boolean(object.auth) : false,
      };
    },

    toJSON(message: OperationAuthorizeTransfer): unknown {
      const obj: any = {};
      if (message.destAddress !== undefined && message.destAddress !== "") {
        obj.dest_address = message.destAddress;
      }
      if (message.auth !== undefined && message.auth !== false) {
        obj.auth = message.auth;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<OperationAuthorizeTransfer>, I>>(
      base?: I,
    ): OperationAuthorizeTransfer {
      return OperationAuthorizeTransfer.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<OperationAuthorizeTransfer>, I>>(
      object: I,
    ): OperationAuthorizeTransfer {
      const message = createBaseOperationAuthorizeTransfer();
      message.destAddress = object.destAddress ?? "";
      message.auth = object.auth ?? false;
      return message;
    },
  };

function createBaseOperation(): Operation {
  return {
    type: 0,
    sourceAddress: "",
    metadata: "",
    createAccount: undefined,
    setMetadata: undefined,
    setSignerWeight: undefined,
    setThreshold: undefined,
    payCoin: undefined,
    log: undefined,
    setPrivilege: undefined,
    upgradeContract: undefined,
    setControlledArea: undefined,
    authorizeTransfer: undefined,
  };
}

export const Operation: MessageFns<Operation> = {
  encode(
    message: Operation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      writer.uint32(18).string(message.sourceAddress);
    }
    if (message.metadata !== undefined && message.metadata !== "") {
      writer.uint32(26).string(message.metadata);
    }
    if (message.createAccount !== undefined) {
      OperationCreateAccount.encode(
        message.createAccount,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.setMetadata !== undefined) {
      OperationSetMetadata.encode(
        message.setMetadata,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.setSignerWeight !== undefined) {
      OperationSetSignerWeight.encode(
        message.setSignerWeight,
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.setThreshold !== undefined) {
      OperationSetThreshold.encode(
        message.setThreshold,
        writer.uint32(74).fork(),
      ).join();
    }
    if (message.payCoin !== undefined) {
      OperationPayCoin.encode(message.payCoin, writer.uint32(82).fork()).join();
    }
    if (message.log !== undefined) {
      OperationLog.encode(message.log, writer.uint32(90).fork()).join();
    }
    if (message.setPrivilege !== undefined) {
      OperationSetPrivilege.encode(
        message.setPrivilege,
        writer.uint32(98).fork(),
      ).join();
    }
    if (message.upgradeContract !== undefined) {
      OperationUpgradeContract.encode(
        message.upgradeContract,
        writer.uint32(106).fork(),
      ).join();
    }
    if (message.setControlledArea !== undefined) {
      OperationSetControlledArea.encode(
        message.setControlledArea,
        writer.uint32(114).fork(),
      ).join();
    }
    if (message.authorizeTransfer !== undefined) {
      OperationAuthorizeTransfer.encode(
        message.authorizeTransfer,
        writer.uint32(122).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createAccount = OperationCreateAccount.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.setMetadata = OperationSetMetadata.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.setSignerWeight = OperationSetSignerWeight.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.setThreshold = OperationSetThreshold.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.payCoin = OperationPayCoin.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.log = OperationLog.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.setPrivilege = OperationSetPrivilege.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.upgradeContract = OperationUpgradeContract.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.setControlledArea = OperationSetControlledArea.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.authorizeTransfer = OperationAuthorizeTransfer.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation {
    return {
      type: isSet(object.type) ? operation_TypeFromJSON(object.type) : 0,
      sourceAddress: isSet(object.source_address)
        ? globalThis.String(object.source_address)
        : "",
      metadata: isSet(object.metadata)
        ? globalThis.String(object.metadata)
        : "",
      createAccount: isSet(object.create_account)
        ? OperationCreateAccount.fromJSON(object.create_account)
        : undefined,
      setMetadata: isSet(object.set_metadata)
        ? OperationSetMetadata.fromJSON(object.set_metadata)
        : undefined,
      setSignerWeight: isSet(object.set_signer_weight)
        ? OperationSetSignerWeight.fromJSON(object.set_signer_weight)
        : undefined,
      setThreshold: isSet(object.set_threshold)
        ? OperationSetThreshold.fromJSON(object.set_threshold)
        : undefined,
      payCoin: isSet(object.pay_coin)
        ? OperationPayCoin.fromJSON(object.pay_coin)
        : undefined,
      log: isSet(object.log) ? OperationLog.fromJSON(object.log) : undefined,
      setPrivilege: isSet(object.set_privilege)
        ? OperationSetPrivilege.fromJSON(object.set_privilege)
        : undefined,
      upgradeContract: isSet(object.upgrade_contract)
        ? OperationUpgradeContract.fromJSON(object.upgrade_contract)
        : undefined,
      setControlledArea: isSet(object.set_controlled_area)
        ? OperationSetControlledArea.fromJSON(object.set_controlled_area)
        : undefined,
      authorizeTransfer: isSet(object.authorize_transfer)
        ? OperationAuthorizeTransfer.fromJSON(object.authorize_transfer)
        : undefined,
    };
  },

  toJSON(message: Operation): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = operation_TypeToJSON(message.type);
    }
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      obj.source_address = message.sourceAddress;
    }
    if (message.metadata !== undefined && message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.createAccount !== undefined) {
      obj.create_account = OperationCreateAccount.toJSON(message.createAccount);
    }
    if (message.setMetadata !== undefined) {
      obj.set_metadata = OperationSetMetadata.toJSON(message.setMetadata);
    }
    if (message.setSignerWeight !== undefined) {
      obj.set_signer_weight = OperationSetSignerWeight.toJSON(
        message.setSignerWeight,
      );
    }
    if (message.setThreshold !== undefined) {
      obj.set_threshold = OperationSetThreshold.toJSON(message.setThreshold);
    }
    if (message.payCoin !== undefined) {
      obj.pay_coin = OperationPayCoin.toJSON(message.payCoin);
    }
    if (message.log !== undefined) {
      obj.log = OperationLog.toJSON(message.log);
    }
    if (message.setPrivilege !== undefined) {
      obj.set_privilege = OperationSetPrivilege.toJSON(message.setPrivilege);
    }
    if (message.upgradeContract !== undefined) {
      obj.upgrade_contract = OperationUpgradeContract.toJSON(
        message.upgradeContract,
      );
    }
    if (message.setControlledArea !== undefined) {
      obj.set_controlled_area = OperationSetControlledArea.toJSON(
        message.setControlledArea,
      );
    }
    if (message.authorizeTransfer !== undefined) {
      obj.authorize_transfer = OperationAuthorizeTransfer.toJSON(
        message.authorizeTransfer,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation>, I>>(base?: I): Operation {
    return Operation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation>, I>>(
    object: I,
  ): Operation {
    const message = createBaseOperation();
    message.type = object.type ?? 0;
    message.sourceAddress = object.sourceAddress ?? "";
    message.metadata = object.metadata ?? "";
    message.createAccount =
      object.createAccount !== undefined && object.createAccount !== null
        ? OperationCreateAccount.fromPartial(object.createAccount)
        : undefined;
    message.setMetadata =
      object.setMetadata !== undefined && object.setMetadata !== null
        ? OperationSetMetadata.fromPartial(object.setMetadata)
        : undefined;
    message.setSignerWeight =
      object.setSignerWeight !== undefined && object.setSignerWeight !== null
        ? OperationSetSignerWeight.fromPartial(object.setSignerWeight)
        : undefined;
    message.setThreshold =
      object.setThreshold !== undefined && object.setThreshold !== null
        ? OperationSetThreshold.fromPartial(object.setThreshold)
        : undefined;
    message.payCoin =
      object.payCoin !== undefined && object.payCoin !== null
        ? OperationPayCoin.fromPartial(object.payCoin)
        : undefined;
    message.log =
      object.log !== undefined && object.log !== null
        ? OperationLog.fromPartial(object.log)
        : undefined;
    message.setPrivilege =
      object.setPrivilege !== undefined && object.setPrivilege !== null
        ? OperationSetPrivilege.fromPartial(object.setPrivilege)
        : undefined;
    message.upgradeContract =
      object.upgradeContract !== undefined && object.upgradeContract !== null
        ? OperationUpgradeContract.fromPartial(object.upgradeContract)
        : undefined;
    message.setControlledArea =
      object.setControlledArea !== undefined &&
      object.setControlledArea !== null
        ? OperationSetControlledArea.fromPartial(object.setControlledArea)
        : undefined;
    message.authorizeTransfer =
      object.authorizeTransfer !== undefined &&
      object.authorizeTransfer !== null
        ? OperationAuthorizeTransfer.fromPartial(object.authorizeTransfer)
        : undefined;
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return {
    sourceAddress: "",
    feeLimit: 0,
    gasPrice: 0,
    nonce: "",
    metadata: "",
    nonceType: 0,
    maxLedgerSeq: 0,
    operations: [],
  };
}

export const Transaction: MessageFns<Transaction> = {
  encode(
    message: Transaction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      writer.uint32(10).string(message.sourceAddress);
    }
    if (message.feeLimit !== undefined && message.feeLimit !== 0) {
      writer.uint32(16).int64(message.feeLimit);
    }
    if (message.gasPrice !== undefined && message.gasPrice !== 0) {
      writer.uint32(24).int64(message.gasPrice);
    }
    if (message.nonce !== undefined && message.nonce !== "") {
      writer.uint32(34).string(message.nonce);
    }
    if (message.metadata !== undefined && message.metadata !== "") {
      writer.uint32(42).string(message.metadata);
    }
    if (message.nonceType !== undefined && message.nonceType !== 0) {
      writer.uint32(48).int32(message.nonceType);
    }
    if (message.maxLedgerSeq !== undefined && message.maxLedgerSeq !== 0) {
      writer.uint32(56).int64(message.maxLedgerSeq);
    }
    if (message.operations !== undefined && message.operations.length !== 0) {
      for (const v of message.operations) {
        Operation.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feeLimit = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gasPrice = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.nonceType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxLedgerSeq = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const el = Operation.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.operations!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      sourceAddress: isSet(object.source_address)
        ? globalThis.String(object.source_address)
        : "",
      feeLimit: isSet(object.fee_limit)
        ? globalThis.Number(object.fee_limit)
        : 0,
      gasPrice: isSet(object.gas_price)
        ? globalThis.Number(object.gas_price)
        : 0,
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
      metadata: isSet(object.metadata)
        ? globalThis.String(object.metadata)
        : "",
      nonceType: isSet(object.nonce_type)
        ? transaction_TxTypeFromJSON(object.nonce_type)
        : 0,
      maxLedgerSeq: isSet(object.max_ledger_seq)
        ? globalThis.Number(object.max_ledger_seq)
        : 0,
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Operation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      obj.source_address = message.sourceAddress;
    }
    if (message.feeLimit !== undefined && message.feeLimit !== 0) {
      obj.fee_limit = Math.round(message.feeLimit);
    }
    if (message.gasPrice !== undefined && message.gasPrice !== 0) {
      obj.gas_price = Math.round(message.gasPrice);
    }
    if (message.nonce !== undefined && message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    if (message.metadata !== undefined && message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.nonceType !== undefined && message.nonceType !== 0) {
      obj.nonce_type = transaction_TxTypeToJSON(message.nonceType);
    }
    if (message.maxLedgerSeq !== undefined && message.maxLedgerSeq !== 0) {
      obj.max_ledger_seq = Math.round(message.maxLedgerSeq);
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Operation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(
    object: I,
  ): Transaction {
    const message = createBaseTransaction();
    message.sourceAddress = object.sourceAddress ?? "";
    message.feeLimit = object.feeLimit ?? 0;
    message.gasPrice = object.gasPrice ?? 0;
    message.nonce = object.nonce ?? "";
    message.metadata = object.metadata ?? "";
    message.nonceType = object.nonceType ?? 0;
    message.maxLedgerSeq = object.maxLedgerSeq ?? 0;
    message.operations =
      object.operations?.map((e) => Operation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTrigger(): Trigger {
  return { transactionType: 0, ledgerSeq: 0, transaction: undefined };
}

export const Trigger: MessageFns<Trigger> = {
  encode(
    message: Trigger,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (
      message.transactionType !== undefined &&
      message.transactionType !== 0
    ) {
      writer.uint32(8).int32(message.transactionType);
    }
    if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
      writer.uint32(16).int64(message.ledgerSeq);
    }
    if (message.transaction !== undefined) {
      Trigger_OperationTrigger.encode(
        message.transaction,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trigger {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ledgerSeq = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transaction = Trigger_OperationTrigger.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trigger {
    return {
      transactionType: isSet(object.transactionType)
        ? trigger_TransactionTypeFromJSON(object.transactionType)
        : 0,
      ledgerSeq: isSet(object.ledger_seq)
        ? globalThis.Number(object.ledger_seq)
        : 0,
      transaction: isSet(object.transaction)
        ? Trigger_OperationTrigger.fromJSON(object.transaction)
        : undefined,
    };
  },

  toJSON(message: Trigger): unknown {
    const obj: any = {};
    if (
      message.transactionType !== undefined &&
      message.transactionType !== 0
    ) {
      obj.transactionType = trigger_TransactionTypeToJSON(
        message.transactionType,
      );
    }
    if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
      obj.ledger_seq = Math.round(message.ledgerSeq);
    }
    if (message.transaction !== undefined) {
      obj.transaction = Trigger_OperationTrigger.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trigger>, I>>(base?: I): Trigger {
    return Trigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trigger>, I>>(object: I): Trigger {
    const message = createBaseTrigger();
    message.transactionType = object.transactionType ?? 0;
    message.ledgerSeq = object.ledgerSeq ?? 0;
    message.transaction =
      object.transaction !== undefined && object.transaction !== null
        ? Trigger_OperationTrigger.fromPartial(object.transaction)
        : undefined;
    return message;
  },
};

function createBaseTrigger_OperationTrigger(): Trigger_OperationTrigger {
  return { hash: new Uint8Array(0), index: 0 };
}

export const Trigger_OperationTrigger: MessageFns<Trigger_OperationTrigger> = {
  encode(
    message: Trigger_OperationTrigger,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.hash !== undefined && message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    if (message.index !== undefined && message.index !== 0) {
      writer.uint32(16).int64(message.index);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Trigger_OperationTrigger {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrigger_OperationTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trigger_OperationTrigger {
    return {
      hash: isSet(object.hash)
        ? bytesFromBase64(object.hash)
        : new Uint8Array(0),
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: Trigger_OperationTrigger): unknown {
    const obj: any = {};
    if (message.hash !== undefined && message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.index !== undefined && message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trigger_OperationTrigger>, I>>(
    base?: I,
  ): Trigger_OperationTrigger {
    return Trigger_OperationTrigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trigger_OperationTrigger>, I>>(
    object: I,
  ): Trigger_OperationTrigger {
    const message = createBaseTrigger_OperationTrigger();
    message.hash = object.hash ?? new Uint8Array(0);
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseTransactionEnv(): TransactionEnv {
  return { transaction: undefined, signatures: [], trigger: undefined };
}

export const TransactionEnv: MessageFns<TransactionEnv> = {
  encode(
    message: TransactionEnv,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    if (message.signatures !== undefined && message.signatures.length !== 0) {
      for (const v of message.signatures) {
        Signature.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.trigger !== undefined) {
      Trigger.encode(message.trigger, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEnv {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEnv();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = Signature.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signatures!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trigger = Trigger.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEnv {
    return {
      transaction: isSet(object.transaction)
        ? Transaction.fromJSON(object.transaction)
        : undefined,
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => Signature.fromJSON(e))
        : [],
      trigger: isSet(object.trigger)
        ? Trigger.fromJSON(object.trigger)
        : undefined,
    };
  },

  toJSON(message: TransactionEnv): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => Signature.toJSON(e));
    }
    if (message.trigger !== undefined) {
      obj.trigger = Trigger.toJSON(message.trigger);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionEnv>, I>>(
    base?: I,
  ): TransactionEnv {
    return TransactionEnv.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionEnv>, I>>(
    object: I,
  ): TransactionEnv {
    const message = createBaseTransactionEnv();
    message.transaction =
      object.transaction !== undefined && object.transaction !== null
        ? Transaction.fromPartial(object.transaction)
        : undefined;
    message.signatures =
      object.signatures?.map((e) => Signature.fromPartial(e)) || [];
    message.trigger =
      object.trigger !== undefined && object.trigger !== null
        ? Trigger.fromPartial(object.trigger)
        : undefined;
    return message;
  },
};

function createBaseTransactionEnvStoreMessage(): TransactionEnvStoreMessage {
  return {
    transactionEnv: undefined,
    errorCode: 0,
    errorDesc: "",
    ledgerSeq: 0,
    closeTime: 0,
    hash: "",
    actualFee: 0,
    contractTxHashes: [],
  };
}

export const TransactionEnvStoreMessage: MessageFns<TransactionEnvStoreMessage> =
  {
    encode(
      message: TransactionEnvStoreMessage,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.transactionEnv !== undefined) {
        TransactionEnv.encode(
          message.transactionEnv,
          writer.uint32(10).fork(),
        ).join();
      }
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(16).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(26).string(message.errorDesc);
      }
      if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
        writer.uint32(32).int64(message.ledgerSeq);
      }
      if (message.closeTime !== undefined && message.closeTime !== 0) {
        writer.uint32(40).int64(message.closeTime);
      }
      if (message.hash !== undefined && message.hash !== "") {
        writer.uint32(50).string(message.hash);
      }
      if (message.actualFee !== undefined && message.actualFee !== 0) {
        writer.uint32(56).int64(message.actualFee);
      }
      if (
        message.contractTxHashes !== undefined &&
        message.contractTxHashes.length !== 0
      ) {
        for (const v of message.contractTxHashes) {
          writer.uint32(66).string(v!);
        }
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): TransactionEnvStoreMessage {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTransactionEnvStoreMessage();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.transactionEnv = TransactionEnv.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.errorCode = reader.int32();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.ledgerSeq = longToNumber(reader.int64());
            continue;
          }
          case 5: {
            if (tag !== 40) {
              break;
            }

            message.closeTime = longToNumber(reader.int64());
            continue;
          }
          case 6: {
            if (tag !== 50) {
              break;
            }

            message.hash = reader.string();
            continue;
          }
          case 7: {
            if (tag !== 56) {
              break;
            }

            message.actualFee = longToNumber(reader.int64());
            continue;
          }
          case 8: {
            if (tag !== 66) {
              break;
            }

            const el = reader.string();
            if (el !== undefined) {
              message.contractTxHashes!.push(el);
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): TransactionEnvStoreMessage {
      return {
        transactionEnv: isSet(object.transaction_env)
          ? TransactionEnv.fromJSON(object.transaction_env)
          : undefined,
        errorCode: isSet(object.error_code)
          ? globalThis.Number(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
        ledgerSeq: isSet(object.ledger_seq)
          ? globalThis.Number(object.ledger_seq)
          : 0,
        closeTime: isSet(object.close_time)
          ? globalThis.Number(object.close_time)
          : 0,
        hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
        actualFee: isSet(object.actual_fee)
          ? globalThis.Number(object.actual_fee)
          : 0,
        contractTxHashes: globalThis.Array.isArray(object?.contract_tx_hashes)
          ? object.contract_tx_hashes.map((e: any) => globalThis.String(e))
          : [],
      };
    },

    toJSON(message: TransactionEnvStoreMessage): unknown {
      const obj: any = {};
      if (message.transactionEnv !== undefined) {
        obj.transaction_env = TransactionEnv.toJSON(message.transactionEnv);
      }
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = Math.round(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
        obj.ledger_seq = Math.round(message.ledgerSeq);
      }
      if (message.closeTime !== undefined && message.closeTime !== 0) {
        obj.close_time = Math.round(message.closeTime);
      }
      if (message.hash !== undefined && message.hash !== "") {
        obj.hash = message.hash;
      }
      if (message.actualFee !== undefined && message.actualFee !== 0) {
        obj.actual_fee = Math.round(message.actualFee);
      }
      if (message.contractTxHashes?.length) {
        obj.contract_tx_hashes = message.contractTxHashes;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<TransactionEnvStoreMessage>, I>>(
      base?: I,
    ): TransactionEnvStoreMessage {
      return TransactionEnvStoreMessage.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<TransactionEnvStoreMessage>, I>>(
      object: I,
    ): TransactionEnvStoreMessage {
      const message = createBaseTransactionEnvStoreMessage();
      message.transactionEnv =
        object.transactionEnv !== undefined && object.transactionEnv !== null
          ? TransactionEnv.fromPartial(object.transactionEnv)
          : undefined;
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      message.ledgerSeq = object.ledgerSeq ?? 0;
      message.closeTime = object.closeTime ?? 0;
      message.hash = object.hash ?? "";
      message.actualFee = object.actualFee ?? 0;
      message.contractTxHashes = object.contractTxHashes?.map((e) => e) || [];
      return message;
    },
  };

function createBaseSignature(): Signature {
  return { publicKey: "", signData: "" };
}

export const Signature: MessageFns<Signature> = {
  encode(
    message: Signature,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.publicKey !== undefined && message.publicKey !== "") {
      writer.uint32(10).string(message.publicKey);
    }
    if (message.signData !== undefined && message.signData !== "") {
      writer.uint32(18).string(message.signData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signature {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signature {
    return {
      publicKey: isSet(object.public_key)
        ? globalThis.String(object.public_key)
        : "",
      signData: isSet(object.sign_data)
        ? globalThis.String(object.sign_data)
        : "",
    };
  },

  toJSON(message: Signature): unknown {
    const obj: any = {};
    if (message.publicKey !== undefined && message.publicKey !== "") {
      obj.public_key = message.publicKey;
    }
    if (message.signData !== undefined && message.signData !== "") {
      obj.sign_data = message.signData;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Signature>, I>>(base?: I): Signature {
    return Signature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Signature>, I>>(
    object: I,
  ): Signature {
    const message = createBaseSignature();
    message.publicKey = object.publicKey ?? "";
    message.signData = object.signData ?? "";
    return message;
  },
};

function createBaseKeyPair(): KeyPair {
  return { key: "", value: "", version: 0 };
}

export const KeyPair: MessageFns<KeyPair> = {
  encode(
    message: KeyPair,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(24).int64(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyPair {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyPair {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: KeyPair): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyPair>, I>>(base?: I): KeyPair {
    return KeyPair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyPair>, I>>(object: I): KeyPair {
    const message = createBaseKeyPair();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseDropTxMessage(): DropTxMessage {
  return { txHash: "", source: 0, timestamp: 0, tx: "" };
}

export const DropTxMessage: MessageFns<DropTxMessage> = {
  encode(
    message: DropTxMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.txHash !== undefined && message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    if (message.source !== undefined && message.source !== 0) {
      writer.uint32(16).int32(message.source);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      writer.uint32(24).int64(message.timestamp);
    }
    if (message.tx !== undefined && message.tx !== "") {
      writer.uint32(34).string(message.tx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DropTxMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropTxMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tx = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DropTxMessage {
    return {
      txHash: isSet(object.tx_hash) ? globalThis.String(object.tx_hash) : "",
      source: isSet(object.source)
        ? dropTxMessage_PoolTypeFromJSON(object.source)
        : 0,
      timestamp: isSet(object.timestamp)
        ? globalThis.Number(object.timestamp)
        : 0,
      tx: isSet(object.tx) ? globalThis.String(object.tx) : "",
    };
  },

  toJSON(message: DropTxMessage): unknown {
    const obj: any = {};
    if (message.txHash !== undefined && message.txHash !== "") {
      obj.tx_hash = message.txHash;
    }
    if (message.source !== undefined && message.source !== 0) {
      obj.source = dropTxMessage_PoolTypeToJSON(message.source);
    }
    if (message.timestamp !== undefined && message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.tx !== undefined && message.tx !== "") {
      obj.tx = message.tx;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DropTxMessage>, I>>(
    base?: I,
  ): DropTxMessage {
    return DropTxMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DropTxMessage>, I>>(
    object: I,
  ): DropTxMessage {
    const message = createBaseDropTxMessage();
    message.txHash = object.txHash ?? "";
    message.source = object.source ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.tx = object.tx ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
