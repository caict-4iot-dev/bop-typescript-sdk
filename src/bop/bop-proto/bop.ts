// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v3.20.3
// source: bop.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "bop";

/** 开放平台状态码定义 */
export enum StatusCodes {
  /** SUCCESS - 成功状态 */
  SUCCESS = 0,
  /** INTERNAL_SERVER_ERROR - 服务内部错误 */
  INTERNAL_SERVER_ERROR = 1,
  /** INVALID_PARAMETER - 参数错误 */
  INVALID_PARAMETER = 2,
  /** OBJECT_ALREADY_EXISTS - 对象已存在，如重复提交交易 */
  OBJECT_ALREADY_EXISTS = 3,
  /** OBJECT_NOT_FOUND - 对象不存在，如查询不到账号、TX、区块等 */
  OBJECT_NOT_FOUND = 4,
  /** TX_TIMEOUT - TX 超时 */
  TX_TIMEOUT = 5,
  /** ACCOUNT_FORBIDDEN - 账户禁止使用 */
  ACCOUNT_FORBIDDEN = 6,
  /** MATH_OVERFLOW - 数学计算溢出 */
  MATH_OVERFLOW = 7,
  /** ILLEGAL_PUBLIC_KEY - 公钥非法 */
  ILLEGAL_PUBLIC_KEY = 90,
  /** ILLEGAL_PRIVATE_KEY - 私钥非法 */
  ILLEGAL_PRIVATE_KEY = 91,
  /** INSUFFICIENT_SIGNATURE_WEIGHT - 签名权重不够，达不到操作的门限值 */
  INSUFFICIENT_SIGNATURE_WEIGHT = 93,
  /** ILLEGAL_ADDRESS - 地址非法 */
  ILLEGAL_ADDRESS = 94,
  /** MISSING_TRANSACTION_OPERATION - 交易缺失操作 */
  MISSING_TRANSACTION_OPERATION = 97,
  /** TOO_MANY_OPERATIONS - 单笔交易内超过了100个操作 */
  TOO_MANY_OPERATIONS = 98,
  /** INVALID_NONCE - 交易序号错误，nonce错误 */
  INVALID_NONCE = 99,
  /** INSUFFICIENT_BALANCE - 余额不足 */
  INSUFFICIENT_BALANCE = 100,
  /** SOURCE_AND_DESTINATION_EQUAL - 源和目的账号相等 */
  SOURCE_AND_DESTINATION_EQUAL = 101,
  /** ACCOUNT_ALREADY_EXISTS - 创建账号操作，目标账号已存在 */
  ACCOUNT_ALREADY_EXISTS = 102,
  /** ACCOUNT_NOT_FOUND - 账户不存在 */
  ACCOUNT_NOT_FOUND = 103,
  /** INSUFFICIENT_INITIAL_ASSETS - 创建账号初始化资产小于配置文件中最小费用 */
  INSUFFICIENT_INITIAL_ASSETS = 106,
  /** INSUFFICIENT_FEE - 费用不足 */
  INSUFFICIENT_FEE = 111,
  /** WEIGHT_OUT_OF_RANGE - 权重值不在有效范围 */
  WEIGHT_OUT_OF_RANGE = 120,
  /** THRESHOLD_OUT_OF_RANGE - 门限值不在有效范围 */
  THRESHOLD_OUT_OF_RANGE = 121,
  /** MISMATCHING_METADATA_VERSION - metadata的version版本号不与已有的匹配 */
  MISMATCHING_METADATA_VERSION = 144,
  /** TRANSACTION_DATA_TOO_LARGE - 交易数据超出上限 */
  TRANSACTION_DATA_TOO_LARGE = 146,
  /** CONTRACT_EXECUTION_FAILED - 合约执行失败 */
  CONTRACT_EXECUTION_FAILED = 151,
  /** CONTRACT_PARSE_FAILED - 合约语法分析失败 */
  CONTRACT_PARSE_FAILED = 152,
  /** CONTRACT_RECURSION_DEPTH_EXCEEDED - 合约递归深度超出上限 */
  CONTRACT_RECURSION_DEPTH_EXCEEDED = 153,
  /** CONTRACT_GENERATED_TOO_MANY_TRANSACTIONS - 合约产生的交易超出上限 */
  CONTRACT_GENERATED_TOO_MANY_TRANSACTIONS = 154,
  /** CONTRACT_EXECUTION_TIMEOUT - 合约执行超时 */
  CONTRACT_EXECUTION_TIMEOUT = 155,
  /** NON_CONTRACT_ADDRESS - 目标地址非合约账户 */
  NON_CONTRACT_ADDRESS = 156,
  /** FAILED_TO_INSERT_INTO_TX_QUEUE - 插入交易缓存队列失败 */
  FAILED_TO_INSERT_INTO_TX_QUEUE = 160,
  /** FORBIDDEN_SPARK_TOKEN_TRANSFER - 禁止转移星火令 */
  FORBIDDEN_SPARK_TOKEN_TRANSFER = 161,
  /** SERVICE_DOMAIN_NOT_FOUND - 服务域不存在 */
  SERVICE_DOMAIN_NOT_FOUND = 170,
  /** SNAPSHOT_NOT_FOUND_FOR_FAST_SYNC - 快速同步的快照不存在 */
  SNAPSHOT_NOT_FOUND_FOR_FAST_SYNC = 180,
  /** ERROR_RETRIEVING_SNAPSHOT_FOR_FAST_SYNC - 快速同步获取快照数据错误 */
  ERROR_RETRIEVING_SNAPSHOT_FOR_FAST_SYNC = 181,
  /** DUPLICATE_NONCE_IN_CACHE - 交易nonce重复，nonce在缓存中 (需重新发送交易) */
  DUPLICATE_NONCE_IN_CACHE = 183,
  /** INVALID_MAX_BLOCK_NUMBER - 交易最大区块数错误，小于当前区块高度 (需要重新获取区块高度序列化接口) */
  INVALID_MAX_BLOCK_NUMBER = 184,
  /** API_NOT_FOUND - 请求的API不存在 */
  API_NOT_FOUND = 1013,
  /** API_DEPRECATED - 请求的API已停用 */
  API_DEPRECATED = 1015,
  /** TIMEOUT - timeout */
  TIMEOUT = 1016,
  /** PARAMETER_TYPE_PARSING_EXCEPTION - 参数类型解析异常 */
  PARAMETER_TYPE_PARSING_EXCEPTION = -3,
  /** INVALID_PARAMETER_EXCEPTION - 无效参数异常 */
  INVALID_PARAMETER_EXCEPTION = -6,
  /** REQUEST_TYPE_EXCEPTION - 请求类型异常 */
  REQUEST_TYPE_EXCEPTION = -7,
  /** UNIFIED_VALIDATION_EXCEPTION - 统一验证参数异常 */
  UNIFIED_VALIDATION_EXCEPTION = -9,
  /** METHOD_NOT_ALLOWED - 不支持当前请求类型 */
  METHOD_NOT_ALLOWED = 405,
  /** SENSITIVE_WORDS_IN_TRANSACTION - 交易数据中包含敏感词汇 */
  SENSITIVE_WORDS_IN_TRANSACTION = 1101,
  /** CONTRACT_ADDRESS_NOT_IN_WHITELIST - 您的合约地址未在项目合约白名单 */
  CONTRACT_ADDRESS_NOT_IN_WHITELIST = 1102,
  /** ILLEGAL_TRANSACTION_DATA - 请检查交易数据是否合规 */
  ILLEGAL_TRANSACTION_DATA = 1103,
  /** TRANSACTION_TYPE_NOT_FOUND - 交易类型不存在 */
  TRANSACTION_TYPE_NOT_FOUND = 1105,
  /** REMOTE_CALL_FAILED - 远程调用失败 */
  REMOTE_CALL_FAILED = 1106,
  /** TRANSACTION_POOL_TYPE_NOT_FOUND - 交易池类型不存在 */
  TRANSACTION_POOL_TYPE_NOT_FOUND = 1107,
  /** PARAMETER_OUT_OF_RANGE - 参数超出限制 */
  PARAMETER_OUT_OF_RANGE = 1108,
  /** ILLEGAL_PARAMETER - 非法参数 */
  ILLEGAL_PARAMETER = 1109,
  /** TX_TYPE_REQUIRED - 当bid 或 tx_id为不为空时，tx_type为必填 */
  TX_TYPE_REQUIRED = 1110,
  /** BUSINESS_PARAMETER_CANNOT_BE_EMPTY - 业务参数不能为空 */
  BUSINESS_PARAMETER_CANNOT_BE_EMPTY = 1111,
  /** API_KEY_NOT_FOUND - API Key不存在 */
  API_KEY_NOT_FOUND = 1122,
  /** REQUEST_RATE_EXCEEDED_PER_SECOND - 每秒请求频次超出限制 */
  REQUEST_RATE_EXCEEDED_PER_SECOND = 1200,
  /** REQUEST_RATE_EXCEEDED_PER_DAY - 每日请求频次超出限制 */
  REQUEST_RATE_EXCEEDED_PER_DAY = 1201,
  /** NO_RESOURCES_AVAILABLE - 您已无资源可用 */
  NO_RESOURCES_AVAILABLE = 1202,
  /** PROJECT_DELETED - 项目已被删除 */
  PROJECT_DELETED = 1203,
  /** PROJECT_DISABLED - 项目已禁用 */
  PROJECT_DISABLED = 1204,
  /** PROJECT_BLACKLISTED - 项目被拉入黑名单 */
  PROJECT_BLACKLISTED = 1205,
  /** ACCOUNT_BLACKLISTED - 账户被拉入黑名单 */
  ACCOUNT_BLACKLISTED = 1206,
  /** API_SECRET_REQUIRED_IN_HEADER - 请在Header中传入API Secret */
  API_SECRET_REQUIRED_IN_HEADER = 1207,
  /** MISMATCHING_API_SECRET - 传入的API Secret与项目不匹配 */
  MISMATCHING_API_SECRET = 1208,
  /** ENHANCED_TRANSACTION_SERVICE_NOT_ENABLED - 增强交易服务未开启 */
  ENHANCED_TRANSACTION_SERVICE_NOT_ENABLED = 1209,
  /** MISMATCHING_PROJECT_AND_API_TYPE - 项目类型与API类型不一致 */
  MISMATCHING_PROJECT_AND_API_TYPE = 1210,
  /** PROJECT_WITHOUT_MAINNET_PERMISSION - 当前项目还没有主网权限 */
  PROJECT_WITHOUT_MAINNET_PERMISSION = 1211,
  /** IN_PLATFORM_QUEUE - 平台队列中 */
  IN_PLATFORM_QUEUE = 1311,
  /** TRANSACTION_SUBMITTED_TO_SPARKCHAIN - 交易已提交到星火链 */
  TRANSACTION_SUBMITTED_TO_SPARKCHAIN = 1312,
  /** TRANSACTION_POOL_TIMEOUT_DISCARD - 平台交易池超时丢弃 */
  TRANSACTION_POOL_TIMEOUT_DISCARD = 1313,
  /** NO_TRANSACTION_POOL_FOR_PROJECT - 项目暂无交易池(增强交易) */
  NO_TRANSACTION_POOL_FOR_PROJECT = 1314,
  /** TRANSACTION_ALREADY_EXISTS - 交易已存在 */
  TRANSACTION_ALREADY_EXISTS = 1315,
  /** SPARKCHAIN_TIMEOUT_DISCARD - 星火链超时丢弃 */
  SPARKCHAIN_TIMEOUT_DISCARD = 1316,
  /** TOO_MANY_TRANSACTION_OPERATIONS - 交易操作频繁 */
  TOO_MANY_TRANSACTION_OPERATIONS = 1317,
<<<<<<< HEAD
  URL_ERROR = 9999,
=======
>>>>>>> 6f9cdce ([feat] Functional development completed)
  UNRECOGNIZED = -1,
}

export function statusCodesFromJSON(object: any): StatusCodes {
  switch (object) {
    case 0:
    case "SUCCESS":
      return StatusCodes.SUCCESS;
    case 1:
    case "INTERNAL_SERVER_ERROR":
      return StatusCodes.INTERNAL_SERVER_ERROR;
    case 2:
    case "INVALID_PARAMETER":
      return StatusCodes.INVALID_PARAMETER;
    case 3:
    case "OBJECT_ALREADY_EXISTS":
      return StatusCodes.OBJECT_ALREADY_EXISTS;
    case 4:
    case "OBJECT_NOT_FOUND":
      return StatusCodes.OBJECT_NOT_FOUND;
    case 5:
    case "TX_TIMEOUT":
      return StatusCodes.TX_TIMEOUT;
    case 6:
    case "ACCOUNT_FORBIDDEN":
      return StatusCodes.ACCOUNT_FORBIDDEN;
    case 7:
    case "MATH_OVERFLOW":
      return StatusCodes.MATH_OVERFLOW;
    case 90:
    case "ILLEGAL_PUBLIC_KEY":
      return StatusCodes.ILLEGAL_PUBLIC_KEY;
    case 91:
    case "ILLEGAL_PRIVATE_KEY":
      return StatusCodes.ILLEGAL_PRIVATE_KEY;
    case 93:
    case "INSUFFICIENT_SIGNATURE_WEIGHT":
      return StatusCodes.INSUFFICIENT_SIGNATURE_WEIGHT;
    case 94:
    case "ILLEGAL_ADDRESS":
      return StatusCodes.ILLEGAL_ADDRESS;
    case 97:
    case "MISSING_TRANSACTION_OPERATION":
      return StatusCodes.MISSING_TRANSACTION_OPERATION;
    case 98:
    case "TOO_MANY_OPERATIONS":
      return StatusCodes.TOO_MANY_OPERATIONS;
    case 99:
    case "INVALID_NONCE":
      return StatusCodes.INVALID_NONCE;
    case 100:
    case "INSUFFICIENT_BALANCE":
      return StatusCodes.INSUFFICIENT_BALANCE;
    case 101:
    case "SOURCE_AND_DESTINATION_EQUAL":
      return StatusCodes.SOURCE_AND_DESTINATION_EQUAL;
    case 102:
    case "ACCOUNT_ALREADY_EXISTS":
      return StatusCodes.ACCOUNT_ALREADY_EXISTS;
    case 103:
    case "ACCOUNT_NOT_FOUND":
      return StatusCodes.ACCOUNT_NOT_FOUND;
    case 106:
    case "INSUFFICIENT_INITIAL_ASSETS":
      return StatusCodes.INSUFFICIENT_INITIAL_ASSETS;
    case 111:
    case "INSUFFICIENT_FEE":
      return StatusCodes.INSUFFICIENT_FEE;
    case 120:
    case "WEIGHT_OUT_OF_RANGE":
      return StatusCodes.WEIGHT_OUT_OF_RANGE;
    case 121:
    case "THRESHOLD_OUT_OF_RANGE":
      return StatusCodes.THRESHOLD_OUT_OF_RANGE;
    case 144:
    case "MISMATCHING_METADATA_VERSION":
      return StatusCodes.MISMATCHING_METADATA_VERSION;
    case 146:
    case "TRANSACTION_DATA_TOO_LARGE":
      return StatusCodes.TRANSACTION_DATA_TOO_LARGE;
    case 151:
    case "CONTRACT_EXECUTION_FAILED":
      return StatusCodes.CONTRACT_EXECUTION_FAILED;
    case 152:
    case "CONTRACT_PARSE_FAILED":
      return StatusCodes.CONTRACT_PARSE_FAILED;
    case 153:
    case "CONTRACT_RECURSION_DEPTH_EXCEEDED":
      return StatusCodes.CONTRACT_RECURSION_DEPTH_EXCEEDED;
    case 154:
    case "CONTRACT_GENERATED_TOO_MANY_TRANSACTIONS":
      return StatusCodes.CONTRACT_GENERATED_TOO_MANY_TRANSACTIONS;
    case 155:
    case "CONTRACT_EXECUTION_TIMEOUT":
      return StatusCodes.CONTRACT_EXECUTION_TIMEOUT;
    case 156:
    case "NON_CONTRACT_ADDRESS":
      return StatusCodes.NON_CONTRACT_ADDRESS;
    case 160:
    case "FAILED_TO_INSERT_INTO_TX_QUEUE":
      return StatusCodes.FAILED_TO_INSERT_INTO_TX_QUEUE;
    case 161:
    case "FORBIDDEN_SPARK_TOKEN_TRANSFER":
      return StatusCodes.FORBIDDEN_SPARK_TOKEN_TRANSFER;
    case 170:
    case "SERVICE_DOMAIN_NOT_FOUND":
      return StatusCodes.SERVICE_DOMAIN_NOT_FOUND;
    case 180:
    case "SNAPSHOT_NOT_FOUND_FOR_FAST_SYNC":
      return StatusCodes.SNAPSHOT_NOT_FOUND_FOR_FAST_SYNC;
    case 181:
    case "ERROR_RETRIEVING_SNAPSHOT_FOR_FAST_SYNC":
      return StatusCodes.ERROR_RETRIEVING_SNAPSHOT_FOR_FAST_SYNC;
    case 183:
    case "DUPLICATE_NONCE_IN_CACHE":
      return StatusCodes.DUPLICATE_NONCE_IN_CACHE;
    case 184:
    case "INVALID_MAX_BLOCK_NUMBER":
      return StatusCodes.INVALID_MAX_BLOCK_NUMBER;
    case 1013:
    case "API_NOT_FOUND":
      return StatusCodes.API_NOT_FOUND;
    case 1015:
    case "API_DEPRECATED":
      return StatusCodes.API_DEPRECATED;
    case 1016:
    case "TIMEOUT":
      return StatusCodes.TIMEOUT;
    case -3:
    case "PARAMETER_TYPE_PARSING_EXCEPTION":
      return StatusCodes.PARAMETER_TYPE_PARSING_EXCEPTION;
    case -6:
    case "INVALID_PARAMETER_EXCEPTION":
      return StatusCodes.INVALID_PARAMETER_EXCEPTION;
    case -7:
    case "REQUEST_TYPE_EXCEPTION":
      return StatusCodes.REQUEST_TYPE_EXCEPTION;
    case -9:
    case "UNIFIED_VALIDATION_EXCEPTION":
      return StatusCodes.UNIFIED_VALIDATION_EXCEPTION;
    case 405:
    case "METHOD_NOT_ALLOWED":
      return StatusCodes.METHOD_NOT_ALLOWED;
    case 1101:
    case "SENSITIVE_WORDS_IN_TRANSACTION":
      return StatusCodes.SENSITIVE_WORDS_IN_TRANSACTION;
    case 1102:
    case "CONTRACT_ADDRESS_NOT_IN_WHITELIST":
      return StatusCodes.CONTRACT_ADDRESS_NOT_IN_WHITELIST;
    case 1103:
    case "ILLEGAL_TRANSACTION_DATA":
      return StatusCodes.ILLEGAL_TRANSACTION_DATA;
    case 1105:
    case "TRANSACTION_TYPE_NOT_FOUND":
      return StatusCodes.TRANSACTION_TYPE_NOT_FOUND;
    case 1106:
    case "REMOTE_CALL_FAILED":
      return StatusCodes.REMOTE_CALL_FAILED;
    case 1107:
    case "TRANSACTION_POOL_TYPE_NOT_FOUND":
      return StatusCodes.TRANSACTION_POOL_TYPE_NOT_FOUND;
    case 1108:
    case "PARAMETER_OUT_OF_RANGE":
      return StatusCodes.PARAMETER_OUT_OF_RANGE;
    case 1109:
    case "ILLEGAL_PARAMETER":
      return StatusCodes.ILLEGAL_PARAMETER;
    case 1110:
    case "TX_TYPE_REQUIRED":
      return StatusCodes.TX_TYPE_REQUIRED;
    case 1111:
    case "BUSINESS_PARAMETER_CANNOT_BE_EMPTY":
      return StatusCodes.BUSINESS_PARAMETER_CANNOT_BE_EMPTY;
    case 1122:
    case "API_KEY_NOT_FOUND":
      return StatusCodes.API_KEY_NOT_FOUND;
    case 1200:
    case "REQUEST_RATE_EXCEEDED_PER_SECOND":
      return StatusCodes.REQUEST_RATE_EXCEEDED_PER_SECOND;
    case 1201:
    case "REQUEST_RATE_EXCEEDED_PER_DAY":
      return StatusCodes.REQUEST_RATE_EXCEEDED_PER_DAY;
    case 1202:
    case "NO_RESOURCES_AVAILABLE":
      return StatusCodes.NO_RESOURCES_AVAILABLE;
    case 1203:
    case "PROJECT_DELETED":
      return StatusCodes.PROJECT_DELETED;
    case 1204:
    case "PROJECT_DISABLED":
      return StatusCodes.PROJECT_DISABLED;
    case 1205:
    case "PROJECT_BLACKLISTED":
      return StatusCodes.PROJECT_BLACKLISTED;
    case 1206:
    case "ACCOUNT_BLACKLISTED":
      return StatusCodes.ACCOUNT_BLACKLISTED;
    case 1207:
    case "API_SECRET_REQUIRED_IN_HEADER":
      return StatusCodes.API_SECRET_REQUIRED_IN_HEADER;
    case 1208:
    case "MISMATCHING_API_SECRET":
      return StatusCodes.MISMATCHING_API_SECRET;
    case 1209:
    case "ENHANCED_TRANSACTION_SERVICE_NOT_ENABLED":
      return StatusCodes.ENHANCED_TRANSACTION_SERVICE_NOT_ENABLED;
    case 1210:
    case "MISMATCHING_PROJECT_AND_API_TYPE":
      return StatusCodes.MISMATCHING_PROJECT_AND_API_TYPE;
    case 1211:
    case "PROJECT_WITHOUT_MAINNET_PERMISSION":
      return StatusCodes.PROJECT_WITHOUT_MAINNET_PERMISSION;
    case 1311:
    case "IN_PLATFORM_QUEUE":
      return StatusCodes.IN_PLATFORM_QUEUE;
    case 1312:
    case "TRANSACTION_SUBMITTED_TO_SPARKCHAIN":
      return StatusCodes.TRANSACTION_SUBMITTED_TO_SPARKCHAIN;
    case 1313:
    case "TRANSACTION_POOL_TIMEOUT_DISCARD":
      return StatusCodes.TRANSACTION_POOL_TIMEOUT_DISCARD;
    case 1314:
    case "NO_TRANSACTION_POOL_FOR_PROJECT":
      return StatusCodes.NO_TRANSACTION_POOL_FOR_PROJECT;
    case 1315:
    case "TRANSACTION_ALREADY_EXISTS":
      return StatusCodes.TRANSACTION_ALREADY_EXISTS;
    case 1316:
    case "SPARKCHAIN_TIMEOUT_DISCARD":
      return StatusCodes.SPARKCHAIN_TIMEOUT_DISCARD;
    case 1317:
    case "TOO_MANY_TRANSACTION_OPERATIONS":
      return StatusCodes.TOO_MANY_TRANSACTION_OPERATIONS;
    case 9999:
    case "URL_ERROR":
      return StatusCodes.URL_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StatusCodes.UNRECOGNIZED;
  }
}

export function statusCodesToJSON(object: StatusCodes): string {
  switch (object) {
    case StatusCodes.SUCCESS:
      return "SUCCESS";
    case StatusCodes.INTERNAL_SERVER_ERROR:
      return "INTERNAL_SERVER_ERROR";
    case StatusCodes.INVALID_PARAMETER:
      return "INVALID_PARAMETER";
    case StatusCodes.OBJECT_ALREADY_EXISTS:
      return "OBJECT_ALREADY_EXISTS";
    case StatusCodes.OBJECT_NOT_FOUND:
      return "OBJECT_NOT_FOUND";
    case StatusCodes.TX_TIMEOUT:
      return "TX_TIMEOUT";
    case StatusCodes.ACCOUNT_FORBIDDEN:
      return "ACCOUNT_FORBIDDEN";
    case StatusCodes.MATH_OVERFLOW:
      return "MATH_OVERFLOW";
    case StatusCodes.ILLEGAL_PUBLIC_KEY:
      return "ILLEGAL_PUBLIC_KEY";
    case StatusCodes.ILLEGAL_PRIVATE_KEY:
      return "ILLEGAL_PRIVATE_KEY";
    case StatusCodes.INSUFFICIENT_SIGNATURE_WEIGHT:
      return "INSUFFICIENT_SIGNATURE_WEIGHT";
    case StatusCodes.ILLEGAL_ADDRESS:
      return "ILLEGAL_ADDRESS";
    case StatusCodes.MISSING_TRANSACTION_OPERATION:
      return "MISSING_TRANSACTION_OPERATION";
    case StatusCodes.TOO_MANY_OPERATIONS:
      return "TOO_MANY_OPERATIONS";
    case StatusCodes.INVALID_NONCE:
      return "INVALID_NONCE";
    case StatusCodes.INSUFFICIENT_BALANCE:
      return "INSUFFICIENT_BALANCE";
    case StatusCodes.SOURCE_AND_DESTINATION_EQUAL:
      return "SOURCE_AND_DESTINATION_EQUAL";
    case StatusCodes.ACCOUNT_ALREADY_EXISTS:
      return "ACCOUNT_ALREADY_EXISTS";
    case StatusCodes.ACCOUNT_NOT_FOUND:
      return "ACCOUNT_NOT_FOUND";
    case StatusCodes.INSUFFICIENT_INITIAL_ASSETS:
      return "INSUFFICIENT_INITIAL_ASSETS";
    case StatusCodes.INSUFFICIENT_FEE:
      return "INSUFFICIENT_FEE";
    case StatusCodes.WEIGHT_OUT_OF_RANGE:
      return "WEIGHT_OUT_OF_RANGE";
    case StatusCodes.THRESHOLD_OUT_OF_RANGE:
      return "THRESHOLD_OUT_OF_RANGE";
    case StatusCodes.MISMATCHING_METADATA_VERSION:
      return "MISMATCHING_METADATA_VERSION";
    case StatusCodes.TRANSACTION_DATA_TOO_LARGE:
      return "TRANSACTION_DATA_TOO_LARGE";
    case StatusCodes.CONTRACT_EXECUTION_FAILED:
      return "CONTRACT_EXECUTION_FAILED";
    case StatusCodes.CONTRACT_PARSE_FAILED:
      return "CONTRACT_PARSE_FAILED";
    case StatusCodes.CONTRACT_RECURSION_DEPTH_EXCEEDED:
      return "CONTRACT_RECURSION_DEPTH_EXCEEDED";
    case StatusCodes.CONTRACT_GENERATED_TOO_MANY_TRANSACTIONS:
      return "CONTRACT_GENERATED_TOO_MANY_TRANSACTIONS";
    case StatusCodes.CONTRACT_EXECUTION_TIMEOUT:
      return "CONTRACT_EXECUTION_TIMEOUT";
    case StatusCodes.NON_CONTRACT_ADDRESS:
      return "NON_CONTRACT_ADDRESS";
    case StatusCodes.FAILED_TO_INSERT_INTO_TX_QUEUE:
      return "FAILED_TO_INSERT_INTO_TX_QUEUE";
    case StatusCodes.FORBIDDEN_SPARK_TOKEN_TRANSFER:
      return "FORBIDDEN_SPARK_TOKEN_TRANSFER";
    case StatusCodes.SERVICE_DOMAIN_NOT_FOUND:
      return "SERVICE_DOMAIN_NOT_FOUND";
    case StatusCodes.SNAPSHOT_NOT_FOUND_FOR_FAST_SYNC:
      return "SNAPSHOT_NOT_FOUND_FOR_FAST_SYNC";
    case StatusCodes.ERROR_RETRIEVING_SNAPSHOT_FOR_FAST_SYNC:
      return "ERROR_RETRIEVING_SNAPSHOT_FOR_FAST_SYNC";
    case StatusCodes.DUPLICATE_NONCE_IN_CACHE:
      return "DUPLICATE_NONCE_IN_CACHE";
    case StatusCodes.INVALID_MAX_BLOCK_NUMBER:
      return "INVALID_MAX_BLOCK_NUMBER";
    case StatusCodes.API_NOT_FOUND:
      return "API_NOT_FOUND";
    case StatusCodes.API_DEPRECATED:
      return "API_DEPRECATED";
    case StatusCodes.TIMEOUT:
      return "TIMEOUT";
    case StatusCodes.PARAMETER_TYPE_PARSING_EXCEPTION:
      return "PARAMETER_TYPE_PARSING_EXCEPTION";
    case StatusCodes.INVALID_PARAMETER_EXCEPTION:
      return "INVALID_PARAMETER_EXCEPTION";
    case StatusCodes.REQUEST_TYPE_EXCEPTION:
      return "REQUEST_TYPE_EXCEPTION";
    case StatusCodes.UNIFIED_VALIDATION_EXCEPTION:
      return "UNIFIED_VALIDATION_EXCEPTION";
    case StatusCodes.METHOD_NOT_ALLOWED:
      return "METHOD_NOT_ALLOWED";
    case StatusCodes.SENSITIVE_WORDS_IN_TRANSACTION:
      return "SENSITIVE_WORDS_IN_TRANSACTION";
    case StatusCodes.CONTRACT_ADDRESS_NOT_IN_WHITELIST:
      return "CONTRACT_ADDRESS_NOT_IN_WHITELIST";
    case StatusCodes.ILLEGAL_TRANSACTION_DATA:
      return "ILLEGAL_TRANSACTION_DATA";
    case StatusCodes.TRANSACTION_TYPE_NOT_FOUND:
      return "TRANSACTION_TYPE_NOT_FOUND";
    case StatusCodes.REMOTE_CALL_FAILED:
      return "REMOTE_CALL_FAILED";
    case StatusCodes.TRANSACTION_POOL_TYPE_NOT_FOUND:
      return "TRANSACTION_POOL_TYPE_NOT_FOUND";
    case StatusCodes.PARAMETER_OUT_OF_RANGE:
      return "PARAMETER_OUT_OF_RANGE";
    case StatusCodes.ILLEGAL_PARAMETER:
      return "ILLEGAL_PARAMETER";
    case StatusCodes.TX_TYPE_REQUIRED:
      return "TX_TYPE_REQUIRED";
    case StatusCodes.BUSINESS_PARAMETER_CANNOT_BE_EMPTY:
      return "BUSINESS_PARAMETER_CANNOT_BE_EMPTY";
    case StatusCodes.API_KEY_NOT_FOUND:
      return "API_KEY_NOT_FOUND";
    case StatusCodes.REQUEST_RATE_EXCEEDED_PER_SECOND:
      return "REQUEST_RATE_EXCEEDED_PER_SECOND";
    case StatusCodes.REQUEST_RATE_EXCEEDED_PER_DAY:
      return "REQUEST_RATE_EXCEEDED_PER_DAY";
    case StatusCodes.NO_RESOURCES_AVAILABLE:
      return "NO_RESOURCES_AVAILABLE";
    case StatusCodes.PROJECT_DELETED:
      return "PROJECT_DELETED";
    case StatusCodes.PROJECT_DISABLED:
      return "PROJECT_DISABLED";
    case StatusCodes.PROJECT_BLACKLISTED:
      return "PROJECT_BLACKLISTED";
    case StatusCodes.ACCOUNT_BLACKLISTED:
      return "ACCOUNT_BLACKLISTED";
    case StatusCodes.API_SECRET_REQUIRED_IN_HEADER:
      return "API_SECRET_REQUIRED_IN_HEADER";
    case StatusCodes.MISMATCHING_API_SECRET:
      return "MISMATCHING_API_SECRET";
    case StatusCodes.ENHANCED_TRANSACTION_SERVICE_NOT_ENABLED:
      return "ENHANCED_TRANSACTION_SERVICE_NOT_ENABLED";
    case StatusCodes.MISMATCHING_PROJECT_AND_API_TYPE:
      return "MISMATCHING_PROJECT_AND_API_TYPE";
    case StatusCodes.PROJECT_WITHOUT_MAINNET_PERMISSION:
      return "PROJECT_WITHOUT_MAINNET_PERMISSION";
    case StatusCodes.IN_PLATFORM_QUEUE:
      return "IN_PLATFORM_QUEUE";
    case StatusCodes.TRANSACTION_SUBMITTED_TO_SPARKCHAIN:
      return "TRANSACTION_SUBMITTED_TO_SPARKCHAIN";
    case StatusCodes.TRANSACTION_POOL_TIMEOUT_DISCARD:
      return "TRANSACTION_POOL_TIMEOUT_DISCARD";
    case StatusCodes.NO_TRANSACTION_POOL_FOR_PROJECT:
      return "NO_TRANSACTION_POOL_FOR_PROJECT";
    case StatusCodes.TRANSACTION_ALREADY_EXISTS:
      return "TRANSACTION_ALREADY_EXISTS";
    case StatusCodes.SPARKCHAIN_TIMEOUT_DISCARD:
      return "SPARKCHAIN_TIMEOUT_DISCARD";
    case StatusCodes.TOO_MANY_TRANSACTION_OPERATIONS:
      return "TOO_MANY_TRANSACTION_OPERATIONS";
    case StatusCodes.URL_ERROR:
      return "URL_ERROR";
    case StatusCodes.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * 账号备案 permit
 * 备案或取消备案的请求项
 */
export interface BidStatus {
  /** 申请账号（长度在1-64之间） */
  bid?: string | undefined;
  /** 账号状态，0：取消许可，1:许可（长度为1） */
  status?: string | undefined;
}

/** 备案或取消备案的请求消息 */
export interface ApplyRequest {
  /** 申请备案、取消备案bid集合，上限100条 */
  data?: BidStatus[] | undefined;
}

export interface ApplyResult {
  requestNo?: string | undefined;
}

export interface ApplyResponse {
  trace?: string | undefined;
  result?: ApplyResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface ApplyStatusRequest {
  requestNo?: string | undefined;
}

export interface ApplyStatusResult {
  /** 请求的序号 */
  requestNo?: string | undefined;
  /** 存储状态（0：待处理，1：处理中，2：处理成功，3：处理失败） */
  status?: string | undefined;
  /** 数据上链交易hash */
  txHash?: string | undefined;
  /** 错误描述（如果处理失败，则提供详细错误信息） */
  errorDesc?: string | undefined;
}

export interface ApplyStatusResponse {
  trace?: string | undefined;
  result?: ApplyStatusResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface DetailRequest {
  requestNo?: string | undefined;
}

export interface DetailResult {
  /** 请求的序号 */
  requestNo?: string | undefined;
  /** 数据上链交易hash（假设为字符串） */
  txHash?: string | undefined;
  /** bid集合（字符串列表） */
  bidList?: string | undefined;
}

export interface DetailResponse {
  trace?: string | undefined;
  result?: DetailResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

/** base */
export interface HelloResult {
  chainCode?: string | undefined;
  licenseVersion?: string | undefined;
  monitorVersion?: string | undefined;
  overlayVersion?: string | undefined;
  websocketPort?: number | undefined;
  addressPrefix?: string | undefined;
  chainVersion?: string | undefined;
  currentTime?: string | undefined;
  hashType?: string | undefined;
  ledgerVersion?: string | undefined;
  networkId?: string | undefined;
}

export interface HelloResponse {
  trace?: string | undefined;
  result?: HelloResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

/** 获取链上某个账户的信息 */
export interface GetAccountRequest {
  address?: string | undefined;
  height?: number | undefined;
  key?: string | undefined;
}

export interface Contract {
  type?: Contract_ContractType | undefined;
  payload?: string | undefined;
}

export enum Contract_ContractType {
  JAVASCRIPT = 0,
  EVM = 1,
  SYSTEM = 2,
  UNRECOGNIZED = -1,
}

export function contract_ContractTypeFromJSON(
  object: any,
): Contract_ContractType {
  switch (object) {
    case 0:
    case "JAVASCRIPT":
      return Contract_ContractType.JAVASCRIPT;
    case 1:
    case "EVM":
      return Contract_ContractType.EVM;
    case 2:
    case "SYSTEM":
      return Contract_ContractType.SYSTEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Contract_ContractType.UNRECOGNIZED;
  }
}

export function contract_ContractTypeToJSON(
  object: Contract_ContractType,
): string {
  switch (object) {
    case Contract_ContractType.JAVASCRIPT:
      return "JAVASCRIPT";
    case Contract_ContractType.EVM:
      return "EVM";
    case Contract_ContractType.SYSTEM:
      return "SYSTEM";
    case Contract_ContractType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Signer {
  address?: string | undefined;
  weight?: number | undefined;
}

export enum Signer_Limit {
  SIGNER_NONE = 0,
  SIGNER = 100,
  UNRECOGNIZED = -1,
}

export function signer_LimitFromJSON(object: any): Signer_Limit {
  switch (object) {
    case 0:
    case "SIGNER_NONE":
      return Signer_Limit.SIGNER_NONE;
    case 100:
    case "SIGNER":
      return Signer_Limit.SIGNER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Signer_Limit.UNRECOGNIZED;
  }
}

export function signer_LimitToJSON(object: Signer_Limit): string {
  switch (object) {
    case Signer_Limit.SIGNER_NONE:
      return "SIGNER_NONE";
    case Signer_Limit.SIGNER:
      return "SIGNER";
    case Signer_Limit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AccountPrivilege {
  masterWeight?: number | undefined;
  signers?: Signer[] | undefined;
  thresholds?: AccountThreshold | undefined;
}

export interface OperationTypeThreshold {
  type?: OperationTypeThreshold_Type | undefined;
  threshold?: number | undefined;
}

export enum OperationTypeThreshold_Type {
  UNKNOWN = 0,
  CREATE_ACCOUNT = 1,
  SET_METADATA = 4,
  SET_SIGNER_WEIGHT = 5,
  SET_THRESHOLD = 6,
  PAY_COIN = 7,
  LOG = 8,
  SET_PRIVILEGE = 9,
  UPGRADE_CONTRACT = 10,
  SET_CONTROLLED_AREA = 11,
  AUTHORIZE_TRANSFER = 12,
  UNRECOGNIZED = -1,
}

export function operationTypeThreshold_TypeFromJSON(
  object: any,
): OperationTypeThreshold_Type {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return OperationTypeThreshold_Type.UNKNOWN;
    case 1:
    case "CREATE_ACCOUNT":
      return OperationTypeThreshold_Type.CREATE_ACCOUNT;
    case 4:
    case "SET_METADATA":
      return OperationTypeThreshold_Type.SET_METADATA;
    case 5:
    case "SET_SIGNER_WEIGHT":
      return OperationTypeThreshold_Type.SET_SIGNER_WEIGHT;
    case 6:
    case "SET_THRESHOLD":
      return OperationTypeThreshold_Type.SET_THRESHOLD;
    case 7:
    case "PAY_COIN":
      return OperationTypeThreshold_Type.PAY_COIN;
    case 8:
    case "LOG":
      return OperationTypeThreshold_Type.LOG;
    case 9:
    case "SET_PRIVILEGE":
      return OperationTypeThreshold_Type.SET_PRIVILEGE;
    case 10:
    case "UPGRADE_CONTRACT":
      return OperationTypeThreshold_Type.UPGRADE_CONTRACT;
    case 11:
    case "SET_CONTROLLED_AREA":
      return OperationTypeThreshold_Type.SET_CONTROLLED_AREA;
    case 12:
    case "AUTHORIZE_TRANSFER":
      return OperationTypeThreshold_Type.AUTHORIZE_TRANSFER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperationTypeThreshold_Type.UNRECOGNIZED;
  }
}

export function operationTypeThreshold_TypeToJSON(
  object: OperationTypeThreshold_Type,
): string {
  switch (object) {
    case OperationTypeThreshold_Type.UNKNOWN:
      return "UNKNOWN";
    case OperationTypeThreshold_Type.CREATE_ACCOUNT:
      return "CREATE_ACCOUNT";
    case OperationTypeThreshold_Type.SET_METADATA:
      return "SET_METADATA";
    case OperationTypeThreshold_Type.SET_SIGNER_WEIGHT:
      return "SET_SIGNER_WEIGHT";
    case OperationTypeThreshold_Type.SET_THRESHOLD:
      return "SET_THRESHOLD";
    case OperationTypeThreshold_Type.PAY_COIN:
      return "PAY_COIN";
    case OperationTypeThreshold_Type.LOG:
      return "LOG";
    case OperationTypeThreshold_Type.SET_PRIVILEGE:
      return "SET_PRIVILEGE";
    case OperationTypeThreshold_Type.UPGRADE_CONTRACT:
      return "UPGRADE_CONTRACT";
    case OperationTypeThreshold_Type.SET_CONTROLLED_AREA:
      return "SET_CONTROLLED_AREA";
    case OperationTypeThreshold_Type.AUTHORIZE_TRANSFER:
      return "AUTHORIZE_TRANSFER";
    case OperationTypeThreshold_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AccountThreshold {
  txThreshold?: number | undefined;
  typeThresholds?: OperationTypeThreshold[] | undefined;
}

export interface KeyPair {
  key?: string | undefined;
  value?: string | undefined;
  version?: number | undefined;
}

export interface GetAccountResult {
  address?: string | undefined;
  balance?: number | undefined;
  nonce?: number | undefined;
  authTransfer?: boolean | undefined;
  metadatasHash?: string | undefined;
  contract?: Contract | undefined;
  priv?: AccountPrivilege | undefined;
  metadatas?: KeyPair[] | undefined;
}

export interface GetAccountResponse {
  trace?: string | undefined;
  result?: GetAccountResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface GetAccountBaseRequest {
  address?: string | undefined;
}

export interface GetAccountBaseResponse {
  trace?: string | undefined;
  result?: GetAccountResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

/** 获取指定账户metadata数据 */
export interface GetAccountMetadataRequest {
  address?: string | undefined;
  key?: string | undefined;
}

export interface GetAccountMetadataResponse {
  trace?: string | undefined;
  result?: { [key: string]: KeyPair } | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface GetAccountMetadataResponse_ResultEntry {
  key: string;
  value?: KeyPair | undefined;
}

export interface GetLedgerRequest {
  seq?: number | undefined;
  withValidator?: boolean | undefined;
  withLeader?: boolean | undefined;
}

export interface LedgerHeader {
  seq?: number | undefined;
  hash?: string | undefined;
  previousHash?: string | undefined;
  accountTreeHash?: string | undefined;
  closeTime?: number | undefined;
  consensusValueHash?: string | undefined;
  version?: number | undefined;
  txCount?: number | undefined;
  validatorsHash?: string | undefined;
  feesHash?: string | undefined;
}

export interface GetLedgerResult {
  leader?: string | undefined;
  validators?: string[] | undefined;
  header?: LedgerHeader | undefined;
  ledgerLength?: number | undefined;
}

export interface GetLedgerResponse {
  trace?: string | undefined;
  result?: GetLedgerResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface Signature {
  publicKey?: string | undefined;
  signData?: string | undefined;
}

export interface TxBlob {
  transactionBlob?: string | undefined;
  signatures?: Signature[] | undefined;
}

export interface SubmitTransactionRequest {
  items?: TxBlob[] | undefined;
}

export interface SubmitTransactionResult {
  hash?: string | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface SubmitTransactionResponse {
  results?: SubmitTransactionResult[] | undefined;
  successCount?: number | undefined;
}

export interface GetTransactionHistoryRequest {
  hash?: string | undefined;
  ledgerSeq?: number | undefined;
  start?: number | undefined;
  limit?: number | undefined;
}

export interface OperationCreateAccount {
  destAddress?: string | undefined;
  contract?: Contract | undefined;
  priv?: AccountPrivilege | undefined;
  metadatas?: KeyPair[] | undefined;
  initBalance?: number | undefined;
  initInput?: string | undefined;
}

export interface OperationPayCoin {
  destAddress?: string | undefined;
  amount?: number | undefined;
  input?: string | undefined;
}

export interface OperationSetMetadata {
  key?: string | undefined;
  value?: string | undefined;
  /** optional */
  version?: number | undefined;
  deleteFlag?: boolean | undefined;
}

export interface OperationUpgradeContract {
  destAddress?: string | undefined;
  payload?: string | undefined;
  type?: number | undefined;
}

export interface OperationSetSignerWeight {
  /** required, [-1,MAX(UINT32)] -1: indicates no setting */
  masterWeight?: number | undefined;
  /** address:weight, if weight is 0, it indicates deleting this signer */
  signers?: Signer[] | undefined;
}

export interface OperationSetThreshold {
  txThreshold?: number | undefined;
  /** type:threshold, threshold:0 indicates deleting this type */
  typeThresholds?: OperationTypeThreshold[] | undefined;
}

export interface OperationLog {
  topic?: string | undefined;
  datas?: string[] | undefined;
  /** for evm */
  topics?: string[] | undefined;
}

export interface OperationSetPrivilege {
  masterWeight?: string | undefined;
  signers?: Signer[] | undefined;
  txThreshold?: string | undefined;
  typeThresholds?: OperationTypeThreshold[] | undefined;
}

export interface ControlledArea {
  trusted?: ControlledArea_trustFlag | undefined;
  status?: ControlledArea_statusFalg | undefined;
  attributes?: KeyPair[] | undefined;
}

export enum ControlledArea_trustFlag {
  UNCERT = 0,
  TRUSTED = 1,
  UNTRUSTED = 2,
  UNRECOGNIZED = -1,
}

export function controlledArea_trustFlagFromJSON(
  object: any,
): ControlledArea_trustFlag {
  switch (object) {
    case 0:
    case "UNCERT":
      return ControlledArea_trustFlag.UNCERT;
    case 1:
    case "TRUSTED":
      return ControlledArea_trustFlag.TRUSTED;
    case 2:
    case "UNTRUSTED":
      return ControlledArea_trustFlag.UNTRUSTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ControlledArea_trustFlag.UNRECOGNIZED;
  }
}

export function controlledArea_trustFlagToJSON(
  object: ControlledArea_trustFlag,
): string {
  switch (object) {
    case ControlledArea_trustFlag.UNCERT:
      return "UNCERT";
    case ControlledArea_trustFlag.TRUSTED:
      return "TRUSTED";
    case ControlledArea_trustFlag.UNTRUSTED:
      return "UNTRUSTED";
    case ControlledArea_trustFlag.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ControlledArea_statusFalg {
  ENABLED = 0,
  DISABLED = 1,
  UNRECOGNIZED = -1,
}

export function controlledArea_statusFalgFromJSON(
  object: any,
): ControlledArea_statusFalg {
  switch (object) {
    case 0:
    case "ENABLED":
      return ControlledArea_statusFalg.ENABLED;
    case 1:
    case "DISABLED":
      return ControlledArea_statusFalg.DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ControlledArea_statusFalg.UNRECOGNIZED;
  }
}

export function controlledArea_statusFalgToJSON(
  object: ControlledArea_statusFalg,
): string {
  switch (object) {
    case ControlledArea_statusFalg.ENABLED:
      return "ENABLED";
    case ControlledArea_statusFalg.DISABLED:
      return "DISABLED";
    case ControlledArea_statusFalg.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OperationSetControlledArea {
  destAddress?: string | undefined;
  sTrusted?: boolean | undefined;
  sStatus?: boolean | undefined;
  trusted?: ControlledArea_trustFlag | undefined;
  status?: ControlledArea_statusFalg | undefined;
  attributes?: KeyPair[] | undefined;
}

export interface OperationAuthorizeTransfer {
  destAddress?: string | undefined;
  auth?: boolean | undefined;
}

export interface Operation {
  type?: Operation_Type | undefined;
  sourceAddress?: string | undefined;
  metadata?: string | undefined;
  createAccount?: OperationCreateAccount | undefined;
  setMetadata?: OperationSetMetadata | undefined;
  setSignerWeight?: OperationSetSignerWeight | undefined;
  setThreshold?: OperationSetThreshold | undefined;
  payCoin?: OperationPayCoin | undefined;
  log?: OperationLog | undefined;
  setPrivilege?: OperationSetPrivilege | undefined;
  upgradeContract?: OperationUpgradeContract | undefined;
  setControlledArea?: OperationSetControlledArea | undefined;
  authorizeTransfer?: OperationAuthorizeTransfer | undefined;
}

export enum Operation_Type {
  UNKNOWN = 0,
  CREATE_ACCOUNT = 1,
  SET_METADATA = 4,
  SET_SIGNER_WEIGHT = 5,
  SET_THRESHOLD = 6,
  PAY_COIN = 7,
  LOG = 8,
  SET_PRIVILEGE = 9,
  UPGRADE_CONTRACT = 10,
  SET_CONTROLLED_AREA = 11,
  AUTHORIZE_TRANSFER = 12,
  UNRECOGNIZED = -1,
}

export function operation_TypeFromJSON(object: any): Operation_Type {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Operation_Type.UNKNOWN;
    case 1:
    case "CREATE_ACCOUNT":
      return Operation_Type.CREATE_ACCOUNT;
    case 4:
    case "SET_METADATA":
      return Operation_Type.SET_METADATA;
    case 5:
    case "SET_SIGNER_WEIGHT":
      return Operation_Type.SET_SIGNER_WEIGHT;
    case 6:
    case "SET_THRESHOLD":
      return Operation_Type.SET_THRESHOLD;
    case 7:
    case "PAY_COIN":
      return Operation_Type.PAY_COIN;
    case 8:
    case "LOG":
      return Operation_Type.LOG;
    case 9:
    case "SET_PRIVILEGE":
      return Operation_Type.SET_PRIVILEGE;
    case 10:
    case "UPGRADE_CONTRACT":
      return Operation_Type.UPGRADE_CONTRACT;
    case 11:
    case "SET_CONTROLLED_AREA":
      return Operation_Type.SET_CONTROLLED_AREA;
    case 12:
    case "AUTHORIZE_TRANSFER":
      return Operation_Type.AUTHORIZE_TRANSFER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Operation_Type.UNRECOGNIZED;
  }
}

export function operation_TypeToJSON(object: Operation_Type): string {
  switch (object) {
    case Operation_Type.UNKNOWN:
      return "UNKNOWN";
    case Operation_Type.CREATE_ACCOUNT:
      return "CREATE_ACCOUNT";
    case Operation_Type.SET_METADATA:
      return "SET_METADATA";
    case Operation_Type.SET_SIGNER_WEIGHT:
      return "SET_SIGNER_WEIGHT";
    case Operation_Type.SET_THRESHOLD:
      return "SET_THRESHOLD";
    case Operation_Type.PAY_COIN:
      return "PAY_COIN";
    case Operation_Type.LOG:
      return "LOG";
    case Operation_Type.SET_PRIVILEGE:
      return "SET_PRIVILEGE";
    case Operation_Type.UPGRADE_CONTRACT:
      return "UPGRADE_CONTRACT";
    case Operation_Type.SET_CONTROLLED_AREA:
      return "SET_CONTROLLED_AREA";
    case Operation_Type.AUTHORIZE_TRANSFER:
      return "AUTHORIZE_TRANSFER";
    case Operation_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Transaction {
  sourceAddress?: string | undefined;
  feeLimit?: number | undefined;
  gasPrice?: number | undefined;
  nonce?: string | undefined;
  metadata?: string | undefined;
  nonceType?: Transaction_TxType | undefined;
  maxLedgerSeq?: number | undefined;
  operations?: Operation[] | undefined;
}

export enum Transaction_TxType {
  INCREASE_NONCE = 0,
  RANDOM_NONCE = 1,
  UNRECOGNIZED = -1,
}

export function transaction_TxTypeFromJSON(object: any): Transaction_TxType {
  switch (object) {
    case 0:
    case "INCREASE_NONCE":
      return Transaction_TxType.INCREASE_NONCE;
    case 1:
    case "RANDOM_NONCE":
      return Transaction_TxType.RANDOM_NONCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Transaction_TxType.UNRECOGNIZED;
  }
}

export function transaction_TxTypeToJSON(object: Transaction_TxType): string {
  switch (object) {
    case Transaction_TxType.INCREASE_NONCE:
      return "INCREASE_NONCE";
    case Transaction_TxType.RANDOM_NONCE:
      return "RANDOM_NONCE";
    case Transaction_TxType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TransactionEnv {
  hash?: string | undefined;
  actualFee?: number | undefined;
  closeTime?: number | undefined;
  contractTxHashes?: string[] | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
  ledgerSeq?: number | undefined;
  signatures?: Signature[] | undefined;
  transaction?: Transaction | undefined;
  txSize?: number | undefined;
  blob?: string | undefined;
}

export interface GetTransactionHistoryResult {
  totalCount?: number | undefined;
  transactions?: TransactionEnv[] | undefined;
}

export interface GetTransactionHistoryResponse {
  trace?: string | undefined;
  result?: GetTransactionHistoryResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface TestTransaction {
  transactionJson?: Transaction | undefined;
  signatureNumber?: number | undefined;
}

export interface TestTransactionRequest {
  items?: TestTransaction[] | undefined;
}

export interface TestTransactionResult {
  stat?: TestTransactionResult_Stat | undefined;
  hash?: string | undefined;
  txs?: TestTransactionResult_TestTx[] | undefined;
}

export interface TestTransactionResult_Stat {
  applyTime?: number | undefined;
  memoryUsage?: number | undefined;
  stackUsage?: number | undefined;
  step?: number | undefined;
}

export interface TestTransactionResult_TransactionEnv {
  transaction?: Transaction | undefined;
}

export interface TestTransactionResult_TestTx {
  gas?: number | undefined;
  transactionEnv?: TestTransactionResult_TransactionEnv | undefined;
  actualFee?: number | undefined;
}

export interface TestTransactionResponse {
  trace?: string | undefined;
  result?: TestTransactionResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface CallContractRequest {
  contractAddress?: string | undefined;
  input?: string | undefined;
  feeLimit?: number | undefined;
  gasPrice?: number | undefined;
  sourceAddress?: string | undefined;
  optType?: number | undefined;
}

export interface CallContractResultSystem {
  queryRets?: QueryReturnSystem[] | undefined;
}

export interface QueryReturnSystem {
  error?: Error | undefined;
  result?: SystemContractResult | undefined;
}

export interface SystemContractResult {
  data?: string | undefined;
}

export interface CallContractResultJs {
  queryRets?: QueryReturnJs[] | undefined;
}

/** 查询返回消息 */
export interface QueryReturnJs {
  error?: Error | undefined;
  result?: JsContractResult | undefined;
}

export interface JsContractResult {
  /** "string" 或 "bool" */
  type?: string | undefined;
  value?: string | undefined;
}

export interface CallContractResultEvm {
  queryRets?: QueryReturnEvm[] | undefined;
}

export interface QueryReturnEvm {
  error?: Error | undefined;
  result?: EvmContractResult | undefined;
}

export interface EvmContractResult {
  code?: number | undefined;
  data?: string | undefined;
  desc?: string | undefined;
  eumcode?: string | undefined;
  gasused?: number | undefined;
}

/** 错误消息 */
export interface Error {
  data?: string | undefined;
}

export interface QueryReturn {
  error?: string | undefined;
  result?: string | undefined;
}

export interface CallContractResult {
  queryRets?: QueryReturn[] | undefined;
}

export interface CallContractResponse {
  trace?: string | undefined;
  result?: CallContractResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface QueryRequest {
  bid?: string | undefined;
  hash?: string | undefined;
  /** 增强交易字段，暂时保留 */
  txId?: string | undefined;
  startTime?: string | undefined;
  endTime?: string | undefined;
  txType?: QueryRequest_TxType | undefined;
  page?: number | undefined;
  pageSize?: number | undefined;
  ledgerSeq?: number | undefined;
}

export enum QueryRequest_TxType {
  BASE_TX = 0,
  ENHANCED_TX = 1,
  UNRECOGNIZED = -1,
}

export function queryRequest_TxTypeFromJSON(object: any): QueryRequest_TxType {
  switch (object) {
    case 0:
    case "BASE_TX":
      return QueryRequest_TxType.BASE_TX;
    case 1:
    case "ENHANCED_TX":
      return QueryRequest_TxType.ENHANCED_TX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QueryRequest_TxType.UNRECOGNIZED;
  }
}

export function queryRequest_TxTypeToJSON(object: QueryRequest_TxType): string {
  switch (object) {
    case QueryRequest_TxType.BASE_TX:
      return "BASE_TX";
    case QueryRequest_TxType.ENHANCED_TX:
      return "ENHANCED_TX";
    case QueryRequest_TxType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TransactionBase {
  id?: string | undefined;
  txId?: string | undefined;
  hash?: string | undefined;
  apiKey?: string | undefined;
  txType?: TransactionBase_TxType | undefined;
  createTime?: string | undefined;
  ledgerSeq?: number | undefined;
  sourceAddress?: string | undefined;
  actualFee?: number | undefined;
  status?: StatusCodes | undefined;
  statusDesc?: string | undefined;
  baseTransaction?: TransactionEnv | undefined;
}

export enum TransactionBase_NetworkType {
  /** UNKNOWN - 保留0作为未知或默认值 */
  UNKNOWN = 0,
  /** DOMESTIC_SPARK_EXPERIENCE - 国内星火体验网 */
  DOMESTIC_SPARK_EXPERIENCE = 1,
  /** DOMESTIC_SPARK_MAINNET - 国内星火主网 */
  DOMESTIC_SPARK_MAINNET = 2,
  /** INTERNATIONAL_SPARK_EXPERIENCE - 国际星火体验网 */
  INTERNATIONAL_SPARK_EXPERIENCE = 3,
  /** INTERNATIONAL_SPARK_MAINNET - 国际星火主网 */
  INTERNATIONAL_SPARK_MAINNET = 4,
  UNRECOGNIZED = -1,
}

export function transactionBase_NetworkTypeFromJSON(
  object: any,
): TransactionBase_NetworkType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return TransactionBase_NetworkType.UNKNOWN;
    case 1:
    case "DOMESTIC_SPARK_EXPERIENCE":
      return TransactionBase_NetworkType.DOMESTIC_SPARK_EXPERIENCE;
    case 2:
    case "DOMESTIC_SPARK_MAINNET":
      return TransactionBase_NetworkType.DOMESTIC_SPARK_MAINNET;
    case 3:
    case "INTERNATIONAL_SPARK_EXPERIENCE":
      return TransactionBase_NetworkType.INTERNATIONAL_SPARK_EXPERIENCE;
    case 4:
    case "INTERNATIONAL_SPARK_MAINNET":
      return TransactionBase_NetworkType.INTERNATIONAL_SPARK_MAINNET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionBase_NetworkType.UNRECOGNIZED;
  }
}

export function transactionBase_NetworkTypeToJSON(
  object: TransactionBase_NetworkType,
): string {
  switch (object) {
    case TransactionBase_NetworkType.UNKNOWN:
      return "UNKNOWN";
    case TransactionBase_NetworkType.DOMESTIC_SPARK_EXPERIENCE:
      return "DOMESTIC_SPARK_EXPERIENCE";
    case TransactionBase_NetworkType.DOMESTIC_SPARK_MAINNET:
      return "DOMESTIC_SPARK_MAINNET";
    case TransactionBase_NetworkType.INTERNATIONAL_SPARK_EXPERIENCE:
      return "INTERNATIONAL_SPARK_EXPERIENCE";
    case TransactionBase_NetworkType.INTERNATIONAL_SPARK_MAINNET:
      return "INTERNATIONAL_SPARK_MAINNET";
    case TransactionBase_NetworkType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransactionBase_TxType {
  BASE_TX = 0,
  ENHANCED_TX = 1,
  UNRECOGNIZED = -1,
}

export function transactionBase_TxTypeFromJSON(
  object: any,
): TransactionBase_TxType {
  switch (object) {
    case 0:
    case "BASE_TX":
      return TransactionBase_TxType.BASE_TX;
    case 1:
    case "ENHANCED_TX":
      return TransactionBase_TxType.ENHANCED_TX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionBase_TxType.UNRECOGNIZED;
  }
}

export function transactionBase_TxTypeToJSON(
  object: TransactionBase_TxType,
): string {
  switch (object) {
    case TransactionBase_TxType.BASE_TX:
      return "BASE_TX";
    case TransactionBase_TxType.ENHANCED_TX:
      return "ENHANCED_TX";
    case TransactionBase_TxType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface QueryResult {
  count?: number | undefined;
  totalPage?: number | undefined;
  transactionBases?: TransactionBase[] | undefined;
}

export interface QueryResponse {
  trace?: string | undefined;
  result?: QueryResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface GetTransactionCacheRequest {
  limit?: number | undefined;
  hash?: string | undefined;
  address?: string | undefined;
}

export enum GetTransactionCacheRequest_PoolType {
  PLATFORM = 0,
  CHAIN = 1,
  UNRECOGNIZED = -1,
}

export function getTransactionCacheRequest_PoolTypeFromJSON(
  object: any,
): GetTransactionCacheRequest_PoolType {
  switch (object) {
    case 0:
    case "PLATFORM":
      return GetTransactionCacheRequest_PoolType.PLATFORM;
    case 1:
    case "CHAIN":
      return GetTransactionCacheRequest_PoolType.CHAIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GetTransactionCacheRequest_PoolType.UNRECOGNIZED;
  }
}

export function getTransactionCacheRequest_PoolTypeToJSON(
  object: GetTransactionCacheRequest_PoolType,
): string {
  switch (object) {
    case GetTransactionCacheRequest_PoolType.PLATFORM:
      return "PLATFORM";
    case GetTransactionCacheRequest_PoolType.CHAIN:
      return "CHAIN";
    case GetTransactionCacheRequest_PoolType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PlatformTransaction {
  transactions?: TransactionBase | undefined;
}

export interface ChainTransaction {
  status?: string | undefined;
  incomingTime?: string | undefined;
  hash?: string | undefined;
  signatures?: Signature[] | undefined;
  transaction?: Transaction | undefined;
}

export interface GetTransactionCacheChainResult {
  totalCount?: number | undefined;
  transactions?: ChainTransaction[] | undefined;
}

export interface GetTransactionCachePlatResult {
  totalCount?: number | undefined;
  transactions?: TransactionEnv[] | undefined;
}

export interface GetTransactionCacheChainResponse {
  trace?: string | undefined;
  result?: GetTransactionCacheChainResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface GetTransactionCachePlatResponse {
  trace?: string | undefined;
  result?: GetTransactionCachePlatResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface DiscardRequest {
  hash?: string | undefined;
  page?: number | undefined;
  pageSize?: number | undefined;
}

export interface DiscardResult {
  count?: number | undefined;
  totalPage?: number | undefined;
  transactionBases?: TransactionBase[] | undefined;
}

export interface DiscardResponse {
  trace?: string | undefined;
  result?: DiscardResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

export interface GetTxCacheSizeResult {
  queueSize?: number | undefined;
}

export interface GetTxCacheSizeResponse {
  trace?: string | undefined;
  result?: GetTxCacheSizeResult | undefined;
  success?: boolean | undefined;
  errorCode?: StatusCodes | undefined;
  errorDesc?: string | undefined;
}

function createBaseBidStatus(): BidStatus {
  return { bid: "", status: "" };
}

export const BidStatus: MessageFns<BidStatus> = {
  encode(
    message: BidStatus,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.bid !== undefined && message.bid !== "") {
      writer.uint32(10).string(message.bid);
    }
    if (message.status !== undefined && message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BidStatus {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBidStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BidStatus {
    return {
      bid: isSet(object.bid) ? globalThis.String(object.bid) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: BidStatus): unknown {
    const obj: any = {};
    if (message.bid !== undefined && message.bid !== "") {
      obj.bid = message.bid;
    }
    if (message.status !== undefined && message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BidStatus>, I>>(base?: I): BidStatus {
    return BidStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BidStatus>, I>>(
    object: I,
  ): BidStatus {
    const message = createBaseBidStatus();
    message.bid = object.bid ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseApplyRequest(): ApplyRequest {
  return { data: [] };
}

export const ApplyRequest: MessageFns<ApplyRequest> = {
  encode(
    message: ApplyRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.data !== undefined && message.data.length !== 0) {
      for (const v of message.data) {
        BidStatus.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = BidStatus.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.data!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyRequest {
    return {
      data: globalThis.Array.isArray(object?.data)
        ? object.data.map((e: any) => BidStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ApplyRequest): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => BidStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplyRequest>, I>>(
    base?: I,
  ): ApplyRequest {
    return ApplyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyRequest>, I>>(
    object: I,
  ): ApplyRequest {
    const message = createBaseApplyRequest();
    message.data = object.data?.map((e) => BidStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseApplyResult(): ApplyResult {
  return { requestNo: "" };
}

export const ApplyResult: MessageFns<ApplyResult> = {
  encode(
    message: ApplyResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.requestNo !== undefined && message.requestNo !== "") {
      writer.uint32(10).string(message.requestNo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestNo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyResult {
    return {
      requestNo: isSet(object.requestNo)
        ? globalThis.String(object.requestNo)
        : "",
    };
  },

  toJSON(message: ApplyResult): unknown {
    const obj: any = {};
    if (message.requestNo !== undefined && message.requestNo !== "") {
      obj.requestNo = message.requestNo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplyResult>, I>>(base?: I): ApplyResult {
    return ApplyResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyResult>, I>>(
    object: I,
  ): ApplyResult {
    const message = createBaseApplyResult();
    message.requestNo = object.requestNo ?? "";
    return message;
  },
};

function createBaseApplyResponse(): ApplyResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const ApplyResponse: MessageFns<ApplyResponse> = {
  encode(
    message: ApplyResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      ApplyResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = ApplyResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? ApplyResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: ApplyResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = ApplyResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplyResponse>, I>>(
    base?: I,
  ): ApplyResponse {
    return ApplyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyResponse>, I>>(
    object: I,
  ): ApplyResponse {
    const message = createBaseApplyResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? ApplyResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseApplyStatusRequest(): ApplyStatusRequest {
  return { requestNo: "" };
}

export const ApplyStatusRequest: MessageFns<ApplyStatusRequest> = {
  encode(
    message: ApplyStatusRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.requestNo !== undefined && message.requestNo !== "") {
      writer.uint32(10).string(message.requestNo);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ApplyStatusRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestNo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyStatusRequest {
    return {
      requestNo: isSet(object.requestNo)
        ? globalThis.String(object.requestNo)
        : "",
    };
  },

  toJSON(message: ApplyStatusRequest): unknown {
    const obj: any = {};
    if (message.requestNo !== undefined && message.requestNo !== "") {
      obj.requestNo = message.requestNo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplyStatusRequest>, I>>(
    base?: I,
  ): ApplyStatusRequest {
    return ApplyStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyStatusRequest>, I>>(
    object: I,
  ): ApplyStatusRequest {
    const message = createBaseApplyStatusRequest();
    message.requestNo = object.requestNo ?? "";
    return message;
  },
};

function createBaseApplyStatusResult(): ApplyStatusResult {
  return { requestNo: "", status: "", txHash: "", errorDesc: "" };
}

export const ApplyStatusResult: MessageFns<ApplyStatusResult> = {
  encode(
    message: ApplyStatusResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.requestNo !== undefined && message.requestNo !== "") {
      writer.uint32(10).string(message.requestNo);
    }
    if (message.status !== undefined && message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.txHash !== undefined && message.txHash !== "") {
      writer.uint32(26).string(message.txHash);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(34).string(message.errorDesc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyStatusResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyStatusResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestNo = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyStatusResult {
    return {
      requestNo: isSet(object.requestNo)
        ? globalThis.String(object.requestNo)
        : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      errorDesc: isSet(object.errorDesc)
        ? globalThis.String(object.errorDesc)
        : "",
    };
  },

  toJSON(message: ApplyStatusResult): unknown {
    const obj: any = {};
    if (message.requestNo !== undefined && message.requestNo !== "") {
      obj.requestNo = message.requestNo;
    }
    if (message.status !== undefined && message.status !== "") {
      obj.status = message.status;
    }
    if (message.txHash !== undefined && message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.errorDesc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplyStatusResult>, I>>(
    base?: I,
  ): ApplyStatusResult {
    return ApplyStatusResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyStatusResult>, I>>(
    object: I,
  ): ApplyStatusResult {
    const message = createBaseApplyStatusResult();
    message.requestNo = object.requestNo ?? "";
    message.status = object.status ?? "";
    message.txHash = object.txHash ?? "";
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseApplyStatusResponse(): ApplyStatusResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const ApplyStatusResponse: MessageFns<ApplyStatusResponse> = {
  encode(
    message: ApplyStatusResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      ApplyStatusResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ApplyStatusResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = ApplyStatusResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyStatusResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? ApplyStatusResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: ApplyStatusResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = ApplyStatusResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplyStatusResponse>, I>>(
    base?: I,
  ): ApplyStatusResponse {
    return ApplyStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyStatusResponse>, I>>(
    object: I,
  ): ApplyStatusResponse {
    const message = createBaseApplyStatusResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? ApplyStatusResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseDetailRequest(): DetailRequest {
  return { requestNo: "" };
}

export const DetailRequest: MessageFns<DetailRequest> = {
  encode(
    message: DetailRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.requestNo !== undefined && message.requestNo !== "") {
      writer.uint32(10).string(message.requestNo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetailRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestNo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetailRequest {
    return {
      requestNo: isSet(object.requestNo)
        ? globalThis.String(object.requestNo)
        : "",
    };
  },

  toJSON(message: DetailRequest): unknown {
    const obj: any = {};
    if (message.requestNo !== undefined && message.requestNo !== "") {
      obj.requestNo = message.requestNo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DetailRequest>, I>>(
    base?: I,
  ): DetailRequest {
    return DetailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DetailRequest>, I>>(
    object: I,
  ): DetailRequest {
    const message = createBaseDetailRequest();
    message.requestNo = object.requestNo ?? "";
    return message;
  },
};

function createBaseDetailResult(): DetailResult {
  return { requestNo: "", txHash: "", bidList: "" };
}

export const DetailResult: MessageFns<DetailResult> = {
  encode(
    message: DetailResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.requestNo !== undefined && message.requestNo !== "") {
      writer.uint32(10).string(message.requestNo);
    }
    if (message.txHash !== undefined && message.txHash !== "") {
      writer.uint32(18).string(message.txHash);
    }
    if (message.bidList !== undefined && message.bidList !== "") {
      writer.uint32(26).string(message.bidList);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetailResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestNo = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bidList = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetailResult {
    return {
      requestNo: isSet(object.requestNo)
        ? globalThis.String(object.requestNo)
        : "",
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      bidList: isSet(object.bidList) ? globalThis.String(object.bidList) : "",
    };
  },

  toJSON(message: DetailResult): unknown {
    const obj: any = {};
    if (message.requestNo !== undefined && message.requestNo !== "") {
      obj.requestNo = message.requestNo;
    }
    if (message.txHash !== undefined && message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.bidList !== undefined && message.bidList !== "") {
      obj.bidList = message.bidList;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DetailResult>, I>>(
    base?: I,
  ): DetailResult {
    return DetailResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DetailResult>, I>>(
    object: I,
  ): DetailResult {
    const message = createBaseDetailResult();
    message.requestNo = object.requestNo ?? "";
    message.txHash = object.txHash ?? "";
    message.bidList = object.bidList ?? "";
    return message;
  },
};

function createBaseDetailResponse(): DetailResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const DetailResponse: MessageFns<DetailResponse> = {
  encode(
    message: DetailResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      DetailResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetailResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = DetailResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetailResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? DetailResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: DetailResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = DetailResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DetailResponse>, I>>(
    base?: I,
  ): DetailResponse {
    return DetailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DetailResponse>, I>>(
    object: I,
  ): DetailResponse {
    const message = createBaseDetailResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? DetailResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseHelloResult(): HelloResult {
  return {
    chainCode: "",
    licenseVersion: "",
    monitorVersion: "",
    overlayVersion: "",
    websocketPort: 0,
    addressPrefix: "",
    chainVersion: "",
    currentTime: "",
    hashType: "",
    ledgerVersion: "",
    networkId: "",
  };
}

export const HelloResult: MessageFns<HelloResult> = {
  encode(
    message: HelloResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.chainCode !== undefined && message.chainCode !== "") {
      writer.uint32(10).string(message.chainCode);
    }
    if (message.licenseVersion !== undefined && message.licenseVersion !== "") {
      writer.uint32(18).string(message.licenseVersion);
    }
    if (message.monitorVersion !== undefined && message.monitorVersion !== "") {
      writer.uint32(26).string(message.monitorVersion);
    }
    if (message.overlayVersion !== undefined && message.overlayVersion !== "") {
      writer.uint32(34).string(message.overlayVersion);
    }
    if (message.websocketPort !== undefined && message.websocketPort !== 0) {
      writer.uint32(40).int64(message.websocketPort);
    }
    if (message.addressPrefix !== undefined && message.addressPrefix !== "") {
      writer.uint32(50).string(message.addressPrefix);
    }
    if (message.chainVersion !== undefined && message.chainVersion !== "") {
      writer.uint32(58).string(message.chainVersion);
    }
    if (message.currentTime !== undefined && message.currentTime !== "") {
      writer.uint32(66).string(message.currentTime);
    }
    if (message.hashType !== undefined && message.hashType !== "") {
      writer.uint32(74).string(message.hashType);
    }
    if (message.ledgerVersion !== undefined && message.ledgerVersion !== "") {
      writer.uint32(82).string(message.ledgerVersion);
    }
    if (message.networkId !== undefined && message.networkId !== "") {
      writer.uint32(90).string(message.networkId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HelloResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHelloResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.licenseVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.monitorVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.overlayVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.websocketPort = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.addressPrefix = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.chainVersion = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currentTime = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.hashType = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.ledgerVersion = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.networkId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HelloResult {
    return {
      chainCode: isSet(object.chain_code)
        ? globalThis.String(object.chain_code)
        : "",
      licenseVersion: isSet(object.license_version)
        ? globalThis.String(object.license_version)
        : "",
      monitorVersion: isSet(object.monitor_version)
        ? globalThis.String(object.monitor_version)
        : "",
      overlayVersion: isSet(object.overlay_version)
        ? globalThis.String(object.overlay_version)
        : "",
      websocketPort: isSet(object.websocket_port)
        ? globalThis.Number(object.websocket_port)
        : 0,
      addressPrefix: isSet(object.address_prefix)
        ? globalThis.String(object.address_prefix)
        : "",
      chainVersion: isSet(object.chain_version)
        ? globalThis.String(object.chain_version)
        : "",
      currentTime: isSet(object.current_time)
        ? globalThis.String(object.current_time)
        : "",
      hashType: isSet(object.hash_type)
        ? globalThis.String(object.hash_type)
        : "",
      ledgerVersion: isSet(object.ledger_version)
        ? globalThis.String(object.ledger_version)
        : "",
      networkId: isSet(object.network_id)
        ? globalThis.String(object.network_id)
        : "",
    };
  },

  toJSON(message: HelloResult): unknown {
    const obj: any = {};
    if (message.chainCode !== undefined && message.chainCode !== "") {
      obj.chain_code = message.chainCode;
    }
    if (message.licenseVersion !== undefined && message.licenseVersion !== "") {
      obj.license_version = message.licenseVersion;
    }
    if (message.monitorVersion !== undefined && message.monitorVersion !== "") {
      obj.monitor_version = message.monitorVersion;
    }
    if (message.overlayVersion !== undefined && message.overlayVersion !== "") {
      obj.overlay_version = message.overlayVersion;
    }
    if (message.websocketPort !== undefined && message.websocketPort !== 0) {
      obj.websocket_port = Math.round(message.websocketPort);
    }
    if (message.addressPrefix !== undefined && message.addressPrefix !== "") {
      obj.address_prefix = message.addressPrefix;
    }
    if (message.chainVersion !== undefined && message.chainVersion !== "") {
      obj.chain_version = message.chainVersion;
    }
    if (message.currentTime !== undefined && message.currentTime !== "") {
      obj.current_time = message.currentTime;
    }
    if (message.hashType !== undefined && message.hashType !== "") {
      obj.hash_type = message.hashType;
    }
    if (message.ledgerVersion !== undefined && message.ledgerVersion !== "") {
      obj.ledger_version = message.ledgerVersion;
    }
    if (message.networkId !== undefined && message.networkId !== "") {
      obj.network_id = message.networkId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HelloResult>, I>>(base?: I): HelloResult {
    return HelloResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HelloResult>, I>>(
    object: I,
  ): HelloResult {
    const message = createBaseHelloResult();
    message.chainCode = object.chainCode ?? "";
    message.licenseVersion = object.licenseVersion ?? "";
    message.monitorVersion = object.monitorVersion ?? "";
    message.overlayVersion = object.overlayVersion ?? "";
    message.websocketPort = object.websocketPort ?? 0;
    message.addressPrefix = object.addressPrefix ?? "";
    message.chainVersion = object.chainVersion ?? "";
    message.currentTime = object.currentTime ?? "";
    message.hashType = object.hashType ?? "";
    message.ledgerVersion = object.ledgerVersion ?? "";
    message.networkId = object.networkId ?? "";
    return message;
  },
};

function createBaseHelloResponse(): HelloResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const HelloResponse: MessageFns<HelloResponse> = {
  encode(
    message: HelloResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      HelloResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HelloResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHelloResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = HelloResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HelloResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? HelloResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: HelloResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = HelloResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HelloResponse>, I>>(
    base?: I,
  ): HelloResponse {
    return HelloResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HelloResponse>, I>>(
    object: I,
  ): HelloResponse {
    const message = createBaseHelloResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? HelloResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseGetAccountRequest(): GetAccountRequest {
  return { address: "", height: 0, key: "" };
}

export const GetAccountRequest: MessageFns<GetAccountRequest> = {
  encode(
    message: GetAccountRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.address !== undefined && message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.height !== undefined && message.height !== 0) {
      writer.uint32(16).int64(message.height);
    }
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAccountRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccountRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: GetAccountRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined && message.address !== "") {
      obj.address = message.address;
    }
    if (message.height !== undefined && message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAccountRequest>, I>>(
    base?: I,
  ): GetAccountRequest {
    return GetAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAccountRequest>, I>>(
    object: I,
  ): GetAccountRequest {
    const message = createBaseGetAccountRequest();
    message.address = object.address ?? "";
    message.height = object.height ?? 0;
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseContract(): Contract {
  return { type: 0, payload: "" };
}

export const Contract: MessageFns<Contract> = {
  encode(
    message: Contract,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload !== undefined && message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Contract {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Contract {
    return {
      type: isSet(object.type) ? contract_ContractTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
    };
  },

  toJSON(message: Contract): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = contract_ContractTypeToJSON(message.type);
    }
    if (message.payload !== undefined && message.payload !== "") {
      obj.payload = message.payload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Contract>, I>>(base?: I): Contract {
    return Contract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Contract>, I>>(object: I): Contract {
    const message = createBaseContract();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? "";
    return message;
  },
};

function createBaseSigner(): Signer {
  return { address: "", weight: 0 };
}

export const Signer: MessageFns<Signer> = {
  encode(
    message: Signer,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.address !== undefined && message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.weight !== undefined && message.weight !== 0) {
      writer.uint32(16).int64(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signer {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.weight = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signer {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: Signer): unknown {
    const obj: any = {};
    if (message.address !== undefined && message.address !== "") {
      obj.address = message.address;
    }
    if (message.weight !== undefined && message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Signer>, I>>(base?: I): Signer {
    return Signer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Signer>, I>>(object: I): Signer {
    const message = createBaseSigner();
    message.address = object.address ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseAccountPrivilege(): AccountPrivilege {
  return { masterWeight: 0, signers: [], thresholds: undefined };
}

export const AccountPrivilege: MessageFns<AccountPrivilege> = {
  encode(
    message: AccountPrivilege,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.masterWeight !== undefined && message.masterWeight !== 0) {
      writer.uint32(8).int64(message.masterWeight);
    }
    if (message.signers !== undefined && message.signers.length !== 0) {
      for (const v of message.signers) {
        Signer.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.thresholds !== undefined) {
      AccountThreshold.encode(
        message.thresholds,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountPrivilege {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountPrivilege();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.masterWeight = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = Signer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signers!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.thresholds = AccountThreshold.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountPrivilege {
    return {
      masterWeight: isSet(object.master_weight)
        ? globalThis.Number(object.master_weight)
        : 0,
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => Signer.fromJSON(e))
        : [],
      thresholds: isSet(object.thresholds)
        ? AccountThreshold.fromJSON(object.thresholds)
        : undefined,
    };
  },

  toJSON(message: AccountPrivilege): unknown {
    const obj: any = {};
    if (message.masterWeight !== undefined && message.masterWeight !== 0) {
      obj.master_weight = Math.round(message.masterWeight);
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    if (message.thresholds !== undefined) {
      obj.thresholds = AccountThreshold.toJSON(message.thresholds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountPrivilege>, I>>(
    base?: I,
  ): AccountPrivilege {
    return AccountPrivilege.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountPrivilege>, I>>(
    object: I,
  ): AccountPrivilege {
    const message = createBaseAccountPrivilege();
    message.masterWeight = object.masterWeight ?? 0;
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    message.thresholds =
      object.thresholds !== undefined && object.thresholds !== null
        ? AccountThreshold.fromPartial(object.thresholds)
        : undefined;
    return message;
  },
};

function createBaseOperationTypeThreshold(): OperationTypeThreshold {
  return { type: 0, threshold: 0 };
}

export const OperationTypeThreshold: MessageFns<OperationTypeThreshold> = {
  encode(
    message: OperationTypeThreshold,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.threshold !== undefined && message.threshold !== 0) {
      writer.uint32(16).int64(message.threshold);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationTypeThreshold {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationTypeThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.threshold = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationTypeThreshold {
    return {
      type: isSet(object.type)
        ? operationTypeThreshold_TypeFromJSON(object.type)
        : 0,
      threshold: isSet(object.threshold)
        ? globalThis.Number(object.threshold)
        : 0,
    };
  },

  toJSON(message: OperationTypeThreshold): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = operationTypeThreshold_TypeToJSON(message.type);
    }
    if (message.threshold !== undefined && message.threshold !== 0) {
      obj.threshold = Math.round(message.threshold);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationTypeThreshold>, I>>(
    base?: I,
  ): OperationTypeThreshold {
    return OperationTypeThreshold.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationTypeThreshold>, I>>(
    object: I,
  ): OperationTypeThreshold {
    const message = createBaseOperationTypeThreshold();
    message.type = object.type ?? 0;
    message.threshold = object.threshold ?? 0;
    return message;
  },
};

function createBaseAccountThreshold(): AccountThreshold {
  return { txThreshold: 0, typeThresholds: [] };
}

export const AccountThreshold: MessageFns<AccountThreshold> = {
  encode(
    message: AccountThreshold,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.txThreshold !== undefined && message.txThreshold !== 0) {
      writer.uint32(8).int64(message.txThreshold);
    }
    if (
      message.typeThresholds !== undefined &&
      message.typeThresholds.length !== 0
    ) {
      for (const v of message.typeThresholds) {
        OperationTypeThreshold.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountThreshold {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txThreshold = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = OperationTypeThreshold.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.typeThresholds!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountThreshold {
    return {
      txThreshold: isSet(object.tx_threshold)
        ? globalThis.Number(object.tx_threshold)
        : 0,
      typeThresholds: globalThis.Array.isArray(object?.type_thresholds)
        ? object.type_thresholds.map((e: any) =>
            OperationTypeThreshold.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: AccountThreshold): unknown {
    const obj: any = {};
    if (message.txThreshold !== undefined && message.txThreshold !== 0) {
      obj.tx_threshold = Math.round(message.txThreshold);
    }
    if (message.typeThresholds?.length) {
      obj.type_thresholds = message.typeThresholds.map((e) =>
        OperationTypeThreshold.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountThreshold>, I>>(
    base?: I,
  ): AccountThreshold {
    return AccountThreshold.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountThreshold>, I>>(
    object: I,
  ): AccountThreshold {
    const message = createBaseAccountThreshold();
    message.txThreshold = object.txThreshold ?? 0;
    message.typeThresholds =
      object.typeThresholds?.map((e) =>
        OperationTypeThreshold.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseKeyPair(): KeyPair {
  return { key: "", value: "", version: 0 };
}

export const KeyPair: MessageFns<KeyPair> = {
  encode(
    message: KeyPair,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(24).int64(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyPair {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyPair {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: KeyPair): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyPair>, I>>(base?: I): KeyPair {
    return KeyPair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyPair>, I>>(object: I): KeyPair {
    const message = createBaseKeyPair();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseGetAccountResult(): GetAccountResult {
  return {
    address: "",
    balance: 0,
    nonce: 0,
    authTransfer: false,
    metadatasHash: "",
    contract: undefined,
    priv: undefined,
    metadatas: [],
  };
}

export const GetAccountResult: MessageFns<GetAccountResult> = {
  encode(
    message: GetAccountResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.address !== undefined && message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.balance !== undefined && message.balance !== 0) {
      writer.uint32(16).int64(message.balance);
    }
    if (message.nonce !== undefined && message.nonce !== 0) {
      writer.uint32(24).int64(message.nonce);
    }
    if (message.authTransfer !== undefined && message.authTransfer !== false) {
      writer.uint32(32).bool(message.authTransfer);
    }
    if (message.metadatasHash !== undefined && message.metadatasHash !== "") {
      writer.uint32(42).string(message.metadatasHash);
    }
    if (message.contract !== undefined) {
      Contract.encode(message.contract, writer.uint32(50).fork()).join();
    }
    if (message.priv !== undefined) {
      AccountPrivilege.encode(message.priv, writer.uint32(58).fork()).join();
    }
    if (message.metadatas !== undefined && message.metadatas.length !== 0) {
      for (const v of message.metadatas) {
        KeyPair.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAccountResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccountResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.balance = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.nonce = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.authTransfer = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadatasHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.contract = Contract.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.priv = AccountPrivilege.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const el = KeyPair.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.metadatas!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccountResult {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      authTransfer: isSet(object.auth_transfer)
        ? globalThis.Boolean(object.auth_transfer)
        : false,
      metadatasHash: isSet(object.metadatas_hash)
        ? globalThis.String(object.metadatas_hash)
        : "",
      contract: isSet(object.contract)
        ? Contract.fromJSON(object.contract)
        : undefined,
      priv: isSet(object.priv)
        ? AccountPrivilege.fromJSON(object.priv)
        : undefined,
      metadatas: globalThis.Array.isArray(object?.metadatas)
        ? object.metadatas.map((e: any) => KeyPair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAccountResult): unknown {
    const obj: any = {};
    if (message.address !== undefined && message.address !== "") {
      obj.address = message.address;
    }
    if (message.balance !== undefined && message.balance !== 0) {
      obj.balance = Math.round(message.balance);
    }
    if (message.nonce !== undefined && message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.authTransfer !== undefined && message.authTransfer !== false) {
      obj.auth_transfer = message.authTransfer;
    }
    if (message.metadatasHash !== undefined && message.metadatasHash !== "") {
      obj.metadatas_hash = message.metadatasHash;
    }
    if (message.contract !== undefined) {
      obj.contract = Contract.toJSON(message.contract);
    }
    if (message.priv !== undefined) {
      obj.priv = AccountPrivilege.toJSON(message.priv);
    }
    if (message.metadatas?.length) {
      obj.metadatas = message.metadatas.map((e) => KeyPair.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAccountResult>, I>>(
    base?: I,
  ): GetAccountResult {
    return GetAccountResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAccountResult>, I>>(
    object: I,
  ): GetAccountResult {
    const message = createBaseGetAccountResult();
    message.address = object.address ?? "";
    message.balance = object.balance ?? 0;
    message.nonce = object.nonce ?? 0;
    message.authTransfer = object.authTransfer ?? false;
    message.metadatasHash = object.metadatasHash ?? "";
    message.contract =
      object.contract !== undefined && object.contract !== null
        ? Contract.fromPartial(object.contract)
        : undefined;
    message.priv =
      object.priv !== undefined && object.priv !== null
        ? AccountPrivilege.fromPartial(object.priv)
        : undefined;
    message.metadatas =
      object.metadatas?.map((e) => KeyPair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAccountResponse(): GetAccountResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const GetAccountResponse: MessageFns<GetAccountResponse> = {
  encode(
    message: GetAccountResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      GetAccountResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAccountResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = GetAccountResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccountResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? GetAccountResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: GetAccountResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = GetAccountResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAccountResponse>, I>>(
    base?: I,
  ): GetAccountResponse {
    return GetAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAccountResponse>, I>>(
    object: I,
  ): GetAccountResponse {
    const message = createBaseGetAccountResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? GetAccountResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseGetAccountBaseRequest(): GetAccountBaseRequest {
  return { address: "" };
}

export const GetAccountBaseRequest: MessageFns<GetAccountBaseRequest> = {
  encode(
    message: GetAccountBaseRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.address !== undefined && message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAccountBaseRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccountBaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccountBaseRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: GetAccountBaseRequest): unknown {
    const obj: any = {};
    if (message.address !== undefined && message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAccountBaseRequest>, I>>(
    base?: I,
  ): GetAccountBaseRequest {
    return GetAccountBaseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAccountBaseRequest>, I>>(
    object: I,
  ): GetAccountBaseRequest {
    const message = createBaseGetAccountBaseRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseGetAccountBaseResponse(): GetAccountBaseResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const GetAccountBaseResponse: MessageFns<GetAccountBaseResponse> = {
  encode(
    message: GetAccountBaseResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      GetAccountResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetAccountBaseResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccountBaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = GetAccountResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccountBaseResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? GetAccountResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: GetAccountBaseResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = GetAccountResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAccountBaseResponse>, I>>(
    base?: I,
  ): GetAccountBaseResponse {
    return GetAccountBaseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAccountBaseResponse>, I>>(
    object: I,
  ): GetAccountBaseResponse {
    const message = createBaseGetAccountBaseResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? GetAccountResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseGetAccountMetadataRequest(): GetAccountMetadataRequest {
  return { address: "", key: "" };
}

export const GetAccountMetadataRequest: MessageFns<GetAccountMetadataRequest> =
  {
    encode(
      message: GetAccountMetadataRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.address !== undefined && message.address !== "") {
        writer.uint32(10).string(message.address);
      }
      if (message.key !== undefined && message.key !== "") {
        writer.uint32(18).string(message.key);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetAccountMetadataRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetAccountMetadataRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.address = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.key = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetAccountMetadataRequest {
      return {
        address: isSet(object.address) ? globalThis.String(object.address) : "",
        key: isSet(object.key) ? globalThis.String(object.key) : "",
      };
    },

    toJSON(message: GetAccountMetadataRequest): unknown {
      const obj: any = {};
      if (message.address !== undefined && message.address !== "") {
        obj.address = message.address;
      }
      if (message.key !== undefined && message.key !== "") {
        obj.key = message.key;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetAccountMetadataRequest>, I>>(
      base?: I,
    ): GetAccountMetadataRequest {
      return GetAccountMetadataRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetAccountMetadataRequest>, I>>(
      object: I,
    ): GetAccountMetadataRequest {
      const message = createBaseGetAccountMetadataRequest();
      message.address = object.address ?? "";
      message.key = object.key ?? "";
      return message;
    },
  };

function createBaseGetAccountMetadataResponse(): GetAccountMetadataResponse {
  return { trace: "", result: {}, success: false, errorCode: 0, errorDesc: "" };
}

export const GetAccountMetadataResponse: MessageFns<GetAccountMetadataResponse> =
  {
    encode(
      message: GetAccountMetadataResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.trace !== undefined && message.trace !== "") {
        writer.uint32(10).string(message.trace);
      }
      Object.entries(message.result || {}).forEach(([key, value]) => {
        GetAccountMetadataResponse_ResultEntry.encode(
          { key: key as any, value },
          writer.uint32(18).fork(),
        ).join();
      });
      if (message.success !== undefined && message.success !== false) {
        writer.uint32(24).bool(message.success);
      }
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(32).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(42).string(message.errorDesc);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetAccountMetadataResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetAccountMetadataResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.trace = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            const entry2 = GetAccountMetadataResponse_ResultEntry.decode(
              reader,
              reader.uint32(),
            );
            if (entry2.value !== undefined) {
              message.result![entry2.key] = entry2.value;
            }
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.success = reader.bool();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetAccountMetadataResponse {
      return {
        trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
        result: isObject(object.result)
          ? Object.entries(object.result).reduce<{ [key: string]: KeyPair }>(
              (acc, [key, value]) => {
                acc[key] = KeyPair.fromJSON(value);
                return acc;
              },
              {},
            )
          : {},
        success: isSet(object.success)
          ? globalThis.Boolean(object.success)
          : false,
        errorCode: isSet(object.error_code)
          ? statusCodesFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
      };
    },

    toJSON(message: GetAccountMetadataResponse): unknown {
      const obj: any = {};
      if (message.trace !== undefined && message.trace !== "") {
        obj.trace = message.trace;
      }
      if (message.result) {
        const entries = Object.entries(message.result);
        if (entries.length > 0) {
          obj.result = {};
          entries.forEach(([k, v]) => {
            obj.result[k] = KeyPair.toJSON(v);
          });
        }
      }
      if (message.success !== undefined && message.success !== false) {
        obj.success = message.success;
      }
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = statusCodesToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetAccountMetadataResponse>, I>>(
      base?: I,
    ): GetAccountMetadataResponse {
      return GetAccountMetadataResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetAccountMetadataResponse>, I>>(
      object: I,
    ): GetAccountMetadataResponse {
      const message = createBaseGetAccountMetadataResponse();
      message.trace = object.trace ?? "";
      message.result = Object.entries(object.result ?? {}).reduce<{
        [key: string]: KeyPair;
      }>((acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = KeyPair.fromPartial(value);
        }
        return acc;
      }, {});
      message.success = object.success ?? false;
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      return message;
    },
  };

function createBaseGetAccountMetadataResponse_ResultEntry(): GetAccountMetadataResponse_ResultEntry {
  return { key: "", value: undefined };
}

export const GetAccountMetadataResponse_ResultEntry: MessageFns<GetAccountMetadataResponse_ResultEntry> =
  {
    encode(
      message: GetAccountMetadataResponse_ResultEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        KeyPair.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetAccountMetadataResponse_ResultEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetAccountMetadataResponse_ResultEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = KeyPair.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetAccountMetadataResponse_ResultEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? KeyPair.fromJSON(object.value) : undefined,
      };
    },

    toJSON(message: GetAccountMetadataResponse_ResultEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = KeyPair.toJSON(message.value);
      }
      return obj;
    },

    create<
      I extends Exact<DeepPartial<GetAccountMetadataResponse_ResultEntry>, I>,
    >(base?: I): GetAccountMetadataResponse_ResultEntry {
      return GetAccountMetadataResponse_ResultEntry.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<GetAccountMetadataResponse_ResultEntry>, I>,
    >(object: I): GetAccountMetadataResponse_ResultEntry {
      const message = createBaseGetAccountMetadataResponse_ResultEntry();
      message.key = object.key ?? "";
      message.value =
        object.value !== undefined && object.value !== null
          ? KeyPair.fromPartial(object.value)
          : undefined;
      return message;
    },
  };

function createBaseGetLedgerRequest(): GetLedgerRequest {
  return { seq: 0, withValidator: false, withLeader: false };
}

export const GetLedgerRequest: MessageFns<GetLedgerRequest> = {
  encode(
    message: GetLedgerRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.seq !== undefined && message.seq !== 0) {
      writer.uint32(8).int64(message.seq);
    }
    if (
      message.withValidator !== undefined &&
      message.withValidator !== false
    ) {
      writer.uint32(16).bool(message.withValidator);
    }
    if (message.withLeader !== undefined && message.withLeader !== false) {
      writer.uint32(24).bool(message.withLeader);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLedgerRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLedgerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seq = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.withValidator = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.withLeader = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLedgerRequest {
    return {
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      withValidator: isSet(object.withValidator)
        ? globalThis.Boolean(object.withValidator)
        : false,
      withLeader: isSet(object.withLeader)
        ? globalThis.Boolean(object.withLeader)
        : false,
    };
  },

  toJSON(message: GetLedgerRequest): unknown {
    const obj: any = {};
    if (message.seq !== undefined && message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (
      message.withValidator !== undefined &&
      message.withValidator !== false
    ) {
      obj.withValidator = message.withValidator;
    }
    if (message.withLeader !== undefined && message.withLeader !== false) {
      obj.withLeader = message.withLeader;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLedgerRequest>, I>>(
    base?: I,
  ): GetLedgerRequest {
    return GetLedgerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLedgerRequest>, I>>(
    object: I,
  ): GetLedgerRequest {
    const message = createBaseGetLedgerRequest();
    message.seq = object.seq ?? 0;
    message.withValidator = object.withValidator ?? false;
    message.withLeader = object.withLeader ?? false;
    return message;
  },
};

function createBaseLedgerHeader(): LedgerHeader {
  return {
    seq: 0,
    hash: "",
    previousHash: "",
    accountTreeHash: "",
    closeTime: 0,
    consensusValueHash: "",
    version: 0,
    txCount: 0,
    validatorsHash: "",
    feesHash: "",
  };
}

export const LedgerHeader: MessageFns<LedgerHeader> = {
  encode(
    message: LedgerHeader,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.seq !== undefined && message.seq !== 0) {
      writer.uint32(8).int64(message.seq);
    }
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    if (message.previousHash !== undefined && message.previousHash !== "") {
      writer.uint32(26).string(message.previousHash);
    }
    if (
      message.accountTreeHash !== undefined &&
      message.accountTreeHash !== ""
    ) {
      writer.uint32(34).string(message.accountTreeHash);
    }
    if (message.closeTime !== undefined && message.closeTime !== 0) {
      writer.uint32(40).int64(message.closeTime);
    }
    if (
      message.consensusValueHash !== undefined &&
      message.consensusValueHash !== ""
    ) {
      writer.uint32(50).string(message.consensusValueHash);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(56).int64(message.version);
    }
    if (message.txCount !== undefined && message.txCount !== 0) {
      writer.uint32(64).int64(message.txCount);
    }
    if (message.validatorsHash !== undefined && message.validatorsHash !== "") {
      writer.uint32(74).string(message.validatorsHash);
    }
    if (message.feesHash !== undefined && message.feesHash !== "") {
      writer.uint32(82).string(message.feesHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LedgerHeader {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seq = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.previousHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accountTreeHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.closeTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.consensusValueHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.txCount = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.validatorsHash = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.feesHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerHeader {
    return {
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      previousHash: isSet(object.previous_hash)
        ? globalThis.String(object.previous_hash)
        : "",
      accountTreeHash: isSet(object.account_tree_hash)
        ? globalThis.String(object.account_tree_hash)
        : "",
      closeTime: isSet(object.close_time)
        ? globalThis.Number(object.close_time)
        : 0,
      consensusValueHash: isSet(object.consensus_value_hash)
        ? globalThis.String(object.consensus_value_hash)
        : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      txCount: isSet(object.tx_count) ? globalThis.Number(object.tx_count) : 0,
      validatorsHash: isSet(object.validators_hash)
        ? globalThis.String(object.validators_hash)
        : "",
      feesHash: isSet(object.fees_hash)
        ? globalThis.String(object.fees_hash)
        : "",
    };
  },

  toJSON(message: LedgerHeader): unknown {
    const obj: any = {};
    if (message.seq !== undefined && message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.previousHash !== undefined && message.previousHash !== "") {
      obj.previous_hash = message.previousHash;
    }
    if (
      message.accountTreeHash !== undefined &&
      message.accountTreeHash !== ""
    ) {
      obj.account_tree_hash = message.accountTreeHash;
    }
    if (message.closeTime !== undefined && message.closeTime !== 0) {
      obj.close_time = Math.round(message.closeTime);
    }
    if (
      message.consensusValueHash !== undefined &&
      message.consensusValueHash !== ""
    ) {
      obj.consensus_value_hash = message.consensusValueHash;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.txCount !== undefined && message.txCount !== 0) {
      obj.tx_count = Math.round(message.txCount);
    }
    if (message.validatorsHash !== undefined && message.validatorsHash !== "") {
      obj.validators_hash = message.validatorsHash;
    }
    if (message.feesHash !== undefined && message.feesHash !== "") {
      obj.fees_hash = message.feesHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LedgerHeader>, I>>(
    base?: I,
  ): LedgerHeader {
    return LedgerHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LedgerHeader>, I>>(
    object: I,
  ): LedgerHeader {
    const message = createBaseLedgerHeader();
    message.seq = object.seq ?? 0;
    message.hash = object.hash ?? "";
    message.previousHash = object.previousHash ?? "";
    message.accountTreeHash = object.accountTreeHash ?? "";
    message.closeTime = object.closeTime ?? 0;
    message.consensusValueHash = object.consensusValueHash ?? "";
    message.version = object.version ?? 0;
    message.txCount = object.txCount ?? 0;
    message.validatorsHash = object.validatorsHash ?? "";
    message.feesHash = object.feesHash ?? "";
    return message;
  },
};

function createBaseGetLedgerResult(): GetLedgerResult {
  return { leader: "", validators: [], header: undefined, ledgerLength: 0 };
}

export const GetLedgerResult: MessageFns<GetLedgerResult> = {
  encode(
    message: GetLedgerResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.leader !== undefined && message.leader !== "") {
      writer.uint32(10).string(message.leader);
    }
    if (message.validators !== undefined && message.validators.length !== 0) {
      for (const v of message.validators) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.header !== undefined) {
      LedgerHeader.encode(message.header, writer.uint32(26).fork()).join();
    }
    if (message.ledgerLength !== undefined && message.ledgerLength !== 0) {
      writer.uint32(32).int64(message.ledgerLength);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLedgerResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLedgerResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leader = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.validators!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.header = LedgerHeader.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ledgerLength = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLedgerResult {
    return {
      leader: isSet(object.leader) ? globalThis.String(object.leader) : "",
      validators: globalThis.Array.isArray(object?.validators)
        ? object.validators.map((e: any) => globalThis.String(e))
        : [],
      header: isSet(object.header)
        ? LedgerHeader.fromJSON(object.header)
        : undefined,
      ledgerLength: isSet(object.ledger_length)
        ? globalThis.Number(object.ledger_length)
        : 0,
    };
  },

  toJSON(message: GetLedgerResult): unknown {
    const obj: any = {};
    if (message.leader !== undefined && message.leader !== "") {
      obj.leader = message.leader;
    }
    if (message.validators?.length) {
      obj.validators = message.validators;
    }
    if (message.header !== undefined) {
      obj.header = LedgerHeader.toJSON(message.header);
    }
    if (message.ledgerLength !== undefined && message.ledgerLength !== 0) {
      obj.ledger_length = Math.round(message.ledgerLength);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLedgerResult>, I>>(
    base?: I,
  ): GetLedgerResult {
    return GetLedgerResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLedgerResult>, I>>(
    object: I,
  ): GetLedgerResult {
    const message = createBaseGetLedgerResult();
    message.leader = object.leader ?? "";
    message.validators = object.validators?.map((e) => e) || [];
    message.header =
      object.header !== undefined && object.header !== null
        ? LedgerHeader.fromPartial(object.header)
        : undefined;
    message.ledgerLength = object.ledgerLength ?? 0;
    return message;
  },
};

function createBaseGetLedgerResponse(): GetLedgerResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const GetLedgerResponse: MessageFns<GetLedgerResponse> = {
  encode(
    message: GetLedgerResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      GetLedgerResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLedgerResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLedgerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = GetLedgerResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLedgerResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? GetLedgerResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: GetLedgerResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = GetLedgerResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLedgerResponse>, I>>(
    base?: I,
  ): GetLedgerResponse {
    return GetLedgerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLedgerResponse>, I>>(
    object: I,
  ): GetLedgerResponse {
    const message = createBaseGetLedgerResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? GetLedgerResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseSignature(): Signature {
  return { publicKey: "", signData: "" };
}

export const Signature: MessageFns<Signature> = {
  encode(
    message: Signature,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.publicKey !== undefined && message.publicKey !== "") {
      writer.uint32(10).string(message.publicKey);
    }
    if (message.signData !== undefined && message.signData !== "") {
      writer.uint32(18).string(message.signData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Signature {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Signature {
    return {
      publicKey: isSet(object.public_key)
        ? globalThis.String(object.public_key)
        : "",
      signData: isSet(object.sign_data)
        ? globalThis.String(object.sign_data)
        : "",
    };
  },

  toJSON(message: Signature): unknown {
    const obj: any = {};
    if (message.publicKey !== undefined && message.publicKey !== "") {
      obj.public_key = message.publicKey;
    }
    if (message.signData !== undefined && message.signData !== "") {
      obj.sign_data = message.signData;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Signature>, I>>(base?: I): Signature {
    return Signature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Signature>, I>>(
    object: I,
  ): Signature {
    const message = createBaseSignature();
    message.publicKey = object.publicKey ?? "";
    message.signData = object.signData ?? "";
    return message;
  },
};

function createBaseTxBlob(): TxBlob {
  return { transactionBlob: "", signatures: [] };
}

export const TxBlob: MessageFns<TxBlob> = {
  encode(
    message: TxBlob,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (
      message.transactionBlob !== undefined &&
      message.transactionBlob !== ""
    ) {
      writer.uint32(10).string(message.transactionBlob);
    }
    if (message.signatures !== undefined && message.signatures.length !== 0) {
      for (const v of message.signatures) {
        Signature.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TxBlob {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTxBlob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionBlob = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = Signature.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signatures!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TxBlob {
    return {
      transactionBlob: isSet(object.transaction_blob)
        ? globalThis.String(object.transaction_blob)
        : "",
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => Signature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TxBlob): unknown {
    const obj: any = {};
    if (
      message.transactionBlob !== undefined &&
      message.transactionBlob !== ""
    ) {
      obj.transaction_blob = message.transactionBlob;
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => Signature.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TxBlob>, I>>(base?: I): TxBlob {
    return TxBlob.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TxBlob>, I>>(object: I): TxBlob {
    const message = createBaseTxBlob();
    message.transactionBlob = object.transactionBlob ?? "";
    message.signatures =
      object.signatures?.map((e) => Signature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubmitTransactionRequest(): SubmitTransactionRequest {
  return { items: [] };
}

export const SubmitTransactionRequest: MessageFns<SubmitTransactionRequest> = {
  encode(
    message: SubmitTransactionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.items !== undefined && message.items.length !== 0) {
      for (const v of message.items) {
        TxBlob.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SubmitTransactionRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = TxBlob.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.items!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTransactionRequest {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => TxBlob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubmitTransactionRequest): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => TxBlob.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTransactionRequest>, I>>(
    base?: I,
  ): SubmitTransactionRequest {
    return SubmitTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTransactionRequest>, I>>(
    object: I,
  ): SubmitTransactionRequest {
    const message = createBaseSubmitTransactionRequest();
    message.items = object.items?.map((e) => TxBlob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubmitTransactionResult(): SubmitTransactionResult {
  return { hash: "", errorCode: 0, errorDesc: "" };
}

export const SubmitTransactionResult: MessageFns<SubmitTransactionResult> = {
  encode(
    message: SubmitTransactionResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SubmitTransactionResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTransactionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTransactionResult {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: SubmitTransactionResult): unknown {
    const obj: any = {};
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTransactionResult>, I>>(
    base?: I,
  ): SubmitTransactionResult {
    return SubmitTransactionResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTransactionResult>, I>>(
    object: I,
  ): SubmitTransactionResult {
    const message = createBaseSubmitTransactionResult();
    message.hash = object.hash ?? "";
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseSubmitTransactionResponse(): SubmitTransactionResponse {
  return { results: [], successCount: 0 };
}

export const SubmitTransactionResponse: MessageFns<SubmitTransactionResponse> =
  {
    encode(
      message: SubmitTransactionResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.results !== undefined && message.results.length !== 0) {
        for (const v of message.results) {
          SubmitTransactionResult.encode(v!, writer.uint32(10).fork()).join();
        }
      }
      if (message.successCount !== undefined && message.successCount !== 0) {
        writer.uint32(16).int64(message.successCount);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SubmitTransactionResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSubmitTransactionResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            const el = SubmitTransactionResult.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.results!.push(el);
            }
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.successCount = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SubmitTransactionResponse {
      return {
        results: globalThis.Array.isArray(object?.results)
          ? object.results.map((e: any) => SubmitTransactionResult.fromJSON(e))
          : [],
        successCount: isSet(object.success_count)
          ? globalThis.Number(object.success_count)
          : 0,
      };
    },

    toJSON(message: SubmitTransactionResponse): unknown {
      const obj: any = {};
      if (message.results?.length) {
        obj.results = message.results.map((e) =>
          SubmitTransactionResult.toJSON(e),
        );
      }
      if (message.successCount !== undefined && message.successCount !== 0) {
        obj.success_count = Math.round(message.successCount);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<SubmitTransactionResponse>, I>>(
      base?: I,
    ): SubmitTransactionResponse {
      return SubmitTransactionResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<SubmitTransactionResponse>, I>>(
      object: I,
    ): SubmitTransactionResponse {
      const message = createBaseSubmitTransactionResponse();
      message.results =
        object.results?.map((e) => SubmitTransactionResult.fromPartial(e)) ||
        [];
      message.successCount = object.successCount ?? 0;
      return message;
    },
  };

function createBaseGetTransactionHistoryRequest(): GetTransactionHistoryRequest {
  return { hash: "", ledgerSeq: 0, start: 0, limit: 0 };
}

export const GetTransactionHistoryRequest: MessageFns<GetTransactionHistoryRequest> =
  {
    encode(
      message: GetTransactionHistoryRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.hash !== undefined && message.hash !== "") {
        writer.uint32(10).string(message.hash);
      }
      if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
        writer.uint32(16).int64(message.ledgerSeq);
      }
      if (message.start !== undefined && message.start !== 0) {
        writer.uint32(24).int64(message.start);
      }
      if (message.limit !== undefined && message.limit !== 0) {
        writer.uint32(32).int64(message.limit);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetTransactionHistoryRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetTransactionHistoryRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.hash = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.ledgerSeq = longToNumber(reader.int64());
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.start = longToNumber(reader.int64());
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.limit = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetTransactionHistoryRequest {
      return {
        hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
        ledgerSeq: isSet(object.ledgerSeq)
          ? globalThis.Number(object.ledgerSeq)
          : 0,
        start: isSet(object.start) ? globalThis.Number(object.start) : 0,
        limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      };
    },

    toJSON(message: GetTransactionHistoryRequest): unknown {
      const obj: any = {};
      if (message.hash !== undefined && message.hash !== "") {
        obj.hash = message.hash;
      }
      if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
        obj.ledgerSeq = Math.round(message.ledgerSeq);
      }
      if (message.start !== undefined && message.start !== 0) {
        obj.start = Math.round(message.start);
      }
      if (message.limit !== undefined && message.limit !== 0) {
        obj.limit = Math.round(message.limit);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetTransactionHistoryRequest>, I>>(
      base?: I,
    ): GetTransactionHistoryRequest {
      return GetTransactionHistoryRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetTransactionHistoryRequest>, I>>(
      object: I,
    ): GetTransactionHistoryRequest {
      const message = createBaseGetTransactionHistoryRequest();
      message.hash = object.hash ?? "";
      message.ledgerSeq = object.ledgerSeq ?? 0;
      message.start = object.start ?? 0;
      message.limit = object.limit ?? 0;
      return message;
    },
  };

function createBaseOperationCreateAccount(): OperationCreateAccount {
  return {
    destAddress: "",
    contract: undefined,
    priv: undefined,
    metadatas: [],
    initBalance: 0,
    initInput: "",
  };
}

export const OperationCreateAccount: MessageFns<OperationCreateAccount> = {
  encode(
    message: OperationCreateAccount,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.destAddress !== undefined && message.destAddress !== "") {
      writer.uint32(10).string(message.destAddress);
    }
    if (message.contract !== undefined) {
      Contract.encode(message.contract, writer.uint32(18).fork()).join();
    }
    if (message.priv !== undefined) {
      AccountPrivilege.encode(message.priv, writer.uint32(26).fork()).join();
    }
    if (message.metadatas !== undefined && message.metadatas.length !== 0) {
      for (const v of message.metadatas) {
        KeyPair.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.initBalance !== undefined && message.initBalance !== 0) {
      writer.uint32(40).int64(message.initBalance);
    }
    if (message.initInput !== undefined && message.initInput !== "") {
      writer.uint32(50).string(message.initInput);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationCreateAccount {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationCreateAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contract = Contract.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.priv = AccountPrivilege.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = KeyPair.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.metadatas!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.initBalance = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.initInput = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationCreateAccount {
    return {
      destAddress: isSet(object.dest_address)
        ? globalThis.String(object.dest_address)
        : "",
      contract: isSet(object.contract)
        ? Contract.fromJSON(object.contract)
        : undefined,
      priv: isSet(object.priv)
        ? AccountPrivilege.fromJSON(object.priv)
        : undefined,
      metadatas: globalThis.Array.isArray(object?.metadatas)
        ? object.metadatas.map((e: any) => KeyPair.fromJSON(e))
        : [],
      initBalance: isSet(object.init_balance)
        ? globalThis.Number(object.init_balance)
        : 0,
      initInput: isSet(object.init_input)
        ? globalThis.String(object.init_input)
        : "",
    };
  },

  toJSON(message: OperationCreateAccount): unknown {
    const obj: any = {};
    if (message.destAddress !== undefined && message.destAddress !== "") {
      obj.dest_address = message.destAddress;
    }
    if (message.contract !== undefined) {
      obj.contract = Contract.toJSON(message.contract);
    }
    if (message.priv !== undefined) {
      obj.priv = AccountPrivilege.toJSON(message.priv);
    }
    if (message.metadatas?.length) {
      obj.metadatas = message.metadatas.map((e) => KeyPair.toJSON(e));
    }
    if (message.initBalance !== undefined && message.initBalance !== 0) {
      obj.init_balance = Math.round(message.initBalance);
    }
    if (message.initInput !== undefined && message.initInput !== "") {
      obj.init_input = message.initInput;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationCreateAccount>, I>>(
    base?: I,
  ): OperationCreateAccount {
    return OperationCreateAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationCreateAccount>, I>>(
    object: I,
  ): OperationCreateAccount {
    const message = createBaseOperationCreateAccount();
    message.destAddress = object.destAddress ?? "";
    message.contract =
      object.contract !== undefined && object.contract !== null
        ? Contract.fromPartial(object.contract)
        : undefined;
    message.priv =
      object.priv !== undefined && object.priv !== null
        ? AccountPrivilege.fromPartial(object.priv)
        : undefined;
    message.metadatas =
      object.metadatas?.map((e) => KeyPair.fromPartial(e)) || [];
    message.initBalance = object.initBalance ?? 0;
    message.initInput = object.initInput ?? "";
    return message;
  },
};

function createBaseOperationPayCoin(): OperationPayCoin {
  return { destAddress: "", amount: 0, input: "" };
}

export const OperationPayCoin: MessageFns<OperationPayCoin> = {
  encode(
    message: OperationPayCoin,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.destAddress !== undefined && message.destAddress !== "") {
      writer.uint32(10).string(message.destAddress);
    }
    if (message.amount !== undefined && message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    if (message.input !== undefined && message.input !== "") {
      writer.uint32(26).string(message.input);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationPayCoin {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationPayCoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.input = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationPayCoin {
    return {
      destAddress: isSet(object.dest_address)
        ? globalThis.String(object.dest_address)
        : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      input: isSet(object.input) ? globalThis.String(object.input) : "",
    };
  },

  toJSON(message: OperationPayCoin): unknown {
    const obj: any = {};
    if (message.destAddress !== undefined && message.destAddress !== "") {
      obj.dest_address = message.destAddress;
    }
    if (message.amount !== undefined && message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.input !== undefined && message.input !== "") {
      obj.input = message.input;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationPayCoin>, I>>(
    base?: I,
  ): OperationPayCoin {
    return OperationPayCoin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationPayCoin>, I>>(
    object: I,
  ): OperationPayCoin {
    const message = createBaseOperationPayCoin();
    message.destAddress = object.destAddress ?? "";
    message.amount = object.amount ?? 0;
    message.input = object.input ?? "";
    return message;
  },
};

function createBaseOperationSetMetadata(): OperationSetMetadata {
  return { key: "", value: "", version: 0, deleteFlag: false };
}

export const OperationSetMetadata: MessageFns<OperationSetMetadata> = {
  encode(
    message: OperationSetMetadata,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== undefined && message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.version !== undefined && message.version !== 0) {
      writer.uint32(24).int64(message.version);
    }
    if (message.deleteFlag !== undefined && message.deleteFlag !== false) {
      writer.uint32(32).bool(message.deleteFlag);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationSetMetadata {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationSetMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deleteFlag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationSetMetadata {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      deleteFlag: isSet(object.delete_flag)
        ? globalThis.Boolean(object.delete_flag)
        : false,
    };
  },

  toJSON(message: OperationSetMetadata): unknown {
    const obj: any = {};
    if (message.key !== undefined && message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    if (message.version !== undefined && message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.deleteFlag !== undefined && message.deleteFlag !== false) {
      obj.delete_flag = message.deleteFlag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationSetMetadata>, I>>(
    base?: I,
  ): OperationSetMetadata {
    return OperationSetMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationSetMetadata>, I>>(
    object: I,
  ): OperationSetMetadata {
    const message = createBaseOperationSetMetadata();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.version = object.version ?? 0;
    message.deleteFlag = object.deleteFlag ?? false;
    return message;
  },
};

function createBaseOperationUpgradeContract(): OperationUpgradeContract {
  return { destAddress: "", payload: "", type: 0 };
}

export const OperationUpgradeContract: MessageFns<OperationUpgradeContract> = {
  encode(
    message: OperationUpgradeContract,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.destAddress !== undefined && message.destAddress !== "") {
      writer.uint32(10).string(message.destAddress);
    }
    if (message.payload !== undefined && message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(24).int64(message.type);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationUpgradeContract {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationUpgradeContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.destAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationUpgradeContract {
    return {
      destAddress: isSet(object.dest_address)
        ? globalThis.String(object.dest_address)
        : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
    };
  },

  toJSON(message: OperationUpgradeContract): unknown {
    const obj: any = {};
    if (message.destAddress !== undefined && message.destAddress !== "") {
      obj.dest_address = message.destAddress;
    }
    if (message.payload !== undefined && message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationUpgradeContract>, I>>(
    base?: I,
  ): OperationUpgradeContract {
    return OperationUpgradeContract.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationUpgradeContract>, I>>(
    object: I,
  ): OperationUpgradeContract {
    const message = createBaseOperationUpgradeContract();
    message.destAddress = object.destAddress ?? "";
    message.payload = object.payload ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseOperationSetSignerWeight(): OperationSetSignerWeight {
  return { masterWeight: 0, signers: [] };
}

export const OperationSetSignerWeight: MessageFns<OperationSetSignerWeight> = {
  encode(
    message: OperationSetSignerWeight,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.masterWeight !== undefined && message.masterWeight !== 0) {
      writer.uint32(8).int64(message.masterWeight);
    }
    if (message.signers !== undefined && message.signers.length !== 0) {
      for (const v of message.signers) {
        Signer.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationSetSignerWeight {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationSetSignerWeight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.masterWeight = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = Signer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signers!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationSetSignerWeight {
    return {
      masterWeight: isSet(object.master_weight)
        ? globalThis.Number(object.master_weight)
        : 0,
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => Signer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OperationSetSignerWeight): unknown {
    const obj: any = {};
    if (message.masterWeight !== undefined && message.masterWeight !== 0) {
      obj.master_weight = Math.round(message.masterWeight);
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationSetSignerWeight>, I>>(
    base?: I,
  ): OperationSetSignerWeight {
    return OperationSetSignerWeight.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationSetSignerWeight>, I>>(
    object: I,
  ): OperationSetSignerWeight {
    const message = createBaseOperationSetSignerWeight();
    message.masterWeight = object.masterWeight ?? 0;
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperationSetThreshold(): OperationSetThreshold {
  return { txThreshold: 0, typeThresholds: [] };
}

export const OperationSetThreshold: MessageFns<OperationSetThreshold> = {
  encode(
    message: OperationSetThreshold,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.txThreshold !== undefined && message.txThreshold !== 0) {
      writer.uint32(8).int64(message.txThreshold);
    }
    if (
      message.typeThresholds !== undefined &&
      message.typeThresholds.length !== 0
    ) {
      for (const v of message.typeThresholds) {
        OperationTypeThreshold.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationSetThreshold {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationSetThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.txThreshold = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = OperationTypeThreshold.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.typeThresholds!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationSetThreshold {
    return {
      txThreshold: isSet(object.tx_threshold)
        ? globalThis.Number(object.tx_threshold)
        : 0,
      typeThresholds: globalThis.Array.isArray(object?.typeThresholds)
        ? object.typeThresholds.map((e: any) =>
            OperationTypeThreshold.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: OperationSetThreshold): unknown {
    const obj: any = {};
    if (message.txThreshold !== undefined && message.txThreshold !== 0) {
      obj.tx_threshold = Math.round(message.txThreshold);
    }
    if (message.typeThresholds?.length) {
      obj.typeThresholds = message.typeThresholds.map((e) =>
        OperationTypeThreshold.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationSetThreshold>, I>>(
    base?: I,
  ): OperationSetThreshold {
    return OperationSetThreshold.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationSetThreshold>, I>>(
    object: I,
  ): OperationSetThreshold {
    const message = createBaseOperationSetThreshold();
    message.txThreshold = object.txThreshold ?? 0;
    message.typeThresholds =
      object.typeThresholds?.map((e) =>
        OperationTypeThreshold.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseOperationLog(): OperationLog {
  return { topic: "", datas: [], topics: [] };
}

export const OperationLog: MessageFns<OperationLog> = {
  encode(
    message: OperationLog,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.topic !== undefined && message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.datas !== undefined && message.datas.length !== 0) {
      for (const v of message.datas) {
        writer.uint32(18).string(v!);
      }
    }
    if (message.topics !== undefined && message.topics.length !== 0) {
      for (const v of message.topics) {
        writer.uint32(26).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationLog {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.datas!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.topics!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationLog {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      datas: globalThis.Array.isArray(object?.datas)
        ? object.datas.map((e: any) => globalThis.String(e))
        : [],
      topics: globalThis.Array.isArray(object?.topics)
        ? object.topics.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OperationLog): unknown {
    const obj: any = {};
    if (message.topic !== undefined && message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.datas?.length) {
      obj.datas = message.datas;
    }
    if (message.topics?.length) {
      obj.topics = message.topics;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationLog>, I>>(
    base?: I,
  ): OperationLog {
    return OperationLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationLog>, I>>(
    object: I,
  ): OperationLog {
    const message = createBaseOperationLog();
    message.topic = object.topic ?? "";
    message.datas = object.datas?.map((e) => e) || [];
    message.topics = object.topics?.map((e) => e) || [];
    return message;
  },
};

function createBaseOperationSetPrivilege(): OperationSetPrivilege {
  return { masterWeight: "", signers: [], txThreshold: "", typeThresholds: [] };
}

export const OperationSetPrivilege: MessageFns<OperationSetPrivilege> = {
  encode(
    message: OperationSetPrivilege,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.masterWeight !== undefined && message.masterWeight !== "") {
      writer.uint32(10).string(message.masterWeight);
    }
    if (message.signers !== undefined && message.signers.length !== 0) {
      for (const v of message.signers) {
        Signer.encode(v!, writer.uint32(18).fork()).join();
      }
    }
    if (message.txThreshold !== undefined && message.txThreshold !== "") {
      writer.uint32(26).string(message.txThreshold);
    }
    if (
      message.typeThresholds !== undefined &&
      message.typeThresholds.length !== 0
    ) {
      for (const v of message.typeThresholds) {
        OperationTypeThreshold.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OperationSetPrivilege {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationSetPrivilege();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.masterWeight = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const el = Signer.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signers!.push(el);
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.txThreshold = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = OperationTypeThreshold.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.typeThresholds!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationSetPrivilege {
    return {
      masterWeight: isSet(object.master_weight)
        ? globalThis.String(object.master_weight)
        : "",
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => Signer.fromJSON(e))
        : [],
      txThreshold: isSet(object.tx_threshold)
        ? globalThis.String(object.tx_threshold)
        : "",
      typeThresholds: globalThis.Array.isArray(object?.typeThresholds)
        ? object.typeThresholds.map((e: any) =>
            OperationTypeThreshold.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: OperationSetPrivilege): unknown {
    const obj: any = {};
    if (message.masterWeight !== undefined && message.masterWeight !== "") {
      obj.master_weight = message.masterWeight;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Signer.toJSON(e));
    }
    if (message.txThreshold !== undefined && message.txThreshold !== "") {
      obj.tx_threshold = message.txThreshold;
    }
    if (message.typeThresholds?.length) {
      obj.typeThresholds = message.typeThresholds.map((e) =>
        OperationTypeThreshold.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OperationSetPrivilege>, I>>(
    base?: I,
  ): OperationSetPrivilege {
    return OperationSetPrivilege.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OperationSetPrivilege>, I>>(
    object: I,
  ): OperationSetPrivilege {
    const message = createBaseOperationSetPrivilege();
    message.masterWeight = object.masterWeight ?? "";
    message.signers = object.signers?.map((e) => Signer.fromPartial(e)) || [];
    message.txThreshold = object.txThreshold ?? "";
    message.typeThresholds =
      object.typeThresholds?.map((e) =>
        OperationTypeThreshold.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseControlledArea(): ControlledArea {
  return { trusted: 0, status: 0, attributes: [] };
}

export const ControlledArea: MessageFns<ControlledArea> = {
  encode(
    message: ControlledArea,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trusted !== undefined && message.trusted !== 0) {
      writer.uint32(8).int32(message.trusted);
    }
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.attributes !== undefined && message.attributes.length !== 0) {
      for (const v of message.attributes) {
        KeyPair.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlledArea {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlledArea();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.trusted = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = KeyPair.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.attributes!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlledArea {
    return {
      trusted: isSet(object.trusted)
        ? controlledArea_trustFlagFromJSON(object.trusted)
        : 0,
      status: isSet(object.status)
        ? controlledArea_statusFalgFromJSON(object.status)
        : 0,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => KeyPair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ControlledArea): unknown {
    const obj: any = {};
    if (message.trusted !== undefined && message.trusted !== 0) {
      obj.trusted = controlledArea_trustFlagToJSON(message.trusted);
    }
    if (message.status !== undefined && message.status !== 0) {
      obj.status = controlledArea_statusFalgToJSON(message.status);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => KeyPair.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ControlledArea>, I>>(
    base?: I,
  ): ControlledArea {
    return ControlledArea.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ControlledArea>, I>>(
    object: I,
  ): ControlledArea {
    const message = createBaseControlledArea();
    message.trusted = object.trusted ?? 0;
    message.status = object.status ?? 0;
    message.attributes =
      object.attributes?.map((e) => KeyPair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperationSetControlledArea(): OperationSetControlledArea {
  return {
    destAddress: "",
    sTrusted: false,
    sStatus: false,
    trusted: 0,
    status: 0,
    attributes: [],
  };
}

export const OperationSetControlledArea: MessageFns<OperationSetControlledArea> =
  {
    encode(
      message: OperationSetControlledArea,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.destAddress !== undefined && message.destAddress !== "") {
        writer.uint32(10).string(message.destAddress);
      }
      if (message.sTrusted !== undefined && message.sTrusted !== false) {
        writer.uint32(16).bool(message.sTrusted);
      }
      if (message.sStatus !== undefined && message.sStatus !== false) {
        writer.uint32(24).bool(message.sStatus);
      }
      if (message.trusted !== undefined && message.trusted !== 0) {
        writer.uint32(32).int32(message.trusted);
      }
      if (message.status !== undefined && message.status !== 0) {
        writer.uint32(40).int32(message.status);
      }
      if (message.attributes !== undefined && message.attributes.length !== 0) {
        for (const v of message.attributes) {
          KeyPair.encode(v!, writer.uint32(50).fork()).join();
        }
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): OperationSetControlledArea {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseOperationSetControlledArea();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.destAddress = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.sTrusted = reader.bool();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.sStatus = reader.bool();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.trusted = reader.int32() as any;
            continue;
          }
          case 5: {
            if (tag !== 40) {
              break;
            }

            message.status = reader.int32() as any;
            continue;
          }
          case 6: {
            if (tag !== 50) {
              break;
            }

            const el = KeyPair.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.attributes!.push(el);
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): OperationSetControlledArea {
      return {
        destAddress: isSet(object.dest_address)
          ? globalThis.String(object.dest_address)
          : "",
        sTrusted: isSet(object.s_trusted)
          ? globalThis.Boolean(object.s_trusted)
          : false,
        sStatus: isSet(object.s_status)
          ? globalThis.Boolean(object.s_status)
          : false,
        trusted: isSet(object.trusted)
          ? controlledArea_trustFlagFromJSON(object.trusted)
          : 0,
        status: isSet(object.status)
          ? controlledArea_statusFalgFromJSON(object.status)
          : 0,
        attributes: globalThis.Array.isArray(object?.attributes)
          ? object.attributes.map((e: any) => KeyPair.fromJSON(e))
          : [],
      };
    },

    toJSON(message: OperationSetControlledArea): unknown {
      const obj: any = {};
      if (message.destAddress !== undefined && message.destAddress !== "") {
        obj.dest_address = message.destAddress;
      }
      if (message.sTrusted !== undefined && message.sTrusted !== false) {
        obj.s_trusted = message.sTrusted;
      }
      if (message.sStatus !== undefined && message.sStatus !== false) {
        obj.s_status = message.sStatus;
      }
      if (message.trusted !== undefined && message.trusted !== 0) {
        obj.trusted = controlledArea_trustFlagToJSON(message.trusted);
      }
      if (message.status !== undefined && message.status !== 0) {
        obj.status = controlledArea_statusFalgToJSON(message.status);
      }
      if (message.attributes?.length) {
        obj.attributes = message.attributes.map((e) => KeyPair.toJSON(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<OperationSetControlledArea>, I>>(
      base?: I,
    ): OperationSetControlledArea {
      return OperationSetControlledArea.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<OperationSetControlledArea>, I>>(
      object: I,
    ): OperationSetControlledArea {
      const message = createBaseOperationSetControlledArea();
      message.destAddress = object.destAddress ?? "";
      message.sTrusted = object.sTrusted ?? false;
      message.sStatus = object.sStatus ?? false;
      message.trusted = object.trusted ?? 0;
      message.status = object.status ?? 0;
      message.attributes =
        object.attributes?.map((e) => KeyPair.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseOperationAuthorizeTransfer(): OperationAuthorizeTransfer {
  return { destAddress: "", auth: false };
}

export const OperationAuthorizeTransfer: MessageFns<OperationAuthorizeTransfer> =
  {
    encode(
      message: OperationAuthorizeTransfer,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.destAddress !== undefined && message.destAddress !== "") {
        writer.uint32(10).string(message.destAddress);
      }
      if (message.auth !== undefined && message.auth !== false) {
        writer.uint32(16).bool(message.auth);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): OperationAuthorizeTransfer {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseOperationAuthorizeTransfer();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.destAddress = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.auth = reader.bool();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): OperationAuthorizeTransfer {
      return {
        destAddress: isSet(object.dest_address)
          ? globalThis.String(object.dest_address)
          : "",
        auth: isSet(object.auth) ? globalThis.Boolean(object.auth) : false,
      };
    },

    toJSON(message: OperationAuthorizeTransfer): unknown {
      const obj: any = {};
      if (message.destAddress !== undefined && message.destAddress !== "") {
        obj.dest_address = message.destAddress;
      }
      if (message.auth !== undefined && message.auth !== false) {
        obj.auth = message.auth;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<OperationAuthorizeTransfer>, I>>(
      base?: I,
    ): OperationAuthorizeTransfer {
      return OperationAuthorizeTransfer.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<OperationAuthorizeTransfer>, I>>(
      object: I,
    ): OperationAuthorizeTransfer {
      const message = createBaseOperationAuthorizeTransfer();
      message.destAddress = object.destAddress ?? "";
      message.auth = object.auth ?? false;
      return message;
    },
  };

function createBaseOperation(): Operation {
  return {
    type: 0,
    sourceAddress: "",
    metadata: "",
    createAccount: undefined,
    setMetadata: undefined,
    setSignerWeight: undefined,
    setThreshold: undefined,
    payCoin: undefined,
    log: undefined,
    setPrivilege: undefined,
    upgradeContract: undefined,
    setControlledArea: undefined,
    authorizeTransfer: undefined,
  };
}

export const Operation: MessageFns<Operation> = {
  encode(
    message: Operation,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      writer.uint32(18).string(message.sourceAddress);
    }
    if (message.metadata !== undefined && message.metadata !== "") {
      writer.uint32(26).string(message.metadata);
    }
    if (message.createAccount !== undefined) {
      OperationCreateAccount.encode(
        message.createAccount,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.setMetadata !== undefined) {
      OperationSetMetadata.encode(
        message.setMetadata,
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.setSignerWeight !== undefined) {
      OperationSetSignerWeight.encode(
        message.setSignerWeight,
        writer.uint32(66).fork(),
      ).join();
    }
    if (message.setThreshold !== undefined) {
      OperationSetThreshold.encode(
        message.setThreshold,
        writer.uint32(74).fork(),
      ).join();
    }
    if (message.payCoin !== undefined) {
      OperationPayCoin.encode(message.payCoin, writer.uint32(82).fork()).join();
    }
    if (message.log !== undefined) {
      OperationLog.encode(message.log, writer.uint32(90).fork()).join();
    }
    if (message.setPrivilege !== undefined) {
      OperationSetPrivilege.encode(
        message.setPrivilege,
        writer.uint32(98).fork(),
      ).join();
    }
    if (message.upgradeContract !== undefined) {
      OperationUpgradeContract.encode(
        message.upgradeContract,
        writer.uint32(106).fork(),
      ).join();
    }
    if (message.setControlledArea !== undefined) {
      OperationSetControlledArea.encode(
        message.setControlledArea,
        writer.uint32(114).fork(),
      ).join();
    }
    if (message.authorizeTransfer !== undefined) {
      OperationAuthorizeTransfer.encode(
        message.authorizeTransfer,
        writer.uint32(122).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createAccount = OperationCreateAccount.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.setMetadata = OperationSetMetadata.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.setSignerWeight = OperationSetSignerWeight.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.setThreshold = OperationSetThreshold.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.payCoin = OperationPayCoin.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.log = OperationLog.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.setPrivilege = OperationSetPrivilege.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.upgradeContract = OperationUpgradeContract.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.setControlledArea = OperationSetControlledArea.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.authorizeTransfer = OperationAuthorizeTransfer.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation {
    return {
      type: isSet(object.type) ? operation_TypeFromJSON(object.type) : 0,
      sourceAddress: isSet(object.source_address)
        ? globalThis.String(object.source_address)
        : "",
      metadata: isSet(object.metadata)
        ? globalThis.String(object.metadata)
        : "",
      createAccount: isSet(object.create_account)
        ? OperationCreateAccount.fromJSON(object.create_account)
        : undefined,
      setMetadata: isSet(object.set_metadata)
        ? OperationSetMetadata.fromJSON(object.set_metadata)
        : undefined,
      setSignerWeight: isSet(object.set_signer_weight)
        ? OperationSetSignerWeight.fromJSON(object.set_signer_weight)
        : undefined,
      setThreshold: isSet(object.set_threshold)
        ? OperationSetThreshold.fromJSON(object.set_threshold)
        : undefined,
      payCoin: isSet(object.pay_coin)
        ? OperationPayCoin.fromJSON(object.pay_coin)
        : undefined,
      log: isSet(object.log) ? OperationLog.fromJSON(object.log) : undefined,
      setPrivilege: isSet(object.set_privilege)
        ? OperationSetPrivilege.fromJSON(object.set_privilege)
        : undefined,
      upgradeContract: isSet(object.upgrade_contract)
        ? OperationUpgradeContract.fromJSON(object.upgrade_contract)
        : undefined,
      setControlledArea: isSet(object.set_controlled_area)
        ? OperationSetControlledArea.fromJSON(object.set_controlled_area)
        : undefined,
      authorizeTransfer: isSet(object.authorize_transfer)
        ? OperationAuthorizeTransfer.fromJSON(object.authorize_transfer)
        : undefined,
    };
  },

  toJSON(message: Operation): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 0) {
      obj.type = operation_TypeToJSON(message.type);
    }
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      obj.source_address = message.sourceAddress;
    }
    if (message.metadata !== undefined && message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.createAccount !== undefined) {
      obj.create_account = OperationCreateAccount.toJSON(message.createAccount);
    }
    if (message.setMetadata !== undefined) {
      obj.set_metadata = OperationSetMetadata.toJSON(message.setMetadata);
    }
    if (message.setSignerWeight !== undefined) {
      obj.set_signer_weight = OperationSetSignerWeight.toJSON(
        message.setSignerWeight,
      );
    }
    if (message.setThreshold !== undefined) {
      obj.set_threshold = OperationSetThreshold.toJSON(message.setThreshold);
    }
    if (message.payCoin !== undefined) {
      obj.pay_coin = OperationPayCoin.toJSON(message.payCoin);
    }
    if (message.log !== undefined) {
      obj.log = OperationLog.toJSON(message.log);
    }
    if (message.setPrivilege !== undefined) {
      obj.set_privilege = OperationSetPrivilege.toJSON(message.setPrivilege);
    }
    if (message.upgradeContract !== undefined) {
      obj.upgrade_contract = OperationUpgradeContract.toJSON(
        message.upgradeContract,
      );
    }
    if (message.setControlledArea !== undefined) {
      obj.set_controlled_area = OperationSetControlledArea.toJSON(
        message.setControlledArea,
      );
    }
    if (message.authorizeTransfer !== undefined) {
      obj.authorize_transfer = OperationAuthorizeTransfer.toJSON(
        message.authorizeTransfer,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Operation>, I>>(base?: I): Operation {
    return Operation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Operation>, I>>(
    object: I,
  ): Operation {
    const message = createBaseOperation();
    message.type = object.type ?? 0;
    message.sourceAddress = object.sourceAddress ?? "";
    message.metadata = object.metadata ?? "";
    message.createAccount =
      object.createAccount !== undefined && object.createAccount !== null
        ? OperationCreateAccount.fromPartial(object.createAccount)
        : undefined;
    message.setMetadata =
      object.setMetadata !== undefined && object.setMetadata !== null
        ? OperationSetMetadata.fromPartial(object.setMetadata)
        : undefined;
    message.setSignerWeight =
      object.setSignerWeight !== undefined && object.setSignerWeight !== null
        ? OperationSetSignerWeight.fromPartial(object.setSignerWeight)
        : undefined;
    message.setThreshold =
      object.setThreshold !== undefined && object.setThreshold !== null
        ? OperationSetThreshold.fromPartial(object.setThreshold)
        : undefined;
    message.payCoin =
      object.payCoin !== undefined && object.payCoin !== null
        ? OperationPayCoin.fromPartial(object.payCoin)
        : undefined;
    message.log =
      object.log !== undefined && object.log !== null
        ? OperationLog.fromPartial(object.log)
        : undefined;
    message.setPrivilege =
      object.setPrivilege !== undefined && object.setPrivilege !== null
        ? OperationSetPrivilege.fromPartial(object.setPrivilege)
        : undefined;
    message.upgradeContract =
      object.upgradeContract !== undefined && object.upgradeContract !== null
        ? OperationUpgradeContract.fromPartial(object.upgradeContract)
        : undefined;
    message.setControlledArea =
      object.setControlledArea !== undefined &&
      object.setControlledArea !== null
        ? OperationSetControlledArea.fromPartial(object.setControlledArea)
        : undefined;
    message.authorizeTransfer =
      object.authorizeTransfer !== undefined &&
      object.authorizeTransfer !== null
        ? OperationAuthorizeTransfer.fromPartial(object.authorizeTransfer)
        : undefined;
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return {
    sourceAddress: "",
    feeLimit: 0,
    gasPrice: 0,
    nonce: "",
    metadata: "",
    nonceType: 0,
    maxLedgerSeq: 0,
    operations: [],
  };
}

export const Transaction: MessageFns<Transaction> = {
  encode(
    message: Transaction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      writer.uint32(10).string(message.sourceAddress);
    }
    if (message.feeLimit !== undefined && message.feeLimit !== 0) {
      writer.uint32(16).int64(message.feeLimit);
    }
    if (message.gasPrice !== undefined && message.gasPrice !== 0) {
      writer.uint32(24).int64(message.gasPrice);
    }
    if (message.nonce !== undefined && message.nonce !== "") {
      writer.uint32(34).string(message.nonce);
    }
    if (message.metadata !== undefined && message.metadata !== "") {
      writer.uint32(42).string(message.metadata);
    }
    if (message.nonceType !== undefined && message.nonceType !== 0) {
      writer.uint32(48).int32(message.nonceType);
    }
    if (message.maxLedgerSeq !== undefined && message.maxLedgerSeq !== 0) {
      writer.uint32(56).int64(message.maxLedgerSeq);
    }
    if (message.operations !== undefined && message.operations.length !== 0) {
      for (const v of message.operations) {
        Operation.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.feeLimit = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gasPrice = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.nonceType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.maxLedgerSeq = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const el = Operation.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.operations!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      sourceAddress: isSet(object.source_address)
        ? globalThis.String(object.source_address)
        : "",
      feeLimit: isSet(object.fee_limit)
        ? globalThis.Number(object.fee_limit)
        : 0,
      gasPrice: isSet(object.gas_price)
        ? globalThis.Number(object.gas_price)
        : 0,
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
      metadata: isSet(object.metadata)
        ? globalThis.String(object.metadata)
        : "",
      nonceType: isSet(object.nonce_type)
        ? transaction_TxTypeFromJSON(object.nonce_type)
        : 0,
      maxLedgerSeq: isSet(object.max_ledger_seq)
        ? globalThis.Number(object.max_ledger_seq)
        : 0,
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Operation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      obj.source_address = message.sourceAddress;
    }
    if (message.feeLimit !== undefined && message.feeLimit !== 0) {
      obj.fee_limit = Math.round(message.feeLimit);
    }
    if (message.gasPrice !== undefined && message.gasPrice !== 0) {
      obj.gas_price = Math.round(message.gasPrice);
    }
    if (message.nonce !== undefined && message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    if (message.metadata !== undefined && message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.nonceType !== undefined && message.nonceType !== 0) {
      obj.nonce_type = transaction_TxTypeToJSON(message.nonceType);
    }
    if (message.maxLedgerSeq !== undefined && message.maxLedgerSeq !== 0) {
      obj.max_ledger_seq = Math.round(message.maxLedgerSeq);
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Operation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(
    object: I,
  ): Transaction {
    const message = createBaseTransaction();
    message.sourceAddress = object.sourceAddress ?? "";
    message.feeLimit = object.feeLimit ?? 0;
    message.gasPrice = object.gasPrice ?? 0;
    message.nonce = object.nonce ?? "";
    message.metadata = object.metadata ?? "";
    message.nonceType = object.nonceType ?? 0;
    message.maxLedgerSeq = object.maxLedgerSeq ?? 0;
    message.operations =
      object.operations?.map((e) => Operation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionEnv(): TransactionEnv {
  return {
    hash: "",
    actualFee: 0,
    closeTime: 0,
    contractTxHashes: [],
    errorCode: 0,
    errorDesc: "",
    ledgerSeq: 0,
    signatures: [],
    transaction: undefined,
    txSize: 0,
    blob: "",
  };
}

export const TransactionEnv: MessageFns<TransactionEnv> = {
  encode(
    message: TransactionEnv,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.actualFee !== undefined && message.actualFee !== 0) {
      writer.uint32(16).int64(message.actualFee);
    }
    if (message.closeTime !== undefined && message.closeTime !== 0) {
      writer.uint32(24).int64(message.closeTime);
    }
    if (
      message.contractTxHashes !== undefined &&
      message.contractTxHashes.length !== 0
    ) {
      for (const v of message.contractTxHashes) {
        writer.uint32(34).string(v!);
      }
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(40).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(50).string(message.errorDesc);
    }
    if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
      writer.uint32(56).int64(message.ledgerSeq);
    }
    if (message.signatures !== undefined && message.signatures.length !== 0) {
      for (const v of message.signatures) {
        Signature.encode(v!, writer.uint32(66).fork()).join();
      }
    }
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(74).fork()).join();
    }
    if (message.txSize !== undefined && message.txSize !== 0) {
      writer.uint32(80).int64(message.txSize);
    }
    if (message.blob !== undefined && message.blob !== "") {
      writer.uint32(90).string(message.blob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionEnv {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionEnv();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actualFee = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.closeTime = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.contractTxHashes!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ledgerSeq = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const el = Signature.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signatures!.push(el);
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.txSize = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.blob = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionEnv {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      actualFee: isSet(object.actual_fee)
        ? globalThis.Number(object.actual_fee)
        : 0,
      closeTime: isSet(object.close_time)
        ? globalThis.Number(object.close_time)
        : 0,
      contractTxHashes: globalThis.Array.isArray(object?.contract_tx_hashes)
        ? object.contract_tx_hashes.map((e: any) => globalThis.String(e))
        : [],
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
      ledgerSeq: isSet(object.ledger_seq)
        ? globalThis.Number(object.ledger_seq)
        : 0,
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => Signature.fromJSON(e))
        : [],
      transaction: isSet(object.transaction)
        ? Transaction.fromJSON(object.transaction)
        : undefined,
      txSize: isSet(object.tx_size) ? globalThis.Number(object.tx_size) : 0,
      blob: isSet(object.blob) ? globalThis.String(object.blob) : "",
    };
  },

  toJSON(message: TransactionEnv): unknown {
    const obj: any = {};
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.actualFee !== undefined && message.actualFee !== 0) {
      obj.actual_fee = Math.round(message.actualFee);
    }
    if (message.closeTime !== undefined && message.closeTime !== 0) {
      obj.close_time = Math.round(message.closeTime);
    }
    if (message.contractTxHashes?.length) {
      obj.contract_tx_hashes = message.contractTxHashes;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
      obj.ledger_seq = Math.round(message.ledgerSeq);
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => Signature.toJSON(e));
    }
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    if (message.txSize !== undefined && message.txSize !== 0) {
      obj.tx_size = Math.round(message.txSize);
    }
    if (message.blob !== undefined && message.blob !== "") {
      obj.blob = message.blob;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionEnv>, I>>(
    base?: I,
  ): TransactionEnv {
    return TransactionEnv.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionEnv>, I>>(
    object: I,
  ): TransactionEnv {
    const message = createBaseTransactionEnv();
    message.hash = object.hash ?? "";
    message.actualFee = object.actualFee ?? 0;
    message.closeTime = object.closeTime ?? 0;
    message.contractTxHashes = object.contractTxHashes?.map((e) => e) || [];
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    message.ledgerSeq = object.ledgerSeq ?? 0;
    message.signatures =
      object.signatures?.map((e) => Signature.fromPartial(e)) || [];
    message.transaction =
      object.transaction !== undefined && object.transaction !== null
        ? Transaction.fromPartial(object.transaction)
        : undefined;
    message.txSize = object.txSize ?? 0;
    message.blob = object.blob ?? "";
    return message;
  },
};

function createBaseGetTransactionHistoryResult(): GetTransactionHistoryResult {
  return { totalCount: 0, transactions: [] };
}

export const GetTransactionHistoryResult: MessageFns<GetTransactionHistoryResult> =
  {
    encode(
      message: GetTransactionHistoryResult,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.totalCount !== undefined && message.totalCount !== 0) {
        writer.uint32(8).int64(message.totalCount);
      }
      if (
        message.transactions !== undefined &&
        message.transactions.length !== 0
      ) {
        for (const v of message.transactions) {
          TransactionEnv.encode(v!, writer.uint32(18).fork()).join();
        }
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetTransactionHistoryResult {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetTransactionHistoryResult();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.totalCount = longToNumber(reader.int64());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            const el = TransactionEnv.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.transactions!.push(el);
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetTransactionHistoryResult {
      return {
        totalCount: isSet(object.total_count)
          ? globalThis.Number(object.total_count)
          : 0,
        transactions: globalThis.Array.isArray(object?.transactions)
          ? object.transactions.map((e: any) => TransactionEnv.fromJSON(e))
          : [],
      };
    },

    toJSON(message: GetTransactionHistoryResult): unknown {
      const obj: any = {};
      if (message.totalCount !== undefined && message.totalCount !== 0) {
        obj.total_count = Math.round(message.totalCount);
      }
      if (message.transactions?.length) {
        obj.transactions = message.transactions.map((e) =>
          TransactionEnv.toJSON(e),
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetTransactionHistoryResult>, I>>(
      base?: I,
    ): GetTransactionHistoryResult {
      return GetTransactionHistoryResult.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetTransactionHistoryResult>, I>>(
      object: I,
    ): GetTransactionHistoryResult {
      const message = createBaseGetTransactionHistoryResult();
      message.totalCount = object.totalCount ?? 0;
      message.transactions =
        object.transactions?.map((e) => TransactionEnv.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseGetTransactionHistoryResponse(): GetTransactionHistoryResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const GetTransactionHistoryResponse: MessageFns<GetTransactionHistoryResponse> =
  {
    encode(
      message: GetTransactionHistoryResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.trace !== undefined && message.trace !== "") {
        writer.uint32(10).string(message.trace);
      }
      if (message.result !== undefined) {
        GetTransactionHistoryResult.encode(
          message.result,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.success !== undefined && message.success !== false) {
        writer.uint32(24).bool(message.success);
      }
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(32).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(42).string(message.errorDesc);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetTransactionHistoryResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetTransactionHistoryResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.trace = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.result = GetTransactionHistoryResult.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.success = reader.bool();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetTransactionHistoryResponse {
      return {
        trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
        result: isSet(object.result)
          ? GetTransactionHistoryResult.fromJSON(object.result)
          : undefined,
        success: isSet(object.success)
          ? globalThis.Boolean(object.success)
          : false,
        errorCode: isSet(object.error_code)
          ? statusCodesFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
      };
    },

    toJSON(message: GetTransactionHistoryResponse): unknown {
      const obj: any = {};
      if (message.trace !== undefined && message.trace !== "") {
        obj.trace = message.trace;
      }
      if (message.result !== undefined) {
        obj.result = GetTransactionHistoryResult.toJSON(message.result);
      }
      if (message.success !== undefined && message.success !== false) {
        obj.success = message.success;
      }
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = statusCodesToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetTransactionHistoryResponse>, I>>(
      base?: I,
    ): GetTransactionHistoryResponse {
      return GetTransactionHistoryResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetTransactionHistoryResponse>, I>>(
      object: I,
    ): GetTransactionHistoryResponse {
      const message = createBaseGetTransactionHistoryResponse();
      message.trace = object.trace ?? "";
      message.result =
        object.result !== undefined && object.result !== null
          ? GetTransactionHistoryResult.fromPartial(object.result)
          : undefined;
      message.success = object.success ?? false;
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      return message;
    },
  };

function createBaseTestTransaction(): TestTransaction {
  return { transactionJson: undefined, signatureNumber: 0 };
}

export const TestTransaction: MessageFns<TestTransaction> = {
  encode(
    message: TestTransaction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transactionJson !== undefined) {
      Transaction.encode(
        message.transactionJson,
        writer.uint32(10).fork(),
      ).join();
    }
    if (
      message.signatureNumber !== undefined &&
      message.signatureNumber !== 0
    ) {
      writer.uint32(16).int64(message.signatureNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestTransaction {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionJson = Transaction.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.signatureNumber = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestTransaction {
    return {
      transactionJson: isSet(object.transaction_json)
        ? Transaction.fromJSON(object.transaction_json)
        : undefined,
      signatureNumber: isSet(object.signature_number)
        ? globalThis.Number(object.signature_number)
        : 0,
    };
  },

  toJSON(message: TestTransaction): unknown {
    const obj: any = {};
    if (message.transactionJson !== undefined) {
      obj.transaction_json = Transaction.toJSON(message.transactionJson);
    }
    if (
      message.signatureNumber !== undefined &&
      message.signatureNumber !== 0
    ) {
      obj.signature_number = Math.round(message.signatureNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestTransaction>, I>>(
    base?: I,
  ): TestTransaction {
    return TestTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestTransaction>, I>>(
    object: I,
  ): TestTransaction {
    const message = createBaseTestTransaction();
    message.transactionJson =
      object.transactionJson !== undefined && object.transactionJson !== null
        ? Transaction.fromPartial(object.transactionJson)
        : undefined;
    message.signatureNumber = object.signatureNumber ?? 0;
    return message;
  },
};

function createBaseTestTransactionRequest(): TestTransactionRequest {
  return { items: [] };
}

export const TestTransactionRequest: MessageFns<TestTransactionRequest> = {
  encode(
    message: TestTransactionRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.items !== undefined && message.items.length !== 0) {
      for (const v of message.items) {
        TestTransaction.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TestTransactionRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = TestTransaction.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.items!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestTransactionRequest {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => TestTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TestTransactionRequest): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => TestTransaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestTransactionRequest>, I>>(
    base?: I,
  ): TestTransactionRequest {
    return TestTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestTransactionRequest>, I>>(
    object: I,
  ): TestTransactionRequest {
    const message = createBaseTestTransactionRequest();
    message.items =
      object.items?.map((e) => TestTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTestTransactionResult(): TestTransactionResult {
  return { stat: undefined, hash: "", txs: [] };
}

export const TestTransactionResult: MessageFns<TestTransactionResult> = {
  encode(
    message: TestTransactionResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.stat !== undefined) {
      TestTransactionResult_Stat.encode(
        message.stat,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    if (message.txs !== undefined && message.txs.length !== 0) {
      for (const v of message.txs) {
        TestTransactionResult_TestTx.encode(
          v!,
          writer.uint32(26).fork(),
        ).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TestTransactionResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestTransactionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stat = TestTransactionResult_Stat.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = TestTransactionResult_TestTx.decode(
            reader,
            reader.uint32(),
          );
          if (el !== undefined) {
            message.txs!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestTransactionResult {
    return {
      stat: isSet(object.stat)
        ? TestTransactionResult_Stat.fromJSON(object.stat)
        : undefined,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      txs: globalThis.Array.isArray(object?.txs)
        ? object.txs.map((e: any) => TestTransactionResult_TestTx.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TestTransactionResult): unknown {
    const obj: any = {};
    if (message.stat !== undefined) {
      obj.stat = TestTransactionResult_Stat.toJSON(message.stat);
    }
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.txs?.length) {
      obj.txs = message.txs.map((e) => TestTransactionResult_TestTx.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestTransactionResult>, I>>(
    base?: I,
  ): TestTransactionResult {
    return TestTransactionResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestTransactionResult>, I>>(
    object: I,
  ): TestTransactionResult {
    const message = createBaseTestTransactionResult();
    message.stat =
      object.stat !== undefined && object.stat !== null
        ? TestTransactionResult_Stat.fromPartial(object.stat)
        : undefined;
    message.hash = object.hash ?? "";
    message.txs =
      object.txs?.map((e) => TestTransactionResult_TestTx.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTestTransactionResult_Stat(): TestTransactionResult_Stat {
  return { applyTime: 0, memoryUsage: 0, stackUsage: 0, step: 0 };
}

export const TestTransactionResult_Stat: MessageFns<TestTransactionResult_Stat> =
  {
    encode(
      message: TestTransactionResult_Stat,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.applyTime !== undefined && message.applyTime !== 0) {
        writer.uint32(8).int64(message.applyTime);
      }
      if (message.memoryUsage !== undefined && message.memoryUsage !== 0) {
        writer.uint32(16).int64(message.memoryUsage);
      }
      if (message.stackUsage !== undefined && message.stackUsage !== 0) {
        writer.uint32(24).int64(message.stackUsage);
      }
      if (message.step !== undefined && message.step !== 0) {
        writer.uint32(32).int64(message.step);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): TestTransactionResult_Stat {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTestTransactionResult_Stat();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.applyTime = longToNumber(reader.int64());
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.memoryUsage = longToNumber(reader.int64());
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.stackUsage = longToNumber(reader.int64());
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.step = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): TestTransactionResult_Stat {
      return {
        applyTime: isSet(object.apply_time)
          ? globalThis.Number(object.apply_time)
          : 0,
        memoryUsage: isSet(object.memory_usage)
          ? globalThis.Number(object.memory_usage)
          : 0,
        stackUsage: isSet(object.stack_usage)
          ? globalThis.Number(object.stack_usage)
          : 0,
        step: isSet(object.step) ? globalThis.Number(object.step) : 0,
      };
    },

    toJSON(message: TestTransactionResult_Stat): unknown {
      const obj: any = {};
      if (message.applyTime !== undefined && message.applyTime !== 0) {
        obj.apply_time = Math.round(message.applyTime);
      }
      if (message.memoryUsage !== undefined && message.memoryUsage !== 0) {
        obj.memory_usage = Math.round(message.memoryUsage);
      }
      if (message.stackUsage !== undefined && message.stackUsage !== 0) {
        obj.stack_usage = Math.round(message.stackUsage);
      }
      if (message.step !== undefined && message.step !== 0) {
        obj.step = Math.round(message.step);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<TestTransactionResult_Stat>, I>>(
      base?: I,
    ): TestTransactionResult_Stat {
      return TestTransactionResult_Stat.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<TestTransactionResult_Stat>, I>>(
      object: I,
    ): TestTransactionResult_Stat {
      const message = createBaseTestTransactionResult_Stat();
      message.applyTime = object.applyTime ?? 0;
      message.memoryUsage = object.memoryUsage ?? 0;
      message.stackUsage = object.stackUsage ?? 0;
      message.step = object.step ?? 0;
      return message;
    },
  };

function createBaseTestTransactionResult_TransactionEnv(): TestTransactionResult_TransactionEnv {
  return { transaction: undefined };
}

export const TestTransactionResult_TransactionEnv: MessageFns<TestTransactionResult_TransactionEnv> =
  {
    encode(
      message: TestTransactionResult_TransactionEnv,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.transaction !== undefined) {
        Transaction.encode(
          message.transaction,
          writer.uint32(10).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): TestTransactionResult_TransactionEnv {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTestTransactionResult_TransactionEnv();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.transaction = Transaction.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): TestTransactionResult_TransactionEnv {
      return {
        transaction: isSet(object.transaction)
          ? Transaction.fromJSON(object.transaction)
          : undefined,
      };
    },

    toJSON(message: TestTransactionResult_TransactionEnv): unknown {
      const obj: any = {};
      if (message.transaction !== undefined) {
        obj.transaction = Transaction.toJSON(message.transaction);
      }
      return obj;
    },

    create<
      I extends Exact<DeepPartial<TestTransactionResult_TransactionEnv>, I>,
    >(base?: I): TestTransactionResult_TransactionEnv {
      return TestTransactionResult_TransactionEnv.fromPartial(
        base ?? ({} as any),
      );
    },
    fromPartial<
      I extends Exact<DeepPartial<TestTransactionResult_TransactionEnv>, I>,
    >(object: I): TestTransactionResult_TransactionEnv {
      const message = createBaseTestTransactionResult_TransactionEnv();
      message.transaction =
        object.transaction !== undefined && object.transaction !== null
          ? Transaction.fromPartial(object.transaction)
          : undefined;
      return message;
    },
  };

function createBaseTestTransactionResult_TestTx(): TestTransactionResult_TestTx {
  return { gas: 0, transactionEnv: undefined, actualFee: 0 };
}

export const TestTransactionResult_TestTx: MessageFns<TestTransactionResult_TestTx> =
  {
    encode(
      message: TestTransactionResult_TestTx,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.gas !== undefined && message.gas !== 0) {
        writer.uint32(8).int64(message.gas);
      }
      if (message.transactionEnv !== undefined) {
        TestTransactionResult_TransactionEnv.encode(
          message.transactionEnv,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.actualFee !== undefined && message.actualFee !== 0) {
        writer.uint32(24).int64(message.actualFee);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): TestTransactionResult_TestTx {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseTestTransactionResult_TestTx();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.gas = longToNumber(reader.int64());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.transactionEnv =
              TestTransactionResult_TransactionEnv.decode(
                reader,
                reader.uint32(),
              );
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.actualFee = longToNumber(reader.int64());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): TestTransactionResult_TestTx {
      return {
        gas: isSet(object.gas) ? globalThis.Number(object.gas) : 0,
        transactionEnv: isSet(object.transaction_env)
          ? TestTransactionResult_TransactionEnv.fromJSON(
              object.transaction_env,
            )
          : undefined,
        actualFee: isSet(object.actual_fee)
          ? globalThis.Number(object.actual_fee)
          : 0,
      };
    },

    toJSON(message: TestTransactionResult_TestTx): unknown {
      const obj: any = {};
      if (message.gas !== undefined && message.gas !== 0) {
        obj.gas = Math.round(message.gas);
      }
      if (message.transactionEnv !== undefined) {
        obj.transaction_env = TestTransactionResult_TransactionEnv.toJSON(
          message.transactionEnv,
        );
      }
      if (message.actualFee !== undefined && message.actualFee !== 0) {
        obj.actual_fee = Math.round(message.actualFee);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<TestTransactionResult_TestTx>, I>>(
      base?: I,
    ): TestTransactionResult_TestTx {
      return TestTransactionResult_TestTx.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<TestTransactionResult_TestTx>, I>>(
      object: I,
    ): TestTransactionResult_TestTx {
      const message = createBaseTestTransactionResult_TestTx();
      message.gas = object.gas ?? 0;
      message.transactionEnv =
        object.transactionEnv !== undefined && object.transactionEnv !== null
          ? TestTransactionResult_TransactionEnv.fromPartial(
              object.transactionEnv,
            )
          : undefined;
      message.actualFee = object.actualFee ?? 0;
      return message;
    },
  };

function createBaseTestTransactionResponse(): TestTransactionResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const TestTransactionResponse: MessageFns<TestTransactionResponse> = {
  encode(
    message: TestTransactionResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      TestTransactionResult.encode(
        message.result,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): TestTransactionResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = TestTransactionResult.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestTransactionResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? TestTransactionResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: TestTransactionResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = TestTransactionResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestTransactionResponse>, I>>(
    base?: I,
  ): TestTransactionResponse {
    return TestTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestTransactionResponse>, I>>(
    object: I,
  ): TestTransactionResponse {
    const message = createBaseTestTransactionResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? TestTransactionResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseCallContractRequest(): CallContractRequest {
  return {
    contractAddress: "",
    input: "",
    feeLimit: 0,
    gasPrice: 0,
    sourceAddress: "",
    optType: 0,
  };
}

export const CallContractRequest: MessageFns<CallContractRequest> = {
  encode(
    message: CallContractRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (
      message.contractAddress !== undefined &&
      message.contractAddress !== ""
    ) {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.input !== undefined && message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.feeLimit !== undefined && message.feeLimit !== 0) {
      writer.uint32(32).int64(message.feeLimit);
    }
    if (message.gasPrice !== undefined && message.gasPrice !== 0) {
      writer.uint32(40).int64(message.gasPrice);
    }
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      writer.uint32(50).string(message.sourceAddress);
    }
    if (message.optType !== undefined && message.optType !== 0) {
      writer.uint32(56).int64(message.optType);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallContractRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.feeLimit = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gasPrice = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sourceAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.optType = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractRequest {
    return {
      contractAddress: isSet(object.contract_address)
        ? globalThis.String(object.contract_address)
        : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      feeLimit: isSet(object.fee_limit)
        ? globalThis.Number(object.fee_limit)
        : 0,
      gasPrice: isSet(object.gas_price)
        ? globalThis.Number(object.gas_price)
        : 0,
      sourceAddress: isSet(object.source_address)
        ? globalThis.String(object.source_address)
        : "",
      optType: isSet(object.opt_type) ? globalThis.Number(object.opt_type) : 0,
    };
  },

  toJSON(message: CallContractRequest): unknown {
    const obj: any = {};
    if (
      message.contractAddress !== undefined &&
      message.contractAddress !== ""
    ) {
      obj.contract_address = message.contractAddress;
    }
    if (message.input !== undefined && message.input !== "") {
      obj.input = message.input;
    }
    if (message.feeLimit !== undefined && message.feeLimit !== 0) {
      obj.fee_limit = Math.round(message.feeLimit);
    }
    if (message.gasPrice !== undefined && message.gasPrice !== 0) {
      obj.gas_price = Math.round(message.gasPrice);
    }
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      obj.source_address = message.sourceAddress;
    }
    if (message.optType !== undefined && message.optType !== 0) {
      obj.opt_type = Math.round(message.optType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractRequest>, I>>(
    base?: I,
  ): CallContractRequest {
    return CallContractRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractRequest>, I>>(
    object: I,
  ): CallContractRequest {
    const message = createBaseCallContractRequest();
    message.contractAddress = object.contractAddress ?? "";
    message.input = object.input ?? "";
    message.feeLimit = object.feeLimit ?? 0;
    message.gasPrice = object.gasPrice ?? 0;
    message.sourceAddress = object.sourceAddress ?? "";
    message.optType = object.optType ?? 0;
    return message;
  },
};

function createBaseCallContractResultSystem(): CallContractResultSystem {
  return { queryRets: [] };
}

export const CallContractResultSystem: MessageFns<CallContractResultSystem> = {
  encode(
    message: CallContractResultSystem,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.queryRets !== undefined && message.queryRets.length !== 0) {
      for (const v of message.queryRets) {
        QueryReturnSystem.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallContractResultSystem {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractResultSystem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = QueryReturnSystem.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.queryRets!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractResultSystem {
    return {
      queryRets: globalThis.Array.isArray(object?.query_rets)
        ? object.query_rets.map((e: any) => QueryReturnSystem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CallContractResultSystem): unknown {
    const obj: any = {};
    if (message.queryRets?.length) {
      obj.query_rets = message.queryRets.map((e) =>
        QueryReturnSystem.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractResultSystem>, I>>(
    base?: I,
  ): CallContractResultSystem {
    return CallContractResultSystem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractResultSystem>, I>>(
    object: I,
  ): CallContractResultSystem {
    const message = createBaseCallContractResultSystem();
    message.queryRets =
      object.queryRets?.map((e) => QueryReturnSystem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryReturnSystem(): QueryReturnSystem {
  return { error: undefined, result: undefined };
}

export const QueryReturnSystem: MessageFns<QueryReturnSystem> = {
  encode(
    message: QueryReturnSystem,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      SystemContractResult.encode(
        message.result,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryReturnSystem {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReturnSystem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = SystemContractResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReturnSystem {
    return {
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      result: isSet(object.result)
        ? SystemContractResult.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: QueryReturnSystem): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.result !== undefined) {
      obj.result = SystemContractResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReturnSystem>, I>>(
    base?: I,
  ): QueryReturnSystem {
    return QueryReturnSystem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReturnSystem>, I>>(
    object: I,
  ): QueryReturnSystem {
    const message = createBaseQueryReturnSystem();
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    message.result =
      object.result !== undefined && object.result !== null
        ? SystemContractResult.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseSystemContractResult(): SystemContractResult {
  return { data: "" };
}

export const SystemContractResult: MessageFns<SystemContractResult> = {
  encode(
    message: SystemContractResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.data !== undefined && message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): SystemContractResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemContractResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemContractResult {
    return { data: isSet(object.data) ? globalThis.String(object.data) : "" };
  },

  toJSON(message: SystemContractResult): unknown {
    const obj: any = {};
    if (message.data !== undefined && message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemContractResult>, I>>(
    base?: I,
  ): SystemContractResult {
    return SystemContractResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemContractResult>, I>>(
    object: I,
  ): SystemContractResult {
    const message = createBaseSystemContractResult();
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseCallContractResultJs(): CallContractResultJs {
  return { queryRets: [] };
}

export const CallContractResultJs: MessageFns<CallContractResultJs> = {
  encode(
    message: CallContractResultJs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.queryRets !== undefined && message.queryRets.length !== 0) {
      for (const v of message.queryRets) {
        QueryReturnJs.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallContractResultJs {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractResultJs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = QueryReturnJs.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.queryRets!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractResultJs {
    return {
      queryRets: globalThis.Array.isArray(object?.query_rets)
        ? object.query_rets.map((e: any) => QueryReturnJs.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CallContractResultJs): unknown {
    const obj: any = {};
    if (message.queryRets?.length) {
      obj.query_rets = message.queryRets.map((e) => QueryReturnJs.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractResultJs>, I>>(
    base?: I,
  ): CallContractResultJs {
    return CallContractResultJs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractResultJs>, I>>(
    object: I,
  ): CallContractResultJs {
    const message = createBaseCallContractResultJs();
    message.queryRets =
      object.queryRets?.map((e) => QueryReturnJs.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryReturnJs(): QueryReturnJs {
  return { error: undefined, result: undefined };
}

export const QueryReturnJs: MessageFns<QueryReturnJs> = {
  encode(
    message: QueryReturnJs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      JsContractResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryReturnJs {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReturnJs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = JsContractResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReturnJs {
    return {
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      result: isSet(object.result)
        ? JsContractResult.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: QueryReturnJs): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.result !== undefined) {
      obj.result = JsContractResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReturnJs>, I>>(
    base?: I,
  ): QueryReturnJs {
    return QueryReturnJs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReturnJs>, I>>(
    object: I,
  ): QueryReturnJs {
    const message = createBaseQueryReturnJs();
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    message.result =
      object.result !== undefined && object.result !== null
        ? JsContractResult.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseJsContractResult(): JsContractResult {
  return { type: "", value: "" };
}

export const JsContractResult: MessageFns<JsContractResult> = {
  encode(
    message: JsContractResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined && message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.value !== undefined && message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JsContractResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsContractResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JsContractResult {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: JsContractResult): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== "") {
      obj.type = message.type;
    }
    if (message.value !== undefined && message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsContractResult>, I>>(
    base?: I,
  ): JsContractResult {
    return JsContractResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsContractResult>, I>>(
    object: I,
  ): JsContractResult {
    const message = createBaseJsContractResult();
    message.type = object.type ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCallContractResultEvm(): CallContractResultEvm {
  return { queryRets: [] };
}

export const CallContractResultEvm: MessageFns<CallContractResultEvm> = {
  encode(
    message: CallContractResultEvm,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.queryRets !== undefined && message.queryRets.length !== 0) {
      for (const v of message.queryRets) {
        QueryReturnEvm.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallContractResultEvm {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractResultEvm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = QueryReturnEvm.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.queryRets!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractResultEvm {
    return {
      queryRets: globalThis.Array.isArray(object?.query_rets)
        ? object.query_rets.map((e: any) => QueryReturnEvm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CallContractResultEvm): unknown {
    const obj: any = {};
    if (message.queryRets?.length) {
      obj.query_rets = message.queryRets.map((e) => QueryReturnEvm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractResultEvm>, I>>(
    base?: I,
  ): CallContractResultEvm {
    return CallContractResultEvm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractResultEvm>, I>>(
    object: I,
  ): CallContractResultEvm {
    const message = createBaseCallContractResultEvm();
    message.queryRets =
      object.queryRets?.map((e) => QueryReturnEvm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryReturnEvm(): QueryReturnEvm {
  return { error: undefined, result: undefined };
}

export const QueryReturnEvm: MessageFns<QueryReturnEvm> = {
  encode(
    message: QueryReturnEvm,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      EvmContractResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryReturnEvm {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReturnEvm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = EvmContractResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReturnEvm {
    return {
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      result: isSet(object.result)
        ? EvmContractResult.fromJSON(object.result)
        : undefined,
    };
  },

  toJSON(message: QueryReturnEvm): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.result !== undefined) {
      obj.result = EvmContractResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReturnEvm>, I>>(
    base?: I,
  ): QueryReturnEvm {
    return QueryReturnEvm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReturnEvm>, I>>(
    object: I,
  ): QueryReturnEvm {
    const message = createBaseQueryReturnEvm();
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined;
    message.result =
      object.result !== undefined && object.result !== null
        ? EvmContractResult.fromPartial(object.result)
        : undefined;
    return message;
  },
};

function createBaseEvmContractResult(): EvmContractResult {
  return { code: 0, data: "", desc: "", eumcode: "", gasused: 0 };
}

export const EvmContractResult: MessageFns<EvmContractResult> = {
  encode(
    message: EvmContractResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.code !== undefined && message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.data !== undefined && message.data !== "") {
      writer.uint32(18).string(message.data);
    }
    if (message.desc !== undefined && message.desc !== "") {
      writer.uint32(26).string(message.desc);
    }
    if (message.eumcode !== undefined && message.eumcode !== "") {
      writer.uint32(34).string(message.eumcode);
    }
    if (message.gasused !== undefined && message.gasused !== 0) {
      writer.uint32(40).int64(message.gasused);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvmContractResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvmContractResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.desc = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eumcode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.gasused = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvmContractResult {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      desc: isSet(object.desc) ? globalThis.String(object.desc) : "",
      eumcode: isSet(object.eumcode) ? globalThis.String(object.eumcode) : "",
      gasused: isSet(object.gasused) ? globalThis.Number(object.gasused) : 0,
    };
  },

  toJSON(message: EvmContractResult): unknown {
    const obj: any = {};
    if (message.code !== undefined && message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.data !== undefined && message.data !== "") {
      obj.data = message.data;
    }
    if (message.desc !== undefined && message.desc !== "") {
      obj.desc = message.desc;
    }
    if (message.eumcode !== undefined && message.eumcode !== "") {
      obj.eumcode = message.eumcode;
    }
    if (message.gasused !== undefined && message.gasused !== 0) {
      obj.gasused = Math.round(message.gasused);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvmContractResult>, I>>(
    base?: I,
  ): EvmContractResult {
    return EvmContractResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvmContractResult>, I>>(
    object: I,
  ): EvmContractResult {
    const message = createBaseEvmContractResult();
    message.code = object.code ?? 0;
    message.data = object.data ?? "";
    message.desc = object.desc ?? "";
    message.eumcode = object.eumcode ?? "";
    message.gasused = object.gasused ?? 0;
    return message;
  },
};

function createBaseError(): Error {
  return { data: "" };
}

export const Error: MessageFns<Error> = {
  encode(
    message: Error,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.data !== undefined && message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return { data: isSet(object.data) ? globalThis.String(object.data) : "" };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.data !== undefined && message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseQueryReturn(): QueryReturn {
  return { error: "", result: "" };
}

export const QueryReturn: MessageFns<QueryReturn> = {
  encode(
    message: QueryReturn,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.error !== undefined && message.error !== "") {
      writer.uint32(10).string(message.error);
    }
    if (message.result !== undefined && message.result !== "") {
      writer.uint32(18).string(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryReturn {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReturn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReturn {
    return {
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      result: isSet(object.result) ? globalThis.String(object.result) : "",
    };
  },

  toJSON(message: QueryReturn): unknown {
    const obj: any = {};
    if (message.error !== undefined && message.error !== "") {
      obj.error = message.error;
    }
    if (message.result !== undefined && message.result !== "") {
      obj.result = message.result;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReturn>, I>>(base?: I): QueryReturn {
    return QueryReturn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReturn>, I>>(
    object: I,
  ): QueryReturn {
    const message = createBaseQueryReturn();
    message.error = object.error ?? "";
    message.result = object.result ?? "";
    return message;
  },
};

function createBaseCallContractResult(): CallContractResult {
  return { queryRets: [] };
}

export const CallContractResult: MessageFns<CallContractResult> = {
  encode(
    message: CallContractResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.queryRets !== undefined && message.queryRets.length !== 0) {
      for (const v of message.queryRets) {
        QueryReturn.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallContractResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = QueryReturn.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.queryRets!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractResult {
    return {
      queryRets: globalThis.Array.isArray(object?.query_rets)
        ? object.query_rets.map((e: any) => QueryReturn.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CallContractResult): unknown {
    const obj: any = {};
    if (message.queryRets?.length) {
      obj.query_rets = message.queryRets.map((e) => QueryReturn.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractResult>, I>>(
    base?: I,
  ): CallContractResult {
    return CallContractResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractResult>, I>>(
    object: I,
  ): CallContractResult {
    const message = createBaseCallContractResult();
    message.queryRets =
      object.queryRets?.map((e) => QueryReturn.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCallContractResponse(): CallContractResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const CallContractResponse: MessageFns<CallContractResponse> = {
  encode(
    message: CallContractResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      CallContractResult.encode(
        message.result,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CallContractResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = CallContractResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallContractResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? CallContractResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: CallContractResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = CallContractResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallContractResponse>, I>>(
    base?: I,
  ): CallContractResponse {
    return CallContractResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallContractResponse>, I>>(
    object: I,
  ): CallContractResponse {
    const message = createBaseCallContractResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? CallContractResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseQueryRequest(): QueryRequest {
  return {
    bid: "",
    hash: "",
    txId: "",
    startTime: "",
    endTime: "",
    txType: 0,
    page: 0,
    pageSize: 0,
    ledgerSeq: 0,
  };
}

export const QueryRequest: MessageFns<QueryRequest> = {
  encode(
    message: QueryRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.bid !== undefined && message.bid !== "") {
      writer.uint32(10).string(message.bid);
    }
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    if (message.txId !== undefined && message.txId !== "") {
      writer.uint32(26).string(message.txId);
    }
    if (message.startTime !== undefined && message.startTime !== "") {
      writer.uint32(34).string(message.startTime);
    }
    if (message.endTime !== undefined && message.endTime !== "") {
      writer.uint32(42).string(message.endTime);
    }
    if (message.txType !== undefined && message.txType !== 0) {
      writer.uint32(48).int32(message.txType);
    }
    if (message.page !== undefined && message.page !== 0) {
      writer.uint32(56).int32(message.page);
    }
    if (message.pageSize !== undefined && message.pageSize !== 0) {
      writer.uint32(64).int32(message.pageSize);
    }
    if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
      writer.uint32(72).int64(message.ledgerSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.txId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.txType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.ledgerSeq = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRequest {
    return {
      bid: isSet(object.bid) ? globalThis.String(object.bid) : "",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      startTime: isSet(object.startTime)
        ? globalThis.String(object.startTime)
        : "",
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : "",
      txType: isSet(object.txType)
        ? queryRequest_TxTypeFromJSON(object.txType)
        : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      ledgerSeq: isSet(object.ledgerSeq)
        ? globalThis.Number(object.ledgerSeq)
        : 0,
    };
  },

  toJSON(message: QueryRequest): unknown {
    const obj: any = {};
    if (message.bid !== undefined && message.bid !== "") {
      obj.bid = message.bid;
    }
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.txId !== undefined && message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.startTime !== undefined && message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== undefined && message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    if (message.txType !== undefined && message.txType !== 0) {
      obj.txType = queryRequest_TxTypeToJSON(message.txType);
    }
    if (message.page !== undefined && message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== undefined && message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
      obj.ledgerSeq = Math.round(message.ledgerSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRequest>, I>>(
    base?: I,
  ): QueryRequest {
    return QueryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRequest>, I>>(
    object: I,
  ): QueryRequest {
    const message = createBaseQueryRequest();
    message.bid = object.bid ?? "";
    message.hash = object.hash ?? "";
    message.txId = object.txId ?? "";
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    message.txType = object.txType ?? 0;
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.ledgerSeq = object.ledgerSeq ?? 0;
    return message;
  },
};

function createBaseTransactionBase(): TransactionBase {
  return {
    id: "",
    txId: "",
    hash: "",
    apiKey: "",
    txType: 0,
    createTime: "",
    ledgerSeq: 0,
    sourceAddress: "",
    actualFee: 0,
    status: 0,
    statusDesc: "",
    baseTransaction: undefined,
  };
}

export const TransactionBase: MessageFns<TransactionBase> = {
  encode(
    message: TransactionBase,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== undefined && message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.txId !== undefined && message.txId !== "") {
      writer.uint32(18).string(message.txId);
    }
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(26).string(message.hash);
    }
    if (message.apiKey !== undefined && message.apiKey !== "") {
      writer.uint32(34).string(message.apiKey);
    }
    if (message.txType !== undefined && message.txType !== 0) {
      writer.uint32(40).int32(message.txType);
    }
    if (message.createTime !== undefined && message.createTime !== "") {
      writer.uint32(50).string(message.createTime);
    }
    if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
      writer.uint32(56).int64(message.ledgerSeq);
    }
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      writer.uint32(66).string(message.sourceAddress);
    }
    if (message.actualFee !== undefined && message.actualFee !== 0) {
      writer.uint32(72).int64(message.actualFee);
    }
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(80).int32(message.status);
    }
    if (message.statusDesc !== undefined && message.statusDesc !== "") {
      writer.uint32(90).string(message.statusDesc);
    }
    if (message.baseTransaction !== undefined) {
      TransactionEnv.encode(
        message.baseTransaction,
        writer.uint32(98).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionBase {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionBase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.apiKey = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.txType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createTime = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ledgerSeq = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sourceAddress = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.actualFee = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.statusDesc = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.baseTransaction = TransactionEnv.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionBase {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      txId: isSet(object.tx_id) ? globalThis.String(object.tx_id) : "",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      apiKey: isSet(object.api_key) ? globalThis.String(object.api_key) : "",
      txType: isSet(object.tx_type)
        ? transactionBase_TxTypeFromJSON(object.tx_type)
        : 0,
      createTime: isSet(object.create_time)
        ? globalThis.String(object.create_time)
        : "",
      ledgerSeq: isSet(object.ledger_seq)
        ? globalThis.Number(object.ledger_seq)
        : 0,
      sourceAddress: isSet(object.source_address)
        ? globalThis.String(object.source_address)
        : "",
      actualFee: isSet(object.actual_fee)
        ? globalThis.Number(object.actual_fee)
        : 0,
      status: isSet(object.status) ? statusCodesFromJSON(object.status) : 0,
      statusDesc: isSet(object.status_desc)
        ? globalThis.String(object.status_desc)
        : "",
      baseTransaction: isSet(object.base_transaction)
        ? TransactionEnv.fromJSON(object.base_transaction)
        : undefined,
    };
  },

  toJSON(message: TransactionBase): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== "") {
      obj.id = message.id;
    }
    if (message.txId !== undefined && message.txId !== "") {
      obj.tx_id = message.txId;
    }
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.apiKey !== undefined && message.apiKey !== "") {
      obj.api_key = message.apiKey;
    }
    if (message.txType !== undefined && message.txType !== 0) {
      obj.tx_type = transactionBase_TxTypeToJSON(message.txType);
    }
    if (message.createTime !== undefined && message.createTime !== "") {
      obj.create_time = message.createTime;
    }
    if (message.ledgerSeq !== undefined && message.ledgerSeq !== 0) {
      obj.ledger_seq = Math.round(message.ledgerSeq);
    }
    if (message.sourceAddress !== undefined && message.sourceAddress !== "") {
      obj.source_address = message.sourceAddress;
    }
    if (message.actualFee !== undefined && message.actualFee !== 0) {
      obj.actual_fee = Math.round(message.actualFee);
    }
    if (message.status !== undefined && message.status !== 0) {
      obj.status = statusCodesToJSON(message.status);
    }
    if (message.statusDesc !== undefined && message.statusDesc !== "") {
      obj.status_desc = message.statusDesc;
    }
    if (message.baseTransaction !== undefined) {
      obj.base_transaction = TransactionEnv.toJSON(message.baseTransaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransactionBase>, I>>(
    base?: I,
  ): TransactionBase {
    return TransactionBase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransactionBase>, I>>(
    object: I,
  ): TransactionBase {
    const message = createBaseTransactionBase();
    message.id = object.id ?? "";
    message.txId = object.txId ?? "";
    message.hash = object.hash ?? "";
    message.apiKey = object.apiKey ?? "";
    message.txType = object.txType ?? 0;
    message.createTime = object.createTime ?? "";
    message.ledgerSeq = object.ledgerSeq ?? 0;
    message.sourceAddress = object.sourceAddress ?? "";
    message.actualFee = object.actualFee ?? 0;
    message.status = object.status ?? 0;
    message.statusDesc = object.statusDesc ?? "";
    message.baseTransaction =
      object.baseTransaction !== undefined && object.baseTransaction !== null
        ? TransactionEnv.fromPartial(object.baseTransaction)
        : undefined;
    return message;
  },
};

function createBaseQueryResult(): QueryResult {
  return { count: 0, totalPage: 0, transactionBases: [] };
}

export const QueryResult: MessageFns<QueryResult> = {
  encode(
    message: QueryResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.count !== undefined && message.count !== 0) {
      writer.uint32(8).int64(message.count);
    }
    if (message.totalPage !== undefined && message.totalPage !== 0) {
      writer.uint32(16).int64(message.totalPage);
    }
    if (
      message.transactionBases !== undefined &&
      message.transactionBases.length !== 0
    ) {
      for (const v of message.transactionBases) {
        TransactionBase.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPage = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = TransactionBase.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.transactionBases!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryResult {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      totalPage: isSet(object.total_page)
        ? globalThis.Number(object.total_page)
        : 0,
      transactionBases: globalThis.Array.isArray(object?.transaction_bases)
        ? object.transaction_bases.map((e: any) => TransactionBase.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryResult): unknown {
    const obj: any = {};
    if (message.count !== undefined && message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.totalPage !== undefined && message.totalPage !== 0) {
      obj.total_page = Math.round(message.totalPage);
    }
    if (message.transactionBases?.length) {
      obj.transaction_bases = message.transactionBases.map((e) =>
        TransactionBase.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryResult>, I>>(base?: I): QueryResult {
    return QueryResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryResult>, I>>(
    object: I,
  ): QueryResult {
    const message = createBaseQueryResult();
    message.count = object.count ?? 0;
    message.totalPage = object.totalPage ?? 0;
    message.transactionBases =
      object.transactionBases?.map((e) => TransactionBase.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryResponse(): QueryResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const QueryResponse: MessageFns<QueryResponse> = {
  encode(
    message: QueryResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      QueryResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = QueryResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? QueryResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: QueryResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = QueryResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryResponse>, I>>(
    base?: I,
  ): QueryResponse {
    return QueryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryResponse>, I>>(
    object: I,
  ): QueryResponse {
    const message = createBaseQueryResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? QueryResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseGetTransactionCacheRequest(): GetTransactionCacheRequest {
  return { limit: 0, hash: "", address: "" };
}

export const GetTransactionCacheRequest: MessageFns<GetTransactionCacheRequest> =
  {
    encode(
      message: GetTransactionCacheRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.limit !== undefined && message.limit !== 0) {
        writer.uint32(16).int64(message.limit);
      }
      if (message.hash !== undefined && message.hash !== "") {
        writer.uint32(26).string(message.hash);
      }
      if (message.address !== undefined && message.address !== "") {
        writer.uint32(34).string(message.address);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetTransactionCacheRequest {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetTransactionCacheRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.limit = longToNumber(reader.int64());
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.hash = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.address = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetTransactionCacheRequest {
      return {
        limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
        hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
        address: isSet(object.address) ? globalThis.String(object.address) : "",
      };
    },

    toJSON(message: GetTransactionCacheRequest): unknown {
      const obj: any = {};
      if (message.limit !== undefined && message.limit !== 0) {
        obj.limit = Math.round(message.limit);
      }
      if (message.hash !== undefined && message.hash !== "") {
        obj.hash = message.hash;
      }
      if (message.address !== undefined && message.address !== "") {
        obj.address = message.address;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetTransactionCacheRequest>, I>>(
      base?: I,
    ): GetTransactionCacheRequest {
      return GetTransactionCacheRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetTransactionCacheRequest>, I>>(
      object: I,
    ): GetTransactionCacheRequest {
      const message = createBaseGetTransactionCacheRequest();
      message.limit = object.limit ?? 0;
      message.hash = object.hash ?? "";
      message.address = object.address ?? "";
      return message;
    },
  };

function createBasePlatformTransaction(): PlatformTransaction {
  return { transactions: undefined };
}

export const PlatformTransaction: MessageFns<PlatformTransaction> = {
  encode(
    message: PlatformTransaction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transactions !== undefined) {
      TransactionBase.encode(
        message.transactions,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PlatformTransaction {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions = TransactionBase.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformTransaction {
    return {
      transactions: isSet(object.transactions)
        ? TransactionBase.fromJSON(object.transactions)
        : undefined,
    };
  },

  toJSON(message: PlatformTransaction): unknown {
    const obj: any = {};
    if (message.transactions !== undefined) {
      obj.transactions = TransactionBase.toJSON(message.transactions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlatformTransaction>, I>>(
    base?: I,
  ): PlatformTransaction {
    return PlatformTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlatformTransaction>, I>>(
    object: I,
  ): PlatformTransaction {
    const message = createBasePlatformTransaction();
    message.transactions =
      object.transactions !== undefined && object.transactions !== null
        ? TransactionBase.fromPartial(object.transactions)
        : undefined;
    return message;
  },
};

function createBaseChainTransaction(): ChainTransaction {
  return {
    status: "",
    incomingTime: "",
    hash: "",
    signatures: [],
    transaction: undefined,
  };
}

export const ChainTransaction: MessageFns<ChainTransaction> = {
  encode(
    message: ChainTransaction,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.status !== undefined && message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.incomingTime !== undefined && message.incomingTime !== "") {
      writer.uint32(18).string(message.incomingTime);
    }
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(26).string(message.hash);
    }
    if (message.signatures !== undefined && message.signatures.length !== 0) {
      for (const v of message.signatures) {
        Signature.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainTransaction {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.incomingTime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = Signature.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.signatures!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainTransaction {
    return {
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      incomingTime: isSet(object.incoming_time)
        ? globalThis.String(object.incoming_time)
        : "",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => Signature.fromJSON(e))
        : [],
      transaction: isSet(object.transaction)
        ? Transaction.fromJSON(object.transaction)
        : undefined,
    };
  },

  toJSON(message: ChainTransaction): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== "") {
      obj.status = message.status;
    }
    if (message.incomingTime !== undefined && message.incomingTime !== "") {
      obj.incoming_time = message.incomingTime;
    }
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => Signature.toJSON(e));
    }
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainTransaction>, I>>(
    base?: I,
  ): ChainTransaction {
    return ChainTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainTransaction>, I>>(
    object: I,
  ): ChainTransaction {
    const message = createBaseChainTransaction();
    message.status = object.status ?? "";
    message.incomingTime = object.incomingTime ?? "";
    message.hash = object.hash ?? "";
    message.signatures =
      object.signatures?.map((e) => Signature.fromPartial(e)) || [];
    message.transaction =
      object.transaction !== undefined && object.transaction !== null
        ? Transaction.fromPartial(object.transaction)
        : undefined;
    return message;
  },
};

function createBaseGetTransactionCacheChainResult(): GetTransactionCacheChainResult {
  return { totalCount: 0, transactions: [] };
}

export const GetTransactionCacheChainResult: MessageFns<GetTransactionCacheChainResult> =
  {
    encode(
      message: GetTransactionCacheChainResult,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.totalCount !== undefined && message.totalCount !== 0) {
        writer.uint32(8).int64(message.totalCount);
      }
      if (
        message.transactions !== undefined &&
        message.transactions.length !== 0
      ) {
        for (const v of message.transactions) {
          ChainTransaction.encode(v!, writer.uint32(26).fork()).join();
        }
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetTransactionCacheChainResult {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetTransactionCacheChainResult();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.totalCount = longToNumber(reader.int64());
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            const el = ChainTransaction.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.transactions!.push(el);
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetTransactionCacheChainResult {
      return {
        totalCount: isSet(object.total_count)
          ? globalThis.Number(object.total_count)
          : 0,
        transactions: globalThis.Array.isArray(object?.transactions)
          ? object.transactions.map((e: any) => ChainTransaction.fromJSON(e))
          : [],
      };
    },

    toJSON(message: GetTransactionCacheChainResult): unknown {
      const obj: any = {};
      if (message.totalCount !== undefined && message.totalCount !== 0) {
        obj.total_count = Math.round(message.totalCount);
      }
      if (message.transactions?.length) {
        obj.transactions = message.transactions.map((e) =>
          ChainTransaction.toJSON(e),
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetTransactionCacheChainResult>, I>>(
      base?: I,
    ): GetTransactionCacheChainResult {
      return GetTransactionCacheChainResult.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<GetTransactionCacheChainResult>, I>,
    >(object: I): GetTransactionCacheChainResult {
      const message = createBaseGetTransactionCacheChainResult();
      message.totalCount = object.totalCount ?? 0;
      message.transactions =
        object.transactions?.map((e) => ChainTransaction.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseGetTransactionCachePlatResult(): GetTransactionCachePlatResult {
  return { totalCount: 0, transactions: [] };
}

export const GetTransactionCachePlatResult: MessageFns<GetTransactionCachePlatResult> =
  {
    encode(
      message: GetTransactionCachePlatResult,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.totalCount !== undefined && message.totalCount !== 0) {
        writer.uint32(8).int64(message.totalCount);
      }
      if (
        message.transactions !== undefined &&
        message.transactions.length !== 0
      ) {
        for (const v of message.transactions) {
          TransactionEnv.encode(v!, writer.uint32(26).fork()).join();
        }
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetTransactionCachePlatResult {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetTransactionCachePlatResult();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.totalCount = longToNumber(reader.int64());
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            const el = TransactionEnv.decode(reader, reader.uint32());
            if (el !== undefined) {
              message.transactions!.push(el);
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetTransactionCachePlatResult {
      return {
        totalCount: isSet(object.total_count)
          ? globalThis.Number(object.total_count)
          : 0,
        transactions: globalThis.Array.isArray(object?.transactions)
          ? object.transactions.map((e: any) => TransactionEnv.fromJSON(e))
          : [],
      };
    },

    toJSON(message: GetTransactionCachePlatResult): unknown {
      const obj: any = {};
      if (message.totalCount !== undefined && message.totalCount !== 0) {
        obj.total_count = Math.round(message.totalCount);
      }
      if (message.transactions?.length) {
        obj.transactions = message.transactions.map((e) =>
          TransactionEnv.toJSON(e),
        );
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetTransactionCachePlatResult>, I>>(
      base?: I,
    ): GetTransactionCachePlatResult {
      return GetTransactionCachePlatResult.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GetTransactionCachePlatResult>, I>>(
      object: I,
    ): GetTransactionCachePlatResult {
      const message = createBaseGetTransactionCachePlatResult();
      message.totalCount = object.totalCount ?? 0;
      message.transactions =
        object.transactions?.map((e) => TransactionEnv.fromPartial(e)) || [];
      return message;
    },
  };

function createBaseGetTransactionCacheChainResponse(): GetTransactionCacheChainResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const GetTransactionCacheChainResponse: MessageFns<GetTransactionCacheChainResponse> =
  {
    encode(
      message: GetTransactionCacheChainResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.trace !== undefined && message.trace !== "") {
        writer.uint32(10).string(message.trace);
      }
      if (message.result !== undefined) {
        GetTransactionCacheChainResult.encode(
          message.result,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.success !== undefined && message.success !== false) {
        writer.uint32(24).bool(message.success);
      }
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(32).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(42).string(message.errorDesc);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetTransactionCacheChainResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetTransactionCacheChainResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.trace = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.result = GetTransactionCacheChainResult.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.success = reader.bool();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetTransactionCacheChainResponse {
      return {
        trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
        result: isSet(object.result)
          ? GetTransactionCacheChainResult.fromJSON(object.result)
          : undefined,
        success: isSet(object.success)
          ? globalThis.Boolean(object.success)
          : false,
        errorCode: isSet(object.error_code)
          ? statusCodesFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
      };
    },

    toJSON(message: GetTransactionCacheChainResponse): unknown {
      const obj: any = {};
      if (message.trace !== undefined && message.trace !== "") {
        obj.trace = message.trace;
      }
      if (message.result !== undefined) {
        obj.result = GetTransactionCacheChainResult.toJSON(message.result);
      }
      if (message.success !== undefined && message.success !== false) {
        obj.success = message.success;
      }
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = statusCodesToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetTransactionCacheChainResponse>, I>>(
      base?: I,
    ): GetTransactionCacheChainResponse {
      return GetTransactionCacheChainResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<GetTransactionCacheChainResponse>, I>,
    >(object: I): GetTransactionCacheChainResponse {
      const message = createBaseGetTransactionCacheChainResponse();
      message.trace = object.trace ?? "";
      message.result =
        object.result !== undefined && object.result !== null
          ? GetTransactionCacheChainResult.fromPartial(object.result)
          : undefined;
      message.success = object.success ?? false;
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      return message;
    },
  };

function createBaseGetTransactionCachePlatResponse(): GetTransactionCachePlatResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const GetTransactionCachePlatResponse: MessageFns<GetTransactionCachePlatResponse> =
  {
    encode(
      message: GetTransactionCachePlatResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.trace !== undefined && message.trace !== "") {
        writer.uint32(10).string(message.trace);
      }
      if (message.result !== undefined) {
        GetTransactionCachePlatResult.encode(
          message.result,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.success !== undefined && message.success !== false) {
        writer.uint32(24).bool(message.success);
      }
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        writer.uint32(32).int32(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        writer.uint32(42).string(message.errorDesc);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): GetTransactionCachePlatResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetTransactionCachePlatResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.trace = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.result = GetTransactionCachePlatResult.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.success = reader.bool();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.errorCode = reader.int32() as any;
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.errorDesc = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetTransactionCachePlatResponse {
      return {
        trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
        result: isSet(object.result)
          ? GetTransactionCachePlatResult.fromJSON(object.result)
          : undefined,
        success: isSet(object.success)
          ? globalThis.Boolean(object.success)
          : false,
        errorCode: isSet(object.error_code)
          ? statusCodesFromJSON(object.error_code)
          : 0,
        errorDesc: isSet(object.error_desc)
          ? globalThis.String(object.error_desc)
          : "",
      };
    },

    toJSON(message: GetTransactionCachePlatResponse): unknown {
      const obj: any = {};
      if (message.trace !== undefined && message.trace !== "") {
        obj.trace = message.trace;
      }
      if (message.result !== undefined) {
        obj.result = GetTransactionCachePlatResult.toJSON(message.result);
      }
      if (message.success !== undefined && message.success !== false) {
        obj.success = message.success;
      }
      if (message.errorCode !== undefined && message.errorCode !== 0) {
        obj.error_code = statusCodesToJSON(message.errorCode);
      }
      if (message.errorDesc !== undefined && message.errorDesc !== "") {
        obj.error_desc = message.errorDesc;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<GetTransactionCachePlatResponse>, I>>(
      base?: I,
    ): GetTransactionCachePlatResponse {
      return GetTransactionCachePlatResponse.fromPartial(base ?? ({} as any));
    },
    fromPartial<
      I extends Exact<DeepPartial<GetTransactionCachePlatResponse>, I>,
    >(object: I): GetTransactionCachePlatResponse {
      const message = createBaseGetTransactionCachePlatResponse();
      message.trace = object.trace ?? "";
      message.result =
        object.result !== undefined && object.result !== null
          ? GetTransactionCachePlatResult.fromPartial(object.result)
          : undefined;
      message.success = object.success ?? false;
      message.errorCode = object.errorCode ?? 0;
      message.errorDesc = object.errorDesc ?? "";
      return message;
    },
  };

function createBaseDiscardRequest(): DiscardRequest {
  return { hash: "", page: 0, pageSize: 0 };
}

export const DiscardRequest: MessageFns<DiscardRequest> = {
  encode(
    message: DiscardRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.hash !== undefined && message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.page !== undefined && message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== undefined && message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscardRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscardRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiscardRequest {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: DiscardRequest): unknown {
    const obj: any = {};
    if (message.hash !== undefined && message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.page !== undefined && message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== undefined && message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiscardRequest>, I>>(
    base?: I,
  ): DiscardRequest {
    return DiscardRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiscardRequest>, I>>(
    object: I,
  ): DiscardRequest {
    const message = createBaseDiscardRequest();
    message.hash = object.hash ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseDiscardResult(): DiscardResult {
  return { count: 0, totalPage: 0, transactionBases: [] };
}

export const DiscardResult: MessageFns<DiscardResult> = {
  encode(
    message: DiscardResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.count !== undefined && message.count !== 0) {
      writer.uint32(8).int64(message.count);
    }
    if (message.totalPage !== undefined && message.totalPage !== 0) {
      writer.uint32(16).int64(message.totalPage);
    }
    if (
      message.transactionBases !== undefined &&
      message.transactionBases.length !== 0
    ) {
      for (const v of message.transactionBases) {
        TransactionBase.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscardResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscardResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPage = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = TransactionBase.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.transactionBases!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiscardResult {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      totalPage: isSet(object.total_page)
        ? globalThis.Number(object.total_page)
        : 0,
      transactionBases: globalThis.Array.isArray(object?.transaction_bases)
        ? object.transaction_bases.map((e: any) => TransactionBase.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DiscardResult): unknown {
    const obj: any = {};
    if (message.count !== undefined && message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.totalPage !== undefined && message.totalPage !== 0) {
      obj.total_page = Math.round(message.totalPage);
    }
    if (message.transactionBases?.length) {
      obj.transaction_bases = message.transactionBases.map((e) =>
        TransactionBase.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiscardResult>, I>>(
    base?: I,
  ): DiscardResult {
    return DiscardResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiscardResult>, I>>(
    object: I,
  ): DiscardResult {
    const message = createBaseDiscardResult();
    message.count = object.count ?? 0;
    message.totalPage = object.totalPage ?? 0;
    message.transactionBases =
      object.transactionBases?.map((e) => TransactionBase.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDiscardResponse(): DiscardResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const DiscardResponse: MessageFns<DiscardResponse> = {
  encode(
    message: DiscardResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      DiscardResult.encode(message.result, writer.uint32(18).fork()).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscardResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscardResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = DiscardResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiscardResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? DiscardResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: DiscardResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = DiscardResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiscardResponse>, I>>(
    base?: I,
  ): DiscardResponse {
    return DiscardResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiscardResponse>, I>>(
    object: I,
  ): DiscardResponse {
    const message = createBaseDiscardResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? DiscardResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

function createBaseGetTxCacheSizeResult(): GetTxCacheSizeResult {
  return { queueSize: 0 };
}

export const GetTxCacheSizeResult: MessageFns<GetTxCacheSizeResult> = {
  encode(
    message: GetTxCacheSizeResult,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.queueSize !== undefined && message.queueSize !== 0) {
      writer.uint32(8).int64(message.queueSize);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetTxCacheSizeResult {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTxCacheSizeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.queueSize = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTxCacheSizeResult {
    return {
      queueSize: isSet(object.queue_size)
        ? globalThis.Number(object.queue_size)
        : 0,
    };
  },

  toJSON(message: GetTxCacheSizeResult): unknown {
    const obj: any = {};
    if (message.queueSize !== undefined && message.queueSize !== 0) {
      obj.queue_size = Math.round(message.queueSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTxCacheSizeResult>, I>>(
    base?: I,
  ): GetTxCacheSizeResult {
    return GetTxCacheSizeResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTxCacheSizeResult>, I>>(
    object: I,
  ): GetTxCacheSizeResult {
    const message = createBaseGetTxCacheSizeResult();
    message.queueSize = object.queueSize ?? 0;
    return message;
  },
};

function createBaseGetTxCacheSizeResponse(): GetTxCacheSizeResponse {
  return {
    trace: "",
    result: undefined,
    success: false,
    errorCode: 0,
    errorDesc: "",
  };
}

export const GetTxCacheSizeResponse: MessageFns<GetTxCacheSizeResponse> = {
  encode(
    message: GetTxCacheSizeResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.trace !== undefined && message.trace !== "") {
      writer.uint32(10).string(message.trace);
    }
    if (message.result !== undefined) {
      GetTxCacheSizeResult.encode(
        message.result,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.success !== undefined && message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(32).int32(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      writer.uint32(42).string(message.errorDesc);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): GetTxCacheSizeResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTxCacheSizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = GetTxCacheSizeResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorDesc = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTxCacheSizeResponse {
    return {
      trace: isSet(object.trace) ? globalThis.String(object.trace) : "",
      result: isSet(object.result)
        ? GetTxCacheSizeResult.fromJSON(object.result)
        : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      errorCode: isSet(object.error_code)
        ? statusCodesFromJSON(object.error_code)
        : 0,
      errorDesc: isSet(object.error_desc)
        ? globalThis.String(object.error_desc)
        : "",
    };
  },

  toJSON(message: GetTxCacheSizeResponse): unknown {
    const obj: any = {};
    if (message.trace !== undefined && message.trace !== "") {
      obj.trace = message.trace;
    }
    if (message.result !== undefined) {
      obj.result = GetTxCacheSizeResult.toJSON(message.result);
    }
    if (message.success !== undefined && message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.error_code = statusCodesToJSON(message.errorCode);
    }
    if (message.errorDesc !== undefined && message.errorDesc !== "") {
      obj.error_desc = message.errorDesc;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTxCacheSizeResponse>, I>>(
    base?: I,
  ): GetTxCacheSizeResponse {
    return GetTxCacheSizeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTxCacheSizeResponse>, I>>(
    object: I,
  ): GetTxCacheSizeResponse {
    const message = createBaseGetTxCacheSizeResponse();
    message.trace = object.trace ?? "";
    message.result =
      object.result !== undefined && object.result !== null
        ? GetTxCacheSizeResult.fromPartial(object.result)
        : undefined;
    message.success = object.success ?? false;
    message.errorCode = object.errorCode ?? 0;
    message.errorDesc = object.errorDesc ?? "";
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
